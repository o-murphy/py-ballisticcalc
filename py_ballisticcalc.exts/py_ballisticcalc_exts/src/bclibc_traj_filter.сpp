#include <cmath>
#include <algorithm>
#include <vector>
#include "bclibc_base_traj_seq.h"
#include "bclibc_traj_filter.hpp"

BCLIBC_TrajectoryDataFilter::BCLIBC_TrajectoryDataFilter(
    const BCLIBC_ShotProps *props,
    BCLIBC_TrajFlag filter_flags,
    BCLIBC_V3dT initial_position,
    BCLIBC_V3dT initial_velocity,
    double barrel_angle_rad,
    double look_angle_rad,
    double range_limit,
    double range_step,
    double time_step)
    : props(props),
      filter(filter_flags),
      seen_zero(BCLIBC_TRAJ_FLAG_NONE),
      time_of_last_record(0.0),
      time_step(time_step),
      range_step(range_step),
      range_limit(range_limit),
      prev_data(),
      prev_prev_data(),
      next_record_distance(0.0),
      look_angle_rad(look_angle_rad),
      look_angle_tangent(std::tan(look_angle_rad))
{
    if (filter & BCLIBC_TRAJ_FLAG_MACH)
    {
        double mach;
        double density_ratio;
        BCLIBC_Atmosphere_updateDensityFactorAndMachForAltitude(
            &props->atmo,
            initial_position.y,
            &density_ratio,
            &mach);

        if (BCLIBC_V3dT_mag(&initial_velocity) < mach)
        {
            // If we start below Mach 1, we won't look for Mach crossings
            this->filter = (BCLIBC_TrajFlag)((int)this->filter & ~(int)BCLIBC_TRAJ_FLAG_MACH);
        }
    }

    if (filter & BCLIBC_TRAJ_FLAG_ZERO)
    {
        if (initial_position.y >= 0)
        {
            // If shot starts above zero then we will only look for a ZERO_DOWN crossing through the line of sight.
            this->filter = (BCLIBC_TrajFlag)(this->filter & BCLIBC_TRAJ_FLAG_ZERO_UP);
        }
        else if (initial_position.y < 0 && barrel_angle_rad <= look_angle_rad)
        {
            // If shot starts below zero and barrel points below line of sight we won't look for any crossings.
            this->filter = (BCLIBC_TrajFlag)(this->filter & ~(BCLIBC_TRAJ_FLAG_ZERO | BCLIBC_TRAJ_FLAG_MRT));
        }
    }
};

bool BCLIBC_TrajectoryDataFilter::can_interpolate(const BCLIBC_BaseTrajData *new_data) const
{
    return (this->prev_data.time < new_data->time) &&
           (this->prev_prev_data.time < this->prev_data.time);
}

void BCLIBC_TrajectoryDataFilter::record(BCLIBC_BaseTrajData *new_data)
{
    if (new_data == nullptr)
    {
        return;
    };

    std::vector<BCLIBC_FlaggedData> rows;
    bool is_can_interpolate = this->can_interpolate(new_data);

    if (new_data->time == 0.0)
    {
        // Always record starting point
        this->add_row(&rows, new_data, (this->range_step > 0 || this->time_step) ? BCLIBC_TRAJ_FLAG_RANGE : BCLIBC_TRAJ_FLAG_NONE);
    }
    else
    {
        // region RANGE steps
        if (this->range_step > 0.0)
        {
            while (this->next_record_distance + this->range_step - this->EPSILON <= new_data->position.x)
            {
                BCLIBC_BaseTrajData result_data = {};
                bool found_data = false;
                double record_distance = this->next_record_distance + this->range_step;
                if (record_distance > this->range_limit + this->EPSILON)
                {
                    this->range_step = -1;
                    break;
                }
                if (std::fabs(record_distance - new_data->position.x) < this->EPSILON)
                {
                    result_data = *new_data;
                    found_data = true;
                }
                else if (is_can_interpolate) /* if (this->prev_data && this->prev_prev_data) */
                {
                    BCLIBC_ErrorType err = BCLIBC_BaseTrajData_interpolate(
                        BCLIBC_INTERP_KEY_POS_X,
                        record_distance,
                        &this->prev_prev_data,
                        &this->prev_data,
                        new_data,
                        &result_data);
                    if (err == BCLIBC_E_NO_ERROR)
                    {
                        found_data = true;
                    }
                }
                if (found_data)
                {
                    this->next_record_distance += this->range_step;
                    this->add_row(&rows, &result_data, BCLIBC_TRAJ_FLAG_RANGE);
                    this->time_of_last_record = result_data.time;
                }
                else
                {
                    // Can't interpolate without valid data/segment
                    break;
                }
            }
        }
        // endregion RANGE steps
        // region Time steps
        if (is_can_interpolate && this->time_step > 0.0)
        {
            while (this->time_of_last_record + this->time_step - this->EPSILON <= new_data->time)
            {

                this->time_of_last_record += this->time_step;
                BCLIBC_BaseTrajData result_data = {};

                BCLIBC_ErrorType err = BCLIBC_BaseTrajData_interpolate(
                    BCLIBC_INTERP_KEY_TIME,
                    this->time_of_last_record,
                    &this->prev_prev_data,
                    &this->prev_data,
                    new_data,
                    &result_data);

                if (err == BCLIBC_E_NO_ERROR)
                {
                    this->add_row(&rows, &result_data, BCLIBC_TRAJ_FLAG_RANGE);
                }
                else
                {
                    // Can't interpolate without valid data/segment
                    break;
                }
            }
        }
        // endregion Time steps
        if (
            is_can_interpolate &&
            this->filter & BCLIBC_TRAJ_FLAG_APEX &&
            this->prev_data.velocity.y > 0 &&
            new_data->velocity.y <= 0)
        {
            // "Apex" is the point where the vertical component of velocity goes from positive to negative.
            BCLIBC_BaseTrajData result_data = {};
            BCLIBC_ErrorType err = BCLIBC_BaseTrajData_interpolate(
                BCLIBC_INTERP_KEY_VEL_Y,
                0.0,
                &this->prev_prev_data,
                &this->prev_data,
                new_data,
                &result_data);
            if (err == BCLIBC_E_NO_ERROR)
            {
                // "Apex" is the point where the vertical component of velocity goes from positive to negative.
                this->add_row(&rows, &result_data, BCLIBC_TRAJ_FLAG_APEX);
                this->filter = (BCLIBC_TrajFlag)(this->filter & ~BCLIBC_TRAJ_FLAG_APEX);
            }
            /* Ignore error */
            // else
            // {
            //     // Can't interpolate without valid data/segment
            //     return;
            // }
        }

        // Commit
        if (!rows.empty())
        {
            for (const auto &new_row : rows)
            {
                // FIXME: can be replaced with this->records.emplace_back(this->props, &new_flagged_data_row);
                BCLIBC_TrajectoryData final_record(this->props, &new_row);
                this->records.push_back(final_record);
            }
        }

        // region Points that must be interpolated on TrajectoryData instances
        if (is_can_interpolate)
        {
            BCLIBC_TrajFlag compute_flags = BCLIBC_TRAJ_FLAG_NONE;
            if (
                this->filter & BCLIBC_TRAJ_FLAG_MACH &&
                BCLIBC_V3dT_mag(&new_data->velocity) < new_data->mach)
            {
                compute_flags = (BCLIBC_TrajFlag)(compute_flags | BCLIBC_TRAJ_FLAG_MACH);
                this->filter = (BCLIBC_TrajFlag)(this->filter & ~BCLIBC_TRAJ_FLAG_MACH); // Don't look for more Mach crossings
            }
            // region ZERO checks (done on TrajectoryData objects so we can interpolate for .slant_height)
            if (this->filter & BCLIBC_TRAJ_FLAG_ZERO)
            {
                // Zero reference line is the sight line defined by look_angle
                double reference_height = new_data->position.x * this->look_angle_tangent;
                // If we haven't seen ZERO_UP, we look for that first
                if (this->filter & BCLIBC_TRAJ_FLAG_ZERO_UP)
                {
                    if (new_data->position.y >= reference_height)
                    {
                        compute_flags = (BCLIBC_TrajFlag)(compute_flags | BCLIBC_TRAJ_FLAG_ZERO_UP);
                        this->filter = (BCLIBC_TrajFlag)(this->filter & ~BCLIBC_TRAJ_FLAG_ZERO_UP);
                    }
                }
                // We've crossed above sight line; now look for crossing back through it
                else if (this->filter & BCLIBC_TRAJ_FLAG_ZERO_DOWN)
                {
                    if (new_data->position.y < reference_height)
                    {
                        compute_flags = (BCLIBC_TrajFlag)(compute_flags | BCLIBC_TRAJ_FLAG_ZERO_DOWN);
                        this->filter = (BCLIBC_TrajFlag)(this->filter & ~BCLIBC_TRAJ_FLAG_ZERO_DOWN);
                    }
                }
            }
            // endregion ZERO checks
            if (compute_flags)
            {
                // Instantiate TrajectoryData and interpolate
                BCLIBC_TrajectoryData t0(this->props, new_data);
                BCLIBC_TrajectoryData t1(this->props, &this->prev_data);
                BCLIBC_TrajectoryData t2(this->props, &this->prev_prev_data);
                std::vector<BCLIBC_TrajectoryData> add_td;
                if (compute_flags & BCLIBC_TRAJ_FLAG_MACH)
                {
                    add_td.push_back(
                        BCLIBC_TrajectoryData::interpolate(
                            BCLIBC_INTERP_KEY_MACH,
                            1.0,
                            &t0, &t1, &t2,
                            BCLIBC_TRAJ_FLAG_MACH));
                }
                if (compute_flags & BCLIBC_TRAJ_FLAG_ZERO)
                {
                    add_td.push_back(
                        BCLIBC_TrajectoryData::interpolate(
                            BCLIBC_INTERP_KEY_SLANT_HEIGHT,
                            0.0,
                            &t0, &t1, &t2,
                            compute_flags));
                }
                // Add TrajectoryData, keeping `results` sorted by time.
                for (const auto &td : add_td)
                {
                    // bisect_left
                    auto it = std::lower_bound(
                        this->records.begin(),
                        this->records.end(),
                        td.time,
                        [](const BCLIBC_TrajectoryData &record_data, double time_to_find)
                        {
                            return record_data.time < time_to_find;
                        });

                    if (it != this->records.end() && std::fabs(it->time - td.time) < this->SEPARATE_ROW_TIME_DELTA)
                    {
                        it->flag = (BCLIBC_TrajFlag)(it->flag | td.flag);
                        continue;
                    }

                    if (it != this->records.begin())
                    {
                        auto prev_it = std::prev(it);

                        if (std::fabs(prev_it->time - td.time) < this->SEPARATE_ROW_TIME_DELTA)
                        {
                            prev_it->flag = (BCLIBC_TrajFlag)(prev_it->flag | td.flag);
                            continue;
                        }
                    }

                    this->records.insert(it, td);
                }
            }
        }
        // ...

        // endregion
        this->prev_prev_data = this->prev_data;
        this->prev_data = *new_data;
    }
};

void BCLIBC_TrajectoryDataFilter::add_row(std::vector<BCLIBC_FlaggedData> *rows, BCLIBC_BaseTrajData *data, BCLIBC_TrajFlag flag)
{
    if (rows == nullptr || data == nullptr)
    {
        return;
    }

    // Find index by time (std::lower_bound - equal bisect_left)
    auto it = std::lower_bound(
        rows->begin(),
        rows->end(),
        data->time,
        // C++ lambda-comparison index:
        [](const BCLIBC_FlaggedData &row_data, double time_to_find)
        {
            return row_data.data.time < time_to_find;
        });

    size_t idx = std::distance(rows->begin(), it);

    // If we match existing row's time then just add this flag to the row

    if (idx < rows->size())
    {
        double time_at_idx = it->data.time;

        if (std::fabs(time_at_idx - data->time) < this->SEPARATE_ROW_TIME_DELTA)
        {
            it->flag = (BCLIBC_TrajFlag)(it->flag | flag);
            return;
        }
    }

    if (idx > 0)
    {
        BCLIBC_FlaggedData &prev_row = (*rows)[idx - 1];

        if (std::fabs(prev_row.data.time - data->time) < this->SEPARATE_ROW_TIME_DELTA)
        {
            prev_row.flag = (BCLIBC_TrajFlag)(prev_row.flag | flag);
            return;
        }
    }

    // Insert at sorted position
    BCLIBC_FlaggedData new_row;
    new_row.data = *data;
    new_row.flag = flag;

    rows->insert(it, new_row);
}