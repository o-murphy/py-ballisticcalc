#!/usr/bin/env python
"""setup.py script for py_ballisticcalc library"""

import os
import platform
from typing import Dict
from setuptools import setup, Extension
from pathlib import Path

try:
    from Cython.Build import cythonize
except ImportError:
    import sys

    # use this command to skip building wheel and compiling modules on unsupported platforms
    # pip install --no-build-isolation --no-binary :all: py-ballisticcalc.exts
    setup()
    sys.exit(0)  # Stop installation

_ENV_VAR_IS_ON = {
    "1",
    "true",
    "yes",
    "on",
}


def env_var_is_enabled(var: str):
    return os.environ.get(var, "0").lower() in _ENV_VAR_IS_ON


ENABLE_CYTHON_COVERAGE = env_var_is_enabled("CYTHON_COVERAGE")
ENABLE_CYTHON_SAFETY = env_var_is_enabled("CYTHON_SAFETY")

# When coverage is requested, force Cython to regenerate C code to avoid stale builds
CYTHON_FORCE_REGEN = env_var_is_enabled("CYTHON_FORCE_REGEN")

compiler_directives = {
    "language_level": 3,
    "embedsignature": True,
    "cdivision": True,  # use with caution! can affect on "/" operator
    "binding": False,  # Keep as False unless you explicitly want Python-level binding methods
    "c_api_binop_methods": True,
    # Suppress noisy warnings about Python-level names (PreferredUnits, Vector, etc.)
    # that are valid Python imports but flagged by Cython's static analyzer.
    "warn.undeclared": False,
    "warn.unreachable": True,
    "warn.maybe_uninitialized": True,
    # Unused warnings are extremely noisy due to autogenerated pickle/state code; disable them.
    "warn.unused": False,
    "warn.unused_arg": False,
    "warn.multiple_declarators": True,
    "show_performance_hints": True,
    # "emit_code_comments": False,
    "freethreading_compatible": True,
}

# Enable line tracing for Cython coverage when requested
if ENABLE_CYTHON_COVERAGE:
    compiler_directives["linetrace"] = True

# When safety is requested, favor correctness checks over speed
if ENABLE_CYTHON_SAFETY:
    compiler_directives.update(
        {
            "boundscheck": True,
            "wraparound": True,
            "initializedcheck": True,
            "nonecheck": True,
            "cdivision": False,
            "overflowcheck": True,
            "embedsignature": True,
        }
    )

EXTENSIONS_BASE_DIR = Path("py_ballisticcalc_exts")

C_SRC_DIR = EXTENSIONS_BASE_DIR / "src"
C_INCLUDE_DIR = EXTENSIONS_BASE_DIR / "include"

# Define all C source files and their paths
C_SOURCES = {
    "v3d": C_SRC_DIR / "bclibc_v3d.c",
    "log": C_SRC_DIR / "bclibc_log.c",
    "error_stack": C_SRC_DIR / "bclibc_error_stack.c",
    "bclib": C_SRC_DIR / "bclibc_bclib.c",
    "bind": C_SRC_DIR / "bclibc_py_bind.c",
    "interp": C_SRC_DIR / "bclibc_interp.c",
    "euler": C_SRC_DIR / "bclibc_euler.c",
    "rk4": C_SRC_DIR / "bclibc_rk4.c",
    "base_traj_seq": C_SRC_DIR / "bclibc_base_traj_seq.c",
    "engine": C_SRC_DIR / "bclibc_engine.c",
    # Add any other C source files here
}

# Define dependencies for each extension as a dictionary
# Keys are extension names (as in extension_names list)
# Values are lists of C source file keys from C_SOURCES that they depend on.
EXTENSION_DEPS = {
    "bind": ["interp", "bclib", "bind", "log"],
    "base_traj_seq": ["interp", "bclib", "base_traj_seq", "log"],
    "base_engine": ["interp", "bclib", "engine", "base_traj_seq", "error_stack", "log"],
    "euler_engine": [
        "v3d",
        "bclib",
        "euler",
        "interp",
        "base_traj_seq",
        "engine",
        "error_stack",
        "log",
    ],
    "rk4_engine": [
        "v3d",
        "bclib",
        "rk4",
        "interp",
        "base_traj_seq",
        "engine",
        "error_stack",
        "log",
    ],
    "trajectory_data": ["interp", "bclib", "log"],
    # Test modules (expose internal C functions for tests only)
    "_test_helpers": ["bclib", "interp", "log"],
    "_test_engine": ["bclib", "interp", "log"],
    "_test_error_stack": ["error_stack", "log"],
}

TEST_EXTENSIONS_DEPS = {}

# Use absolute paths for include directories
include_dirs = [
    EXTENSIONS_BASE_DIR.as_posix(),  # For .pxd files
    C_SRC_DIR.as_posix(),  # For source-level headers
    C_INCLUDE_DIR.as_posix(),  # For public headers
]

# Platform-specific compiler flags
is_msvc = platform.system() == "Windows"

if is_msvc:
    # MSVC-specific flags
    extra_compile_args = [
        "/O2",  # Optimize for speed (or /Od for debug)
        "/W3",  # Warning level 3
    ]
    # Crucial for MSVC on ARM
    if platform.machine().startswith("ARM"):
        extra_compile_args.append("/fp:precise")
else:
    # GCC/Clang flags
    extra_compile_args = [
        "-g",
        "-O0",
        "-std=c99",
    ]


# Dynamically create extensions for names in extension_names
def collect_extensions(deps: Dict[str, Path], path: Path):
    extensions_local = []
    for name, deps in deps.items():
        # Use subproject-local .pyx paths (these exist during build)
        sources = [(path / name).with_suffix(".pyx")]

        # Add dependent C source files from the EXTENSION_DEPS dictionary
        # Use .get(name, []) to safely get an empty list if an extension has no explicit C dependencies
        for dep_key in deps:
            if dep_key in C_SOURCES:
                sources.append(C_SOURCES[dep_key])
            else:
                print(f"Warning: C source '{dep_key}' not found in C_SOURCES dictionary for extension '{name}'.")

        define_macros = []
        if ENABLE_CYTHON_COVERAGE:
            # Enable tracing in both with-GIL and nogil regions
            define_macros.extend([("CYTHON_TRACE", "1"), ("CYTHON_TRACE_NOGIL", "1")])

        extensions_local.append(
            Extension(
                "py_ballisticcalc_exts." + name,
                sources=[s.as_posix() for s in sources],
                include_dirs=include_dirs,
                define_macros=define_macros,
                extra_compile_args=extra_compile_args,
                # libraries=['m'] # For Linux/macOS, add 'm' for math functions. For Windows, usually not needed or part of default C runtime.
            )
        )
    return extensions_local


# Initialize extensions list
extensions_list = []
extensions_list.extend(collect_extensions(EXTENSION_DEPS, EXTENSIONS_BASE_DIR))

# Standard cythonize with a clean in-project build dir; annotate only if coverage requested
extensions = cythonize(
    extensions_list,
    compiler_directives=compiler_directives,
    annotate=True,  # ENABLE_CYTHON_COVERAGE, # whether to generate .html annotations
    build_dir="build",  # to keep built data
    force=ENABLE_CYTHON_COVERAGE or CYTHON_FORCE_REGEN,
)

setup(ext_modules=extensions)
