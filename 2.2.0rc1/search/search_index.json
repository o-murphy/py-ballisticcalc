{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-ballisticcalc","text":"<p>py-ballisticcalc is the most flexible library for ballistic trajectory calculations for Python.</p>"},{"location":"Architecture/","title":"Architecture Overview","text":"<p>This document orients you to the high-level structure and main components of the project so you can find where functionality is implemented.</p> <p>Goals - Keep a compact, well-tested ballistic calculator. - Provide multiple integration engines (pure-Python and Cython-accelerated engines). - Expose consistent APIs and event semantics (zero crossings, Mach crossing, apex) across engines.</p>"},{"location":"Architecture/#high-level-layers","title":"High-level layers","text":""},{"location":"Architecture/#1-public-api","title":"1. Public API","text":"<ul> <li><code>Calculator</code> (in <code>py_ballisticcalc/interface.py</code>) is the top-level helper used by most clients.</li> <li>Unit types and preferences are implemented in <code>py_ballisticcalc/unit.py</code> and <code>PreferredUnits</code>.</li> </ul>"},{"location":"Architecture/#2-scene-shot-description","title":"2. Scene / shot description","text":"<ul> <li><code>py_ballisticcalc.conditions.Shot</code> captures the shot parameters: <code>ammo</code>, <code>weapon</code>, <code>look_angle</code>, <code>relative_angle</code>, winds and atmosphere.</li> <li><code>Ammo</code>, <code>Weapon</code>, and <code>Atmo</code> live in <code>py_ballisticcalc.munition</code> and <code>py_ballisticcalc.conditions</code>.</li> </ul>"},{"location":"Architecture/#3-drag-model","title":"3. Drag model","text":"<ul> <li><code>py_ballisticcalc.drag_model</code> and <code>py_ballisticcalc.drag_tables</code> provide the drag lookup and interpolation used by the integrators.</li> </ul>"},{"location":"Architecture/#4-integration-engines","title":"4. Integration engines","text":"<ul> <li>Engines implement <code>EngineProtocol</code> (see <code>py_ballisticcalc.generics.engine</code>).</li> <li>Python engines:</li> <li><code>py_ballisticcalc.engines.rk4.RK4IntegrationEngine</code></li> <li><code>py_ballisticcalc.engines.euler</code> etc.</li> <li>Cython engines are compiled in <code>py_ballisticcalc.exts/py_ballisticcalc_exts</code> for performance:</li> <li><code>rk4_engine.pyx</code>, <code>euler_engine.pyx</code> implement high-performance numeric integration.</li> </ul>"},{"location":"Architecture/#5-trajectory-data-and-events","title":"5. Trajectory data and events","text":"<ul> <li><code>py_ballisticcalc.trajectory_data</code> defines <code>BaseTrajData</code>, <code>TrajectoryData</code>, <code>TrajFlag</code>, <code>ShotProps</code>, and <code>HitResult</code>.</li> <li>Event flags include: ZERO_UP, ZERO_DOWN, MACH, RANGE, APEX, and they are recorded with union semantics when they occur within a small time window.</li> <li><code>TrajectoryDataFilter</code> (in <code>engines/base_engine.py</code>) is the canonical Python implementation that:</li> <li>Converts raw step samples to recorded <code>TrajectoryData</code> rows.</li> <li>Handles sampling by range/time.</li> <li>Detects events (zero crossings, Mach crossing, apex) and performs interpolation for precise event timestamps/values.</li> <li>Applies unioning of flags within <code>BaseIntegrationEngine.SEPARATE_ROW_TIME_DELTA</code>.</li> </ul>"},{"location":"Architecture/#search-helpers","title":"Search helpers","text":"<ul> <li>The engine provides root-finding and search helpers implemented on top of the integrate() method:</li> <li><code>zero_angle</code>, which falls back on the more computationally demanding but reliable <code>find_zero_angle</code>, finds barrel_elevation to hit a sight distance.</li> <li><code>find_max_range</code> finds angle that maximizes slant range.</li> <li><code>find_apex</code> finds the apex, which is where vertical velocity crosses from positive to negative.</li> <li>To ensure parity between engines, these searches run the same Python-side logic and temporarily relax termination constraints where needed.</li> </ul>"},{"location":"Architecture/#integration-details-parity","title":"Integration details &amp; parity","text":"<ul> <li>Cython engines return dense <code>BaseTrajData</code> samples; Python is responsible for event interpolation. This design keeps the high-level semantics in one place and reduces duplication.</li> <li>Engines use configuration parameters (<code>BaseEngineConfig</code>) such as <code>cMinimumVelocity</code>, <code>cMaximumDrop</code>, <code>cMinimumAltitude</code>, <code>cZeroFindingAccuracy</code>, and <code>cStepMultiplier</code> for step scaling.</li> <li>RK4: default internal time step = <code>DEFAULT_TIME_STEP * calc_step</code> (see <code>RK4IntegrationEngine.get_calc_step</code>).</li> </ul>"},{"location":"Architecture/#where-to-look-when-investigating-bugs","title":"Where to look when investigating bugs","text":"<ul> <li>Event detection and interpolation: <code>py_ballisticcalc.engines.base_engine.TrajectoryDataFilter</code> and <code>py_ballisticcalc.trajectory_data</code>.</li> <li>Cython stepping: <code>py_ballisticcalc.exts/py_ballisticcalc_exts/*.pyx</code> (look for <code>_integrate</code> implementations).</li> <li>High-level search logic (zero/max_range/apex): <code>py_ballisticcalc.engines.base_engine</code> and mirrored logic in the Cython base wrapper <code>base_engine.pyx</code>.</li> </ul>"},{"location":"Architecture/#testing-examples","title":"Testing &amp; examples","text":"<ul> <li>Unit tests: <code>tests/</code> include fixtures and parity tests for the extensions.</li> <li>Notebooks: <code>examples/*.ipynb</code> provide extended examples and visualizations.</li> </ul>"},{"location":"Architecture/#performance-note","title":"Performance note","text":"<ul> <li>Prefer Cython RK4 engine for production runs when <code>py-ballisticcalc[exts]</code> is installed; the Cython modules focus on numeric inner loops and can be recompiled independently.</li> </ul> <p>If you want deeper detail on any of these layers (e.g., a sequence diagram for firing or exact data shapes), let me know which area to expand.</p>"},{"location":"Architecture/#diagrams","title":"Diagrams","text":"<p>The following diagrams give a compact visual summary of the main runtime flows. They use Mermaid syntax which is supported by many documentation viewers (MkDocs with mermaid plugin, GitHub markdown preview with a mermaid extension, etc.).</p>"},{"location":"Architecture/#component-data-flow-high-level","title":"Component / Data-flow (high level)","text":"<pre><code>graph LR\n  subgraph Public\n    Calculator[Calculator]\n  end\n  subgraph Core\n    BaseEng[BaseIntegrationEngine]\n    FilterNode[\"_TrajectoryDataFilter\"]\n    TrajData[TrajectoryData]\n    Hit[HitResult]\n  end\n  subgraph Engines\n    EngineImpl[\"EngineImpl (Python or Cython wrapper)\"]\n    CLayer[\"C-layer stepping (_integrate) - dense BaseTrajData\"]\n  end\n\n  Calculator --&gt;|\"fire() / zero_angle\"| BaseEng\n  BaseEng --&gt;|\"calls\"| EngineImpl\n  EngineImpl -.-&gt;|\"if Cythonized\"| CLayer\n  CLayer --&gt;|\"returns\"| BaseTrajDataList[\"BaseTrajData[]\"]\n  EngineImpl --&gt;|\"returns dense samples\"| BaseTrajDataList\n  BaseTrajDataList --&gt;|\"post-process\"| FilterNode\n  FilterNode --&gt; TrajData\n  TrajData --&gt; Hit\n  Hit --&gt; Calculator\n</code></pre>"},{"location":"Architecture/#runtime-sequence-simplified","title":"Runtime sequence (simplified)","text":"<pre><code>sequenceDiagram\n  participant User as \"User\"\n  participant Calc as \"Calculator\"\n  participant Base as \"BaseIntegrationEngine\"\n  participant Engine as \"EngineImpl\"\n  participant CEngine as \"C engine\"\n  participant Filter as \"_TrajectoryDataFilter\"\n  participant Result as \"HitResult\"\n\n  User-&gt;&gt;Calc: fire(shot, range, step, flags)\n  Calc-&gt;&gt;Base: integrate(...)\n  Base-&gt;&gt;Engine: _integrate(...)\n  alt Engine is Cython wrapper\n    Engine-&gt;&gt;CEngine: run numeric stepping (RK4/Euler)\n    CEngine--&gt;&gt;Engine: dense BaseTrajData[]\n  else Engine is Python\n    Engine--&gt;&gt;Base: BaseTrajData[] (from Python loop)\n  end\n  Engine-&gt;&gt;Filter: feed BaseTrajData sequentially\n  Filter--&gt;&gt;Engine: TrajectoryData rows (range/time/event sampling + interpolations)\n  Engine-&gt;&gt;Result: HitResult(props, rows, base_data)\n  Result--&gt;&gt;Calc: return\n  Calc--&gt;&gt;User: HitResult\n</code></pre>"},{"location":"Architecture/#zero-finding-search-overview","title":"Zero-finding / search (overview)","text":"<p>The zero-finding methods are implemented on top of <code>integrate()</code>. The search loop repeatedly calls <code>integrate()</code> while adjusting barrel elevation; termination constraints (minimum velocity, max drop, min altitude) may be temporarily relaxed for robust bracketing.</p> <pre><code>flowchart TD\n  Start[\"Caller: find_zero_angle(distance)\"] --&gt; ComputeBracket[\"compute max_range / initial bracket\"]\n  ComputeBracket --&gt; RidderLoop[\"Ridder iterations\"]\n  RidderLoop --&gt; IntegrateCall[\"call integrate(props, target_x, flags=NONE)\"]\n  IntegrateCall --&gt; Analyze[\"result.last_row -&gt; slant_height/distance\"]\n  Analyze --&gt;|converged| Success[\"return barrel elevation\"]\n  Analyze --&gt;|not converged| RidderLoop\n</code></pre> <p>Note: the search flow uses the same <code>integrate()</code> implementation that returns <code>HitResult</code>. For parity, both Python and Cython engines use the same search code; the Cython engine provides dense samples while Python orchestrates event detection and root-finding.</p>"},{"location":"Cython/","title":"Cython conventions for py-ballisticcalc","text":"<p>This document records the Cython conventions adopted by the project. It explains naming, error handling, Global Interpreter Lock (GIL) usage, and why these choices were made.</p> <p>Goals</p> <ul> <li>Keep hot numerical work free of the Python GIL to maximize throughput.</li> <li>Provide Python-friendly, well-tested public APIs while preserving C-level performance.</li> </ul>"},{"location":"Cython/#gil-and-nogil","title":"GIL and <code>nogil</code>","text":"<ul> <li><code>nogil</code> helpers operate on C types only (primitives, C structs, raw pointers).</li> <li>All allocations performed in <code>nogil</code> must use C allocation (malloc/realloc) and return raw pointers; wrappers must free or wrap these pointers and raise proper Python exceptions if needed.</li> <li>Wrappers acquire GIL (are standard Python <code>def</code>) and construct Python objects from C results.</li> </ul>"},{"location":"Cython/#naming-conventions","title":"Naming conventions","text":"<ul> <li>Nogil helpers: suffix with <code>_nogil</code> or <code>_c_nogil</code> (we use <code>_interpolate_nogil</code>, <code>_append_nogil</code>).</li> <li>Try-style helpers: prefix with <code>_try_</code> for functions that return a status instead of raising (e.g. <code>_try_grow</code>).</li> <li>C-level internal implementations: prefix with <code>_</code> and end with <code>_c</code> for functions that are \"C-level but may be called with the GIL\" (e.g. <code>_append_c</code>).</li> <li>Public Python-facing methods: plain names (e.g. <code>append</code>, <code>interpolate_at</code>). These are <code>def</code> wrappers that call into <code>cdef</code>/<code>nogil</code> helpers.</li> </ul>"},{"location":"Cython/#error-handling-conventions","title":"Error handling conventions","text":"<ul> <li><code>nogil</code> functions must not raise Python exceptions.</li> <li>Use status codes (<code>int</code> or <code>bint</code>) and/or out-parameters to signal errors.</li> <li>Example convention:<ul> <li>return 1 for success, 0 for failure; or</li> <li>return 0 for success and negative error codes for specific failures.</li> </ul> </li> <li>Python wrappers map status codes to Python exceptions (MemoryError, IndexError, ValueError, etc.).</li> <li>For allocators: provide <code>_ensure_capacity_try_nogil</code> that attempts realloc and returns success/failure without raising.</li> </ul>"},{"location":"Cython/#exception-annotation-on-nogil","title":"Exception annotation on nogil","text":"<ul> <li> <p><code>.pxd</code> declarations for <code>nogil</code> functions or module-level functions should have explicit exception values. Cython warns that cimporters calling them without the GIL will require exception checks. If you intend for these functions to never raise Cython exceptions, you must declare them <code>noexcept</code>.</p> </li> <li> <p>Declaring them <code>noexcept</code> in the <code>.pxd</code> is the clearest way to indicate that a function will not propagate a Python exception.</p> </li> <li> <p>Specify an explicit exception value (e.g., <code>except NULL</code> or <code>except False</code>) where appropriate to avoid implicit exception checks if the function can indicate an error via its return value but does not raise a Python exception.</p> </li> </ul>"},{"location":"Cython/#pxd-and-api-exposure","title":".pxd and API exposure","text":"<ul> <li>Declare <code>nogil</code> helpers, <code>cdef</code> functions, and <code>enums</code> in <code>.pxd</code> so they can be <code>cimport</code>ed by other Cython modules and used without Python overhead.</li> <li>Keep public Python wrappers (<code>def</code> methods) unexposed in <code>.pxd</code> by default. This encourages other Cython modules to call the <code>nogil</code> helper or <code>cdef</code> function directly instead of the Python wrapper.</li> </ul>"},{"location":"Cython/#examples-patterns-used","title":"Examples (patterns used)","text":"<ul> <li> <p>Interpolation (nogil core): <pre><code>  cdef enum InterpKey: KEY_TIME, KEY_MACH, KEY_POS_X, ...\n  cdef BaseTrajC* _interpolate_nogil(self, Py_ssize_t idx, InterpKey key_kind, double key_value) nogil\n\n  def interpolate_at(self, idx, key_attribute, key_value):\n      # map key_attribute -&gt; InterpKey\n      with nogil:\n          outp = self._interpolate_nogil(idx, key_kind, key_value)\n      if outp == NULL:\n          raise IndexError(...)\n      result = BaseTrajDataT_create(...)\n      free(outp)\n      return result\n</code></pre></p> </li> <li> <p>Append (nogil fast-path + GIL grow): <pre><code>  cdef bint _ensure_capacity_try_nogil(self, size_t min_capacity) nogil\n  cdef void _append_nogil(self, double time, ...) nogil\n\n  def append(self, time, ...):\n      if not self._ensure_capacity_try_nogil(self._length + 1):\n          # acquire GIL and call a grow function that may raise MemoryError\n          self._ensure_capacity(self._length + 1)\n      with nogil:\n          self._append_nogil(time, ...)\n</code></pre></p> </li> </ul>"},{"location":"Cython/#practical-notes","title":"Practical notes","text":"<ul> <li><code>nogil</code> is only legal on functions that return C types or are annotated to not return Python objects.</li> <li><code>with nogil:</code> blocks are used to call <code>nogil</code> helpers but the block cannot contain Python operations.</li> <li>When calling <code>malloc</code> in <code>nogil</code>, check the return value and <code>return NULL</code> on failure; do not raise Python exceptions inside <code>nogil</code>.</li> <li>In <code>nogil</code> code you can\u2019t safely pass Python <code>cdef class</code> instances (they carry Python object headers and refcounts).</li> </ul>"},{"location":"Cython/#why-this-approach","title":"Why this approach","text":"<ul> <li>Minimizes GIL contention in tight numeric loops (integration engine and interpolation hot paths).</li> <li>Provides explicit, auditable separation of concerns (numeric work vs Python object handling).</li> <li>Gives tests and Python scripts simple interfaces while guaranteeing C-level callers can use the fastest path.</li> </ul>"},{"location":"Cython/#when-to-use-cpdef-vs-cdef-def-wrapper","title":"When to use <code>cpdef</code> vs <code>cdef</code> + <code>def</code> wrapper","text":"<ul> <li> <p>Use <code>cpdef</code> when:</p> <ul> <li>The function is small and its behavior is identical whether called from Python or Cython.</li> <li>You want a convenient, single definition that exposes both a fast C-level entrypoint (for cimports) and a Python-callable function without writing a separate wrapper.</li> <li>The function does not need special GIL management (no <code>nogil</code> core) and does not require bespoke exception mapping or complex Python-object construction.</li> </ul> </li> <li> <p>Prefer <code>cdef</code> + <code>def</code> wrapper when:</p> <ul> <li>The hot-path work must run without the GIL (you need a <code>nogil</code> numeric core) or you need tight control over GIL acquire/release.</li> <li>The function must return Python objects, raise Python exceptions, or perform Python-side housekeeping that should only live in the wrapper.</li> <li>You need different behavior or different APIs for C callers vs Python callers (for example, C callers get raw pointers or status codes while Python callers get high-level objects and exceptions).</li> <li>You want to avoid exposing a C-level symbol to other modules inadvertently; <code>cdef</code> keeps the C API internal unless you explicitly declare it in a <code>.pxd</code>.</li> </ul> </li> <li> <p>Rationale</p> <p><code>cpdef</code> is convenient and can be slightly faster for Python callers than a handwritten wrapper, but it bundles the Python-callable surface with the C implementation. That reduces flexibility and clarity: you get less explicit control of error translation, GIL handling, and resource lifetimes. For numeric hot paths and any code that must be <code>nogil</code>-safe, the <code>cdef</code> + <code>def</code> wrapper pattern is safer and clearer: the <code>cdef</code> core can be <code>nogil</code> and return C-only results/statuses while the <code>def</code> wrapper handles Python conversions and raises exceptions. This separation also helps prevent <code>cimport</code> cycles that can occur when <code>cpdef</code> methods from different modules call each other.</p> </li> <li> <p>Practical decision rule</p> <ul> <li>If the function is purely a utility that both Cython modules and Python code will call and it neither needs <code>nogil</code> nor special exception mapping, <code>cpdef</code> is acceptable.</li> <li>If the function is a hot numeric path, manipulates raw buffers/pointers, or needs careful error/status handling, implement a <code>cdef</code> nogil core and a <code>def</code> wrapper.</li> </ul> </li> </ul>"},{"location":"Cython/#c-helpers","title":"C helpers","text":"<p>For any object in the hot path we create a C helper as follows:</p> <ol> <li>Define a C struct in <code>bclib.h</code>, and list helper functions.  Example: <code>typedef struct ... ShotProps_t</code> and <code>void ShotProps_t_free(ShotProps_t *shot_props_ptr)</code></li> <li>Implement any helper functions in <code>bclib.c</code>.  These are typically to allocate and free memory.  Example: <code>ShotProps_t_free()</code>.</li> <li>Copy the <code>struct</code> as a <code>ctypedef</code> to <code>cy_bindings.pxd</code>.  (This could be automated at compile time but is not at present.)</li> <li>Put any conversion logic in <code>cy_bindings.pyx</code>.  E.g., <code>cdef ShotProps_t ShotProps_t_from_pyshot(object shot_props):</code></li> </ol>"},{"location":"Details/","title":"Developer Details","text":"<p>This page is for contributors who want to modify algorithms, add engines, or extend the project.</p>"},{"location":"Details/#recommended-one-step-dev-setup-cross-platform","title":"Recommended one-step dev setup (cross-platform)","text":"<pre><code># create/sync venv with dev + exts\nuv sync --python 3.12 --dev --extra exts\n\n# install editable local packages into the active venv\nuv pip install -e ./py_ballisticcalc.exts\nuv pip install -e .\n\n# activate &amp; test\nsource .venv/bin/activate   # Linux/macOS\n# .\\.venv\\Scripts\\activate  # Windows\npython -m pytest tests --engine=\"rk4_engine\"\n</code></pre> <p>Notes: - The repo includes a <code>sitecustomize.py</code> that disables user site-packages and warns if you are not using the local <code>.venv</code>, to prevent stale/external packages from shadowing your build. - VS Code settings and <code>.env</code> pin the interpreter to <code>.venv</code> and set <code>PYTHONNOUSERSITE=1</code> automatically.  - If you prefer pip, using <code>python -m pip install -e ./py_ballisticcalc.exts</code> (then <code>python -m pip install -e .</code>) works fine when the venv is activated.</p>"},{"location":"Details/#ci-and-uvlock","title":"CI and <code>uv.lock</code>","text":"<p>Development dependencies and reproducible developer/CI installs are pinned in <code>uv.lock</code>. * This lockfile is for maintainers and CI reproducibility; it is not used by library consumers who install via pip/pyproject. * If you use <code>uv</code> for environment management, run <code>uv sync --dev</code> (optionally with <code>--extra exts</code> to install the Cython subproject) to produce the locked environment used by CI.</p>"},{"location":"Details/#code-locations-responsibilities","title":"Code locations &amp; responsibilities","text":"<ul> <li><code>py_ballisticcalc/</code> \u2014 core Python package.</li> <li><code>engines/</code> \u2014 Python engine implementations and <code>TrajectoryDataFilter</code>.</li> <li><code>trajectory_data.py</code> \u2014 <code>BaseTrajData</code>, <code>TrajectoryData</code>, <code>HitResult</code>, <code>TrajFlag</code>, interpolation helpers.</li> <li><code>conditions.py</code>, <code>munition.py</code> \u2014 shot and environment objects.</li> <li><code>drag_model.py</code>, <code>drag_tables.py</code> \u2014 drag lookup and interpolation.</li> <li><code>py_ballisticcalc.exts/py_ballisticcalc_exts/</code> \u2014 Cython acceleration layer.</li> <li><code>base_engine.pyx</code> \u2014 Cython wrapper that orchestrates C-layer stepping and defers event logic to Python.</li> <li><code>rk4_engine.pyx</code>, <code>euler_engine.pyx</code> \u2014 numeric stepping implementations.</li> <li><code>cy_bindings.pyx/.pxd</code> \u2014 bridging helpers for C structs and helper functions.</li> </ul>"},{"location":"Details/#how-engines-are-wired","title":"How engines are wired","text":"<ul> <li>Public call flow (simplified):</li> <li><code>Calculator.fire()</code> calls <code>engine.integrate()</code>.</li> <li><code>BaseIntegrationEngine.integrate()</code> (Python) converts units, calls engine <code>_integrate()</code>.</li> <li>Python <code>_integrate()</code> returns a <code>HitResult</code> constructed from <code>TrajectoryData</code> rows or (for Cythonized engines) dense <code>BaseTrajData</code> which are post-processed by Python <code>TrajectoryDataFilter</code>.</li> </ul>"},{"location":"Details/#adding-a-new-engine","title":"Adding a new engine","text":"<ol> <li>Implement the <code>EngineProtocol</code> (or subclass <code>BaseIntegrationEngine</code>) and implement <code>_integrate(props, range_limit_ft, range_step_ft, time_step, filter_flags, dense_output)</code>.</li> <li>If using Cython for performance, place numeric stepping in <code>py_ballisticcalc.exts/py_ballisticcalc_exts/*.pyx</code> and keep event detection in Python.</li> <li>Add an entry point in <code>pyproject.toml</code> so <code>Calculator</code> can discover your engine.</li> </ol>"},{"location":"Details/#testing-parity","title":"Testing &amp; parity","text":"<ul> <li>The project runs many parity tests that assert identical results between Python and Cython engines. When adding features, run the whole test suite using the <code>--engine=\"engine_name\"</code> argument.</li> <li>Focus tests on:</li> <li>Event parity (ZERO_UP/ZERO_DOWN/MACH/APEX) and interpolation accuracy.</li> <li>Search functions (<code>find_zero_angle</code>, <code>find_max_range</code>, <code>find_apex</code>).</li> <li>Dense output correctness (HitResult.base_data) and shape.</li> </ul>"},{"location":"Details/#cython-notes-common-pitfalls","title":"Cython notes &amp; common pitfalls","text":"<ul> <li>Cython is used only for performance-critical numeric loops. Keep higher-level semantics in Python to avoid code duplication and subtle parity issues.</li> <li>Common Cython pitfalls observed in this codebase:</li> <li>Indentation and cdef scoping errors \u2014 ensure <code>cdef</code> declarations live at the top of a C function or appropriate scope.</li> <li>Avoid using Python booleans when declaring typed C variables (use <code>bint</code> and 0/1 assignment in the C context).</li> <li>Keep initialisation of C structs and memory allocation clear; release resources in <code>_free_trajectory</code>.</li> </ul>"},{"location":"Details/#debugging-tips","title":"Debugging tips","text":"<ul> <li>Reproduce failure with a focused pytest call (pass the test path) to avoid long runs.</li> <li>Add temporary debug prints in Python-side filter rather than in C to avoid recompiles.</li> <li>To iterate on Cython code rapidly: keep <code>pyx</code> edits small and incremental, run <code>py -m pip install -e .\\py_ballisticcalc.exts</code> to rebuild the extension in-place.</li> </ul>"},{"location":"Details/#build-test-commands","title":"Build / test commands","text":"<pre><code># optional: install editable C extensions and main package\npy -m pip install -e .\\py_ballisticcalc.exts\npy -m pip install -e .\n\n# run a single test file\npy -m pytest tests/test_exts_basic.py -q\n\n# run full tests\npy -m pytest -q\n</code></pre>"},{"location":"Details/#contribution-checklist","title":"Contribution checklist","text":"<ul> <li>Keep parity: match Python reference implementations for event semantics unless you intentionally change behavior (document that change).</li> <li>Add tests for any public behavioral change.</li> <li>Keep Cython numeric code focused on inner loops and return dense samples for Python post-processing.</li> </ul> <p>Where to ask questions - Open an issue on the repository with a minimal reproduction and a note about the engine(s) involved.</p> <p>Appendix: quick reference - Key types: <code>BaseTrajData</code> (dense low-level samples), <code>TrajectoryData</code> (recorded rows with units), <code>ShotProps</code> (float-coded shot parameters), <code>HitResult</code> (result wrapper with <code>.trajectory</code>, <code>.base_data</code>, and <code>.flag()</code> helpers).</p>"},{"location":"Details/#diagrams-developer-view","title":"Diagrams (developer view)","text":""},{"location":"Details/#data-shapes-and-contracts","title":"Data shapes and contracts","text":"<pre><code>classDiagram\n    class ShotProps {\n        +muzzle_velocity_fps: float\n        +barrel_elevation_rad: float\n        +look_angle_rad: float\n        +winds: list\n        +calc_step: float\n        +filter_flags: int\n    }\n    class BaseTrajData {\n        +time: float\n        +position: V3d (x,y,z)  \n        +velocity: V3d\n        +mach: float\n    }\n    class TrajectoryData {\n        +time: float\n        +distance: Distance\n        +height: Distance\n        +slant_height: Distance\n        +flag: int\n    }\n    ShotProps \"1\" --&gt; \"*\" BaseTrajData : produces\n    BaseTrajData \"*\" --&gt; \"*\" TrajectoryData : interpolated by _TrajectoryDataFilter\n</code></pre>"},{"location":"Details/#developer-sequence-integrate-filter-search","title":"Developer sequence: integrate() -&gt; filter -&gt; search","text":"<pre><code>sequenceDiagram\n  participant Dev\n  participant Engine\n  participant CLayer\n  participant Filter\n  participant Search\n\n  Dev-&gt;&gt;Engine: call integrate(props, range_limit, range_step, flags)\n  Engine-&gt;&gt;CLayer: numeric stepping (_integrate) if Cython\n  CLayer--&gt;&gt;Engine: BaseTrajData[]\n  Engine-&gt;&gt;Filter: feed BaseTrajData sequentially\n  Filter--&gt;&gt;Engine: TrajectoryData rows (with interpolated events)\n  Engine-&gt;&gt;Dev: returns HitResult\n  Dev-&gt;&gt;Search: find_zero_angle(distance)\n  Search-&gt;&gt;Engine: repeatedly call integrate() with adjusted barrel_elevation\n  Engine--&gt;&gt;Search: return status rows -&gt; converge\n</code></pre>"},{"location":"Details/#common-cython-pitfalls-visual","title":"Common Cython pitfalls (visual)","text":"<pre><code>graph LR\n  A[Edit pyx file] --&gt; B{Use cdef at correct scope}\n  B -- Wrong --&gt; C[Indentation or cdef scoping errors]\n  B -- Right --&gt; D[Fast numeric loop]\n  C --&gt; E[Compile failure]\n  E --&gt; A\n</code></pre> <p>These diagrams should help new contributors quickly understand how to trace behavior between the Python 'controller' code and the C/Cython numeric inner loop.</p>"},{"location":"QuickStart/","title":"QuickStart","text":"<p>This QuickStart gets you from a fresh environment to running basic ballistic calculations and the provided examples.</p>"},{"location":"QuickStart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+ recommended.</li> <li>A virtual environment for development (venv, conda, etc.).</li> </ul>"},{"location":"QuickStart/#install","title":"Install","text":"<ul> <li>Stable (PyPI):</li> </ul> <pre><code>pip install py-ballisticcalc\n</code></pre> <ul> <li>With native performance extensions (recommended for production/benchmarks):</li> </ul> <pre><code>pip install py-ballisticcalc[exts]\n</code></pre> <ul> <li>From local sources (editable), useful when developing or running tests:</li> </ul> <pre><code># from repo root\npy -m pip install -e .\\py_ballisticcalc.exts   # build/install C extensions (optional)\npy -m pip install -e .                        # main package editable\n</code></pre>"},{"location":"QuickStart/#examples","title":"Examples","text":""},{"location":"QuickStart/#run-a-simple-zero-example","title":"Run a simple zero example","text":"<pre><code>from py_ballisticcalc import *\n\n# create a shot with a simple DragModel\nzero = Shot(weapon=Weapon(sight_height=2), ammo=Ammo(DragModel(0.22, TableG7), mv=Velocity.FPS(2600)))\ncalc = Calculator()\nzero_distance = Distance.Yard(100)\nzero_elevation = calc.set_weapon_zero(zero, zero_distance)\nprint(f'Barrel elevation (total): {zero_elevation}')\n</code></pre>"},{"location":"QuickStart/#fire-and-get-trajectory","title":"Fire and get trajectory","text":"<pre><code># fire out to 500 yards, 1 yd sampling\nresult = calc.fire(zero, trajectory_range=Distance.Yard(500), trajectory_step=Distance.Yard(1))\nprint(len(result.trajectory), \"rows\")\n# plot if you have matplotlib\nax = result.plot()\n</code></pre>"},{"location":"QuickStart/#running-tests","title":"Running tests","text":"<ul> <li>Install dev requirements (recommended):</li> </ul> <pre><code>py -m pip install -e .[dev]\n</code></pre> <ul> <li>Run unit tests:</li> </ul> <pre><code>py -m pytest\n</code></pre>"},{"location":"QuickStart/#files-examples","title":"Files &amp; examples","text":"<ul> <li>See <code>examples/Examples.ipynb</code> and <code>examples/ExtremeExamples.ipynb</code> for notebooks demonstrating advanced usage.</li> </ul>"},{"location":"QuickStart/#support-issues","title":"Support / Issues","text":"<ul> <li>Open an issue on the GitHub repository if you encounter bugs or unexpected behavior.</li> </ul>"},{"location":"about/","title":"About project","text":"<p>The library provides trajectory calculation for ballistic projectiles including air rifles, bows, firearms, artillery, and so on.</p> <p>The 3DoF model that is used in this calculator is rooted in public C code of JBM's calculator, ported to C#, optimized, fixed and extended with elements described in Litz's Applied Ballistics book and from the friendly project of Alexandre Trofimov and then ported to Go.</p> <p>This Python3 implementation has been expanded to support multiple ballistic coefficients and custom drag functions, such as those derived from Doppler radar data.</p> <p>The online version of Go documentation is located here.</p> <p>C# version of the package is located here, and the online version of C# API documentation is located here.</p> <p>RISK NOTICE</p> <p>The library performs very limited simulation of a complex physical process and so it performs a lot of approximations. Therefore, the calculation results MUST NOT be considered as completely and reliably reflecting actual behavior or characteristics of projectiles. While these results may be used for educational purpose, they must NOT be considered as reliable for the areas where incorrect calculation may cause making a wrong decision, financial harm, or can put a human life at risk.</p> <p>THE CODE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We'd love you to contribute to py_ballisticcalc!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"from importlib.metadata import metadata; print(metadata('py-ballisticcalc')['Version'])\"\n</code></pre> <p>Please try to always include the above unless you're unable to install py-ballisticcalc or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be extremely simple to get started and create a Pull Request. py-ballisticcalc is released regularly so you should see your improvements release in a matter of days or weeks \ud83d\ude80.</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily, py-ballisticcalc has few dependencies, and tests don't need access to databases, etc. Because of this, setting up and running the tests should be very simple.</p> <p>Note</p> <p>You should know the py-ballisticcalc requires cython to compile py-ballisticcalc.exts module to get high productivity calculations</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>You'll need the following prerequisites:</p> <ul> <li>Any Python version between Python 3.9 and 3.12</li> <li>venv or uv or other virtual environment tool</li> <li>git</li> </ul>"},{"location":"contributing/#installation-and-setup","title":"Installation and setup","text":"<p>Fork the repository on GitHub and clone your fork locally.</p> <pre><code># Clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/py-ballisticcalc.git\ncd py-ballisticcalc\n\n# Setup virtual environment (we will use `venv` there)\npython -m venv .venv\nsource .venv/bin/activate\n\n# Install package in editable mode with `dev` requirements to local environment \npip install -e .[dev]\n</code></pre> <p>If you want to contribute to cythonized extensions you can also install them in editable mode</p> <pre><code>pip install -e ./py_ballisticcalc.exts[dev]\n</code></pre>"},{"location":"contributing/#check-out-a-new-branch-and-make-your-changes","title":"Check out a new branch and make your changes","text":"<p>Create a new branch for your changes.</p> <pre><code># Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# Make your changes...\n</code></pre>"},{"location":"contributing/#run-tests-and-linting","title":"Run tests and linting","text":"<p>Run tests and linting locally to make sure everything is working as expected.</p> <pre><code># Run automated code linting\nruff check\n\n# Run mypy static analysing \nmypy\n\n# Run automated tests\npytest\n\n# Run automated tests for specific engine\npytest --engine=\"cythonized_rk4_engine\"  # via project.entry-points\npytest --engine=\"my_lib.my_engine:MyEngineClass\"  # via entry point path \n</code></pre>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>We use <code>pytest-cov</code> to get coverage reports: <pre><code>pytest --cov=py_ballisticcalc --cov-report=html  # for default engine\npytest --cov=py_ballisticcalc --cov-report=html --engine=\"scipy_engine\"  # for custom engine \n</code></pre></p> <p>To get coverage of Cython, set the environment variable <code>CYTHON_COVERAGE = '1'</code>, rebuild <code>py_ballisticcalc.exts</code> (from project root: <code>pip install -e py_ballisticcalc.exts</code>), then run:</p> <pre><code>python scripts\\sync_cython_sources.py\npytest --engine=\"cythonized_rk4_engine\" --cov=py_ballisticcalc --cov=py_ballisticcalc_exts --cov-report=html\n</code></pre>"},{"location":"contributing/#cython-extensions-safety-stress","title":"Cython extensions: safety &amp; stress","text":"<p>For diagnosing low-level issues (bounds, None checks, overflows) and for opt-in long-running stress tests, use the safety and stress workflows below. Commands are shown for Windows PowerShell.</p> <pre><code># Rebuild Cython extensions with safety checks enabled\n$env:CYTHON_SAFETY = '1'\n# Optional: force Cython to regenerate C code even if sources look unchanged\n$env:CYTHON_FORCE_REGEN = '1'\n\n# Reinstall extensions in editable mode (from project root)\npip install -e .\\py_ballisticcalc.exts\n\n# Run extension test suite (stress tests excluded by default via markers)\npytest .\\py_ballisticcalc.exts\\tests -q\n\n# Run only the stress tests (opt-in). These are longer and more memory-heavy.\npytest .\\py_ballisticcalc.exts\\tests -m stress -q\n\n# Clear env after testing\nRemove-Item Env:CYTHON_SAFETY; Remove-Item Env:CYTHON_FORCE_REGEN\n</code></pre> <p>Notes: - Safety build toggles bounds checking, wraparound, initialization checks, None checks, disables cdivision, and adds overflow checks; it trades speed for correctness to surface bugs. - The extension test suite enables <code>faulthandler</code> for better tracebacks on crashes. - Stress tests are marked with <code>@pytest.mark.stress</code> and are excluded by default.</p>"},{"location":"contributing/#build-documentation","title":"Build Documentation","text":"<p>If you've made any changes to the documentation (including changes to function signatures, class definitions, or docstrings that will appear in the API documentation), make sure the documentation builds successfully.</p> <p>We use <code>mkdocs-material[imaging]</code> to support social previews. You can find directions on how to install the required dependencies here.</p> <pre><code># Install dependencies for docs building\npip install -e .[docs]\n\n# Rebuild docs locally before commiting them to the branch   \nmkdocs build\n\n# Use this command to serve docs locally \nmkdocs serve\n</code></pre> <p>If this isn't working due to issues with the imaging plugin, try commenting out the <code>social</code> plugin line in <code>mkdocs.yml</code> and running <code>mkdocs build</code> again.</p>"},{"location":"contributing/#commit-and-push-your-changes","title":"Commit and push your changes","text":"<p>Commit your changes, push your branch to GitHub, and create a pull request.</p> <p>Please follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.</p> <p>When your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is written in Markdown and built using Material for MkDocs. API documentation is build from docstrings using mkdocstrings.</p> <p>In general, documentation should be written in a friendly, approachable style. It should be easy to read and understand, and should be as concise as possible while still being complete.</p> <p>Code examples are encouraged but should be kept short and simple. However, every code example should be complete, self-contained, and runnable. (If you're not sure how to do this, ask for help!) We prefer print output to naked asserts, but if you're testing something that doesn't have a useful print output, asserts are fine.</p>"},{"location":"contributing/#code-documentation","title":"Code documentation","text":"<p>When contributing to py-ballisticcalc, please make sure that all code is well documented. The following should be documented using properly formatted docstrings:</p> <ul> <li>Modules</li> <li>Class definitions</li> <li>Function definitions</li> <li>Module-level variables</li> </ul> <p>py-ballisticcalc uses Google-style docstrings formatted according to PEP 257 guidelines. (See Example Google Style Python Docstrings for further examples.)</p> <p>pydocstyle is used for linting docstrings. You can run <code>pydocstyle .\\py_ballisticcalc\\</code> to check your docstrings.</p> <p>Where this is a conflict between Google-style docstrings and pydocstyle linting, follow the pydocstyle linting hints.</p> <p>Class attributes and function arguments should be documented in the format \"name: description.\" When applicable, a return type should be documented with just a description. Types are inferred from the signature/type-hints.</p> <ul> <li> <p>Class attributes should be documented in the class docstring.</p> </li> <li> <p>Instance attributes should be documented as \"Args\" in the <code>__init__</code> docstring.</p> </li> </ul> <pre><code>class Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n</code></pre> <pre><code>def bar(self, baz: int) -&gt; str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n</code></pre> <p>You may include example code in docstrings.  Ideally it should pass doctest, which you can run via <code>scripts\\run_doctest.py</code>.</p>"},{"location":"contributors/","title":"Our People","text":"<p>py-ballisticcalc has an amazing community of contributors, reviewers, and experts that help propel the project forward. Here, we celebrate those people and their contributions.</p>"},{"location":"contributors/#contributors","title":"Contributors","text":"<p>This project exists thanks to all the people who contribute.</p> <p></p> <p>Special thanks to:</p> <ul> <li>David Bookstaber - Ballistics Expert  For help understanding and improving the functionality</li> <li>Nikolay Gekht For the sources code on C# and GO-lang from which this project firstly was forked</li> </ul>"},{"location":"help/","title":"Getting help with py-ballisticcalc","text":"<p>If you need help getting started with py-ballisticcalc or with advanced usage, the following sources may be useful.</p>"},{"location":"help/#usage-documentation","title":"Usage Documentation","text":"<p>The usage documentation is the most complete guide on how to use py-ballisticcalc.</p>"},{"location":"help/#github-discussions","title":"GitHub Discussions","text":"<p>GitHub discussions are useful for asking questions, your question and the answer will help everyone.</p>"},{"location":"install/","title":"Installation","text":"<p>Installation is as simple as:</p> pipuv <pre><code>pip install py-ballisticcalc\n</code></pre> <pre><code>uv add py-ballisticcalc \n</code></pre> <p>py-ballisticcalc has a few dependencies:</p> <ul> <li><code>typing-extensions</code>: Backport of the standard library typing module.</li> </ul> <p>If you've got Python 3.9+ and <code>pip</code> installed, you're good to go.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>py-ballisticcalc has the following optional dependencies:</p> <ul> <li><code>py_ballisticcalc.exts</code>: Cython based implementation of some classes to increase performance. py_ballisticcalc.exts package.</li> </ul> <p>To install optional dependencies along with py-ballisticcalc:</p> pipuv <pre><code># with the `py_ballisticcalc.exts` extra:\npip install 'py-ballisticcalc[exts]'\n</code></pre> <pre><code># with dependencies for data visualisation    \npip install py-ballisticcalc[visualize]\n</code></pre> <pre><code># with the `py_ballisticcalc.exts` extra:\nuv add 'py-ballisticcalc[exts]'\n</code></pre> <pre><code># with dependencies for data visualisation    \nuv add  'py-ballisticcalc[visualize]'\n</code></pre> <p>Of course, you can also install requirements manually with <code>pip install py-ballisticcalc.exts pandas matplotlib</code>.</p> <p>To install latest version from sources in editable mode</p> <pre><code>git clone github.com/o-murphy/py-ballisticcalc\ncd py-ballisticcalc\npip install -e .[dev]\n# optionally install binary extensions\npip install -e ./py_ballisticcalc.exts[dev]\n</code></pre>"},{"location":"api/constants/","title":"Constants","text":"<p>Global physical and atmospheric constants for ballistic calculations.</p> <p>This module defines scientific constants used throughout the ballistic calculations, including atmospheric model constants, physical constants, and runtime limits. All constants follow international standards (ISA, ICAO) where applicable.</p> Constant Categories <ul> <li>Global atmosphere constants: Standard conditions and coefficients</li> <li>ISA metric constants: International Standard Atmosphere in metric units  </li> <li>ICAO constants: International Civil Aviation Organization standards</li> <li>Conversion factors: Unit conversion constants</li> <li>Runtime limits: Computational bounds and validation limits</li> </ul> References <ul> <li>ISA: https://www.engineeringtoolbox.com/international-standard-atmosphere-d_985.html</li> <li>ICAO: International Civil Aviation Organization standards</li> <li>Physical constants: NIST and other authoritative sources</li> </ul>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardHumidity","title":"cStandardHumidity  <code>module-attribute</code>","text":"<pre><code>cStandardHumidity: Final[float] = 0.0\n</code></pre> <p>Standard relative humidity used in atmospheric calculations (%)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cPressureExponent","title":"cPressureExponent  <code>module-attribute</code>","text":"<pre><code>cPressureExponent: Final[float] = 5.255876\n</code></pre> <p>Pressure exponent constant for barometric formula (dimensionless)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardTemperatureC","title":"cStandardTemperatureC  <code>module-attribute</code>","text":"<pre><code>cStandardTemperatureC: Final[float] = 15.0\n</code></pre> <p>Standard temperature at sea level in Celsius (\u00b0C)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLapseRateKperFoot","title":"cLapseRateKperFoot  <code>module-attribute</code>","text":"<pre><code>cLapseRateKperFoot: Final[float] = -0.0019812\n</code></pre> <p>Temperature lapse rate in Kelvin per foot (K/ft)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLapseRateMetric","title":"cLapseRateMetric  <code>module-attribute</code>","text":"<pre><code>cLapseRateMetric: Final[float] = -0.0065\n</code></pre> <p>Temperature lapse rate in metric units (\u00b0C/m)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardPressureMetric","title":"cStandardPressureMetric  <code>module-attribute</code>","text":"<pre><code>cStandardPressureMetric: Final[float] = 1013.25\n</code></pre> <p>Standard atmospheric pressure at sea level (hPa)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cSpeedOfSoundMetric","title":"cSpeedOfSoundMetric  <code>module-attribute</code>","text":"<pre><code>cSpeedOfSoundMetric: Final[float] = 20.0467\n</code></pre> <p>Speed of sound coefficient in metric units (m/s per \u221aK)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardDensityMetric","title":"cStandardDensityMetric  <code>module-attribute</code>","text":"<pre><code>cStandardDensityMetric: Final[float] = 1.225\n</code></pre> <p>Standard air density at sea level in metric units (kg/m\u00b3)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardTemperatureF","title":"cStandardTemperatureF  <code>module-attribute</code>","text":"<pre><code>cStandardTemperatureF: Final[float] = 59.0\n</code></pre> <p>Standard temperature at sea level in Fahrenheit (\u00b0F)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLapseRateImperial","title":"cLapseRateImperial  <code>module-attribute</code>","text":"<pre><code>cLapseRateImperial: Final[float] = -0.00356616\n</code></pre> <p>Temperature lapse rate in imperial units (\u00b0F/ft)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardPressure","title":"cStandardPressure  <code>module-attribute</code>","text":"<pre><code>cStandardPressure: Final[float] = 29.92\n</code></pre> <p>Standard atmospheric pressure at sea level (InHg)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cSpeedOfSoundImperial","title":"cSpeedOfSoundImperial  <code>module-attribute</code>","text":"<pre><code>cSpeedOfSoundImperial: Final[float] = 49.0223\n</code></pre> <p>Speed of sound coefficient in imperial units (fps per \u221a\u00b0R)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardDensity","title":"cStandardDensity  <code>module-attribute</code>","text":"<pre><code>cStandardDensity: Final[float] = 0.076474\n</code></pre> <p>Standard air density at sea level in imperial units (lb/ft\u00b3)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cDegreesCtoK","title":"cDegreesCtoK  <code>module-attribute</code>","text":"<pre><code>cDegreesCtoK: Final[float] = 273.15\n</code></pre> <p>Celsius to Kelvin conversion constant (K)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cDegreesFtoR","title":"cDegreesFtoR  <code>module-attribute</code>","text":"<pre><code>cDegreesFtoR: Final[float] = 459.67\n</code></pre> <p>Fahrenheit to Rankine conversion constant (\u00b0R)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cDensityImperialToMetric","title":"cDensityImperialToMetric  <code>module-attribute</code>","text":"<pre><code>cDensityImperialToMetric: Final[float] = 16.0185\n</code></pre> <p>Density conversion factor from imperial to metric units (kg/m\u00b3 per lb/ft\u00b3)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLowestTempF","title":"cLowestTempF  <code>module-attribute</code>","text":"<pre><code>cLowestTempF: Final[float] = -130\n</code></pre> <p>Minimum allowed temperature for atmospheric calculations (\u00b0F)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cMaxWindDistanceFeet","title":"cMaxWindDistanceFeet  <code>module-attribute</code>","text":"<pre><code>cMaxWindDistanceFeet: Final[float] = 100000000.0\n</code></pre> <p>Maximum wind effect distance for computational limits (ft)</p>"},{"location":"api/constants/#global-atmosphere-constants","title":"Global atmosphere constants","text":"Constant Description Value Unit / Notes <code>cStandardHumidity</code> Relative Humidity in percents 0.0 % <code>cPressureExponent</code> =gM/RL 5.255876 - <code>cA0</code> Coefficient A0 1.24871 - <code>cA1</code> Coefficient A1 0.0988438 - <code>cA2</code> Coefficient A2 0.00152907 - <code>cA3</code> Coefficient A3 -3.07031e-06 - <code>cA4</code> Coefficient A4 4.21329e-07 - <code>cA5</code> Coefficient A5 3.342e-04 -"},{"location":"api/constants/#isa-metric-prefer_units","title":"ISA, metric prefer_units","text":"Constant Description Value Unit / Notes <code>cDegreesCtoK</code> Celsius to Kelvin conversion 273.15 \u00b0K = \u00b0C + 273.15 <code>cStandardTemperatureC</code> Standard temperature in Celsius 15.0 \u00b0C <code>cLapseRateMetric</code> Metric lapse rate -6.5e-03 \u00b0C/m <code>cStandardPressureMetric</code> Standard pressure (metric) 1013.25 hPa <code>cSpeedOfSoundMetric</code> Speed of sound in metric 331.3 m/s <code>cStandardDensityMetric</code> Standard air density (metric) 1.2250 kg/m\u00b3 <code>cDensityImperialToMetric</code> Density conversion (imperial to metric) 16.0185 lb/ft\u00b3 to kg/m\u00b3"},{"location":"api/constants/#icao-standard-atmosphere","title":"ICAO standard atmosphere","text":"Constant Description Value Unit / Notes <code>cDegreesFtoR</code> Fahrenheit to Rankine conversion 459.67 \u00b0R = \u00b0F + 459.67 <code>cStandardTemperatureF</code> Standard temperature in Fahrenheit 59.0 \u00b0F <code>cLapseRateImperial</code> Imperial lapse rate -3.56616e-03 \u00b0F/ft <code>cStandardPressure</code> Standard pressure (imperial) 29.92 InHg <code>cSpeedOfSoundImperial</code> Speed of sound (imperial) 49.0223 fps <code>cStandardDensity</code> Standard air density (imperial) 0.076474 lb/ft\u00b3"},{"location":"api/constants/#runtime-limits-constants","title":"Runtime limits constants","text":"Constant Description Value Unit / Notes <code>cLowestTempF</code> Lowest temperature recorded -130 \u00b0F <code>cMaxWindDistanceFeet</code> Maximum wind distance 1e8 ft"},{"location":"api/drag_model/","title":"DragModel","text":"<p>Drag model implementations for ballistic projectiles.</p> <p>This module provides classes and functions for modeling aerodynamic drag of projectiles, including single and multi-BC (ballistic coefficient) models. Supports standard drag tables and custom drag data points.</p> Key Components <p>DragDataPoint: Individual drag coefficient at specific Mach number BCPoint: Ballistic coefficient point for multi-BC models DragModel: Primary drag model with ballistic coefficient and drag table DragModelMultiBC: Multi-BC drag model for varying ballistic coefficients</p> <p>Functions:</p> Name Description <code>make_data_points</code> <p>Convert drag table data to DragDataPoint objects</p> <code>sectional_density</code> <p>Calculate sectional density from weight and diameter</p> <code>linear_interpolation</code> <p>Linear interpolation utility function</p> <p>The drag models use standard ballistic reference tables (G1, G7, etc.) and allow for custom drag functions based on Mach number vs drag coefficient data.</p>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragDataPoint","title":"DragDataPoint  <code>dataclass</code>","text":"<pre><code>DragDataPoint(Mach: float, CD: float)\n</code></pre> <p>Drag coefficient at a specific Mach number.</p> <p>Attributes:</p> Name Type Description <code>Mach</code> <code>float</code> <p>Velocity in Mach units (dimensionless)</p> <code>CD</code> <code>float</code> <p>Drag coefficient (dimensionless)</p>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.BCPoint","title":"BCPoint  <code>dataclass</code>","text":"<pre><code>BCPoint(\n    BC: float,\n    Mach: Optional[float] = None,\n    V: Optional[Union[float, Velocity]] = None,\n)\n</code></pre> <p>Ballistic coefficient point for multi-BC drag models.</p> <p>Represents a single ballistic coefficient measurement at a specific velocity or Mach number. Designed to be sortable by Mach number for constructing multi-BC drag models.</p> <p>Attributes:</p> Name Type Description <code>BC</code> <code>float</code> <p>Ballistic coefficient (dimensionless)</p> <code>Mach</code> <code>float</code> <p>Mach number corresponding to this BC measurement (dimensionless)</p> <code>V</code> <code>Optional[Velocity]</code> <p>Velocity corresponding to this BC measurement (optional)</p> Note <p>Either Mach or V must be specified, but not both. If V is provided, Mach will be calculated automatically using standard atmospheric conditions.</p> <p>Parameters:</p> Name Type Description Default <code>BC</code> <code>float</code> <p>Ballistic coefficient (must be positive)</p> required <code>Mach</code> <code>Optional[float]</code> <p>Mach number (optional, mutually exclusive with V)</p> <code>None</code> <code>V</code> <code>Optional[Union[float, Velocity]]</code> <p>Velocity (optional, mutually exclusive with Mach)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If BC is not positive, or if both or neither of Mach and V are specified.</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def __init__(self,\n             BC: float,\n             Mach: Optional[float] = None,\n             V: Optional[Union[float, Velocity]] = None) -&gt; None:\n    \"\"\"Initialize a BCPoint with ballistic coefficient and velocity/Mach.\n\n    Args:\n        BC: Ballistic coefficient (must be positive)\n        Mach: Mach number (optional, mutually exclusive with V)\n        V: Velocity (optional, mutually exclusive with Mach)\n\n    Raises:\n        ValueError: If BC is not positive, or if both or neither of Mach and V are specified.\n    \"\"\"\n    if BC &lt;= 0:\n        raise ValueError('Ballistic coefficient must be positive')\n    if Mach and V:\n        raise ValueError(\"You cannot specify both 'Mach' and 'V' at the same time\")\n    if not Mach and not V:\n        raise ValueError(\"One of 'Mach' and 'V' must be specified\")\n\n    self.BC = BC\n    self.V = PreferredUnits.velocity(V or 0)\n    if V:\n        self.Mach = (self.V &gt;&gt; Velocity.MPS) / self._machC()\n    elif Mach:\n        self.Mach = Mach\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragModel","title":"DragModel","text":"<pre><code>DragModel(\n    bc: float,\n    drag_table: DragTableDataType,\n    weight: Union[float, Weight] = 0,\n    diameter: Union[float, Distance] = 0,\n    length: Union[float, Distance] = 0,\n)\n</code></pre> <p>Aerodynamic drag model for ballistic projectiles.</p> <p>Represents the drag characteristics of a projectile using a ballistic coefficient and drag table.</p> <p>The ballistic coefficient (BC) is defined as:     BC = weight / (diameter^2 * form_factor) where weight is in pounds, diameter is in inches, and form_factor is relative to the selected drag model.</p> <p>Attributes:</p> Name Type Description <code>BC</code> <p>Ballistic coefficient (scales drag model for a particular projectile)</p> <code>drag_table</code> <p>List of DragDataPoint objects defining Mach vs CD</p> <code>weight</code> <p>Projectile weight (only needed for spin drift calculations)</p> <code>diameter</code> <p>Projectile diameter (only needed for spin drift calculations) </p> <code>length</code> <p>Projectile length (only needed for spin drift calculations)</p> <code>sectional_density</code> <p>Calculated sectional density (lb/in\u00b2)</p> <code>form_factor</code> <p>Calculated form factor (dimensionless)</p> Note <p>The weight, diameter, and length parameters are only required when computing spin drift. For basic trajectory calculations, only BC and drag_table are needed.</p> <p>Parameters:</p> Name Type Description Default <code>bc</code> <code>float</code> <p>Ballistic coefficient</p> required <code>drag_table</code> <code>DragTableDataType</code> <p>Either list of DragDataPoint objects or list of         dictionaries with 'Mach' and 'CD' keys</p> required <code>weight</code> <code>Union[float, Weight]</code> <p>Projectile weight in grains (default: 0)</p> <code>0</code> <code>diameter</code> <code>Union[float, Distance]</code> <p>Projectile diameter in inches (default: 0)</p> <code>0</code> <code>length</code> <code>Union[float, Distance]</code> <p>Projectile length in inches (default: 0)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If BC is not positive or drag_table is empty</p> <code>TypeError</code> <p>If drag_table format is invalid</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def __init__(self,\n             bc: float,\n             drag_table: DragTableDataType,\n             weight: Union[float, Weight] = 0,\n             diameter: Union[float, Distance] = 0,\n             length: Union[float, Distance] = 0) -&gt; None:\n    \"\"\"Initialize a drag model with ballistic coefficient and drag table.\n\n    Args:\n        bc: Ballistic coefficient\n        drag_table: Either list of DragDataPoint objects or list of\n                    dictionaries with 'Mach' and 'CD' keys\n        weight: Projectile weight in grains (default: 0)\n        diameter: Projectile diameter in inches (default: 0)\n        length: Projectile length in inches (default: 0)\n\n    Raises:\n        ValueError: If BC is not positive or drag_table is empty\n        TypeError: If drag_table format is invalid\n    \"\"\"\n    if len(drag_table) &lt;= 0:\n        raise ValueError('Received empty drag table')\n    if bc &lt;= 0:\n        raise ValueError('Ballistic coefficient must be positive')\n    if len(drag_table) &lt; 2:\n        warnings.warn('Drag table needs at least 2 entries to enable interpolation', UserWarning)\n\n    self.drag_table = make_data_points(drag_table)\n\n    self.BC = bc\n    self.length = PreferredUnits.length(length)\n    self.weight = PreferredUnits.weight(weight)\n    self.diameter = PreferredUnits.diameter(diameter)\n    if weight &gt; 0 and diameter &gt; 0:\n        self.sectional_density = self._get_sectional_density()\n        self.form_factor = self._get_form_factor(self.BC)\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragModelMultiBC","title":"DragModelMultiBC","text":"<pre><code>DragModelMultiBC(\n    bc_points: List[BCPoint],\n    drag_table: DragTableDataType,\n    weight: Union[float, Weight] = 0,\n    diameter: Union[float, Distance] = 0,\n    length: Union[float, Distance] = 0,\n) -&gt; DragModel\n</code></pre> <p>Create a drag model with multiple ballistic coefficients.</p> <p>Constructs a DragModel using multiple BC measurements at different velocities, interpolating between them to create a more accurate drag function. This is useful for projectiles whose BC varies significantly with velocity.</p> <p>Parameters:</p> Name Type Description Default <code>bc_points</code> <code>List[BCPoint]</code> <p>List of BCPoint objects with BC measurements at specific velocities</p> required <code>drag_table</code> <code>DragTableDataType</code> <p>Standard drag table (G1, G7, etc.) or custom drag data</p> required <code>weight</code> <code>Union[float, Weight]</code> <p>Projectile weight in grains (default: 0)</p> <code>0</code> <code>diameter</code> <code>Union[float, Distance]</code> <p>Projectile diameter in inches (default: 0) </p> <code>0</code> <code>length</code> <code>Union[float, Distance]</code> <p>Projectile length in inches (default: 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>DragModel</code> <p>DragModel with interpolated drag coefficients based on multiple BCs</p> Note <p>If weight and diameter are provided, BC is set to sectional density. Otherwise, BC=1 and the drag_table contains final drag terms. BC points are automatically sorted by Mach number for interpolation.</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def DragModelMultiBC(bc_points: List[BCPoint],\n                     drag_table: DragTableDataType,\n                     weight: Union[float, Weight] = 0,\n                     diameter: Union[float, Distance] = 0,\n                     length: Union[float, Distance] = 0) -&gt; DragModel:\n    \"\"\"Create a drag model with multiple ballistic coefficients.\n\n    Constructs a DragModel using multiple BC measurements at different velocities,\n    interpolating between them to create a more accurate drag function. This is\n    useful for projectiles whose BC varies significantly with velocity.\n\n    Args:\n        bc_points: List of BCPoint objects with BC measurements at specific velocities\n        drag_table: Standard drag table (G1, G7, etc.) or custom drag data\n        weight: Projectile weight in grains (default: 0)\n        diameter: Projectile diameter in inches (default: 0) \n        length: Projectile length in inches (default: 0)\n\n    Returns:\n        DragModel with interpolated drag coefficients based on multiple BCs\n\n    Note:\n        If weight and diameter are provided, BC is set to sectional density.\n        Otherwise, BC=1 and the drag_table contains final drag terms.\n        BC points are automatically sorted by Mach number for interpolation.\n    \"\"\"\n    weight = PreferredUnits.weight(weight)\n    diameter = PreferredUnits.diameter(diameter)\n    if weight &gt; 0 and diameter &gt; 0:\n        bc = sectional_density(weight &gt;&gt; Weight.Grain, diameter &gt;&gt; Distance.Inch)\n    else:\n        bc = 1.0\n\n    drag_table = make_data_points(drag_table)  # Convert from list of dicts to list of DragDataPoints\n\n    bc_points.sort(key=lambda p: p.Mach)  # Make sure bc_points are sorted for linear interpolation\n    bc_interp = linear_interpolation([x.Mach for x in drag_table],\n                                     [x.Mach for x in bc_points],\n                                     [x.BC / bc for x in bc_points])\n\n    for i, point in enumerate(drag_table):\n        point.CD = point.CD / bc_interp[i]\n    return DragModel(bc, drag_table, weight, diameter, length)\n</code></pre>"},{"location":"api/trajectory_data/","title":"TrajectoryData","text":"<p>Ballistic Trajectory Data Structures and Post-Processing Classes.</p> Core Components <ul> <li>TrajFlag: Ballistic points of interest</li> <li>TrajectoryData: Detailed ballistic state at a single trajectory point</li> <li>BaseTrajData: Minimal trajectory data required for a single point</li> <li>HitResult: Complete trajectory results with metadata</li> <li>DangerSpace: Target engagement zone analysis</li> </ul> Key Features <ul> <li>Immutable trajectory data structures for thread safety</li> <li>Cubic interpolation for smooth trajectory analysis</li> <li>Support for multiple coordinate systems and unit conversions</li> <li>Integration with visualization libraries (matplotlib)</li> <li>Zero-crossing detection and special point identification</li> <li>Danger space analysis for tactical applications</li> </ul> Typical Usage <pre><code>from py_ballisticcalc import Calculator, Shot, DragModel\nfrom py_ballisticcalc.trajectory_data import TrajFlag\n\n# Calculate trajectory\ncalc = Calculator()\nshot = Shot(...)\n\nhit_result = calc.fire(shot, trajectory_range=1000, flags=TrajFlag.ALL)\n\n# Access trajectory data\nfor point in hit_result.trajectory:\n    print(f\"Time: {point.time:.3f}s, Distance: {point.distance}, \"\n          f\"Height: {point.height}, Velocity: {point.velocity}\")\n\n# Find specific points\nzero_data = hit_result.zeros()  # Zero crossings\nmax_range_point = hit_result.get_at('distance', Distance.Meter(1000))\n\n# Cubic interpolation for specific point\ninterpolated = TrajectoryData.interpolate('time', 1.5, point1, point2, point3)\n\n# Danger space analysis\ndanger = hit_result.danger_space(at_range=Distance.Meter(500),\n                                 target_height=Distance.Feet(2))\n</code></pre> See Also <ul> <li>py_ballisticcalc.interface: Calculator class to generate HitResults</li> <li>py_ballisticcalc.unit: Unit system for all measurement values</li> <li>py_ballisticcalc.vector: Vector mathematics for position/velocity</li> </ul>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag","title":"TrajFlag","text":"<p>               Bases: <code>int</code></p> <p>Trajectory point classification flags for marking special trajectory events.</p> <p>Provides enumeration values for identifying and filtering special points in ballistic trajectories. The flags can be combined using bitwise operations.</p> Flag Values <p>NONE (0): Standard trajectory point with no special events ZERO_UP (1): Upward zero crossing (trajectory rising through sight line) ZERO_DOWN (2): Downward zero crossing (trajectory falling through sight line) ZERO (3): Any zero crossing (ZERO_UP | ZERO_DOWN) MACH (4): Mach 1 transition point (sound barrier crossing) RANGE (8): User requested point, typically by distance or time step APEX (16): Trajectory apex (maximum height point) ALL (31): All special points (combination of all above flags) MRT (32): Mid-Range Trajectory/Maximum Ordinate (largest slant height) [PROPOSED]</p> <p>Examples:</p> <p>Basic flag usage:</p> <pre><code>from py_ballisticcalc.trajectory_data import TrajFlag\n\n# Filter for zero crossings only\nflags = TrajFlag.ZERO\n\n# Filter for multiple event types\nflags = TrajFlag.ZERO | TrajFlag.APEX | TrajFlag.MACH\n\n# Filter for all special points\nflags = TrajFlag.ALL\n\n# Check if a trajectory point has specific flags\nif point.flag &amp; TrajFlag.APEX:\n    print(\"Trajectory apex\")\n</code></pre> <p>Trajectory calculation with flags:</p> <pre><code># Calculate trajectory with zero crossings and apex\nhit_result = calc.fire(shot, 1000, filter_flags=TrajFlag.ZERO | TrajFlag.APEX)\n\n# Find all zero crossing points\nzeros = [p for p in hit_result.trajectory if p.flag &amp; TrajFlag.ZERO]\n\n# Find apex point\napex = next((p for p in hit_result.trajectory if p.flag &amp; TrajFlag.APEX), None)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag.name","title":"name  <code>staticmethod</code>","text":"<pre><code>name(value: Union[int, TrajFlag]) -&gt; str\n</code></pre> <p>Get the human-readable name for a trajectory flag value.</p> <p>Converts a numeric flag value to its corresponding string name for display, logging, or debugging purposes. Supports both individual flags and combined flag values with intelligent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, TrajFlag]</code> <p>The TrajFlag enum value or integer flag to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String name of the flag. For combined flags, returns names joined</p> <code>str</code> <p>with \"|\". For unknown flags, returns \"UNKNOWN\". Special handling</p> <code>str</code> <p>for ZERO flag combinations.</p> <p>Examples:</p> <pre><code># Individual flag names\nprint(TrajFlag.name(TrajFlag.ZERO))      # \"ZERO\"\nprint(TrajFlag.name(TrajFlag.APEX))      # \"APEX\"\n\n# Combined flags\ncombined = TrajFlag.ZERO | TrajFlag.APEX\nprint(TrajFlag.name(combined))           # \"ZERO|APEX\"\n\n# Unknown flags\nprint(TrajFlag.name(999))                # \"UNKNOWN\"\n</code></pre> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef name(value: Union[int, TrajFlag]) -&gt; str:\n    \"\"\"Get the human-readable name for a trajectory flag value.\n\n    Converts a numeric flag value to its corresponding string name for\n    display, logging, or debugging purposes. Supports both individual\n    flags and combined flag values with intelligent formatting.\n\n    Args:\n        value: The TrajFlag enum value or integer flag to convert.\n\n    Returns:\n        String name of the flag. For combined flags, returns names joined\n        with \"|\". For unknown flags, returns \"UNKNOWN\". Special handling\n        for ZERO flag combinations.\n\n    Examples:\n        ```python\n        # Individual flag names\n        print(TrajFlag.name(TrajFlag.ZERO))      # \"ZERO\"\n        print(TrajFlag.name(TrajFlag.APEX))      # \"APEX\"\n\n        # Combined flags\n        combined = TrajFlag.ZERO | TrajFlag.APEX\n        print(TrajFlag.name(combined))           # \"ZERO|APEX\"\n\n        # Unknown flags\n        print(TrajFlag.name(999))                # \"UNKNOWN\"\n        ```\n    \"\"\"\n    v = int(value)\n    mapping = TrajFlag._value_to_name()\n    if v in mapping:\n        return mapping[v]\n    parts = [mapping[bit] for bit in sorted(mapping) if bit and (v &amp; bit) == bit]\n    if \"ZERO_UP\" in parts and \"ZERO_DOWN\" in parts:\n        parts.remove(\"ZERO_UP\")\n        parts.remove(\"ZERO_DOWN\")\n    return \"|\".join(parts) if parts else \"UNKNOWN\"\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.BaseTrajData","title":"BaseTrajData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Minimal ballistic trajectory point data.</p> <p>Represents the minimum state information for a single point in a ballistic trajectory. The data are kept in basic units (seconds, feet) to avoid unit tracking and conversion overhead.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>float</code> <p>Time since projectile launch in seconds.</p> <code>position</code> <code>Vector</code> <p>3D position vector in feet (x=downrange, y=height, z=windage).</p> <code>velocity</code> <code>Vector</code> <p>3D velocity vector in feet per second.</p> <code>mach</code> <code>float</code> <p>Local speed of sound in feet per second.</p> <p>Examples:</p> <pre><code>from py_ballisticcalc.vector import Vector\n\n# Create trajectory point at launch\nlaunch_pt = BaseTrajData(\n    time=0.0,\n    position=Vector(0.0, -0.1, 0.0),   # 0.1 ft scope height\n    velocity=Vector(2640.0, 0.0, 0.0), # 800 m/s \u2248 2640 fps\n    mach=1115.5                        # Standard conditions\n)\n\n# Interpolate between points\ninterpolated = BaseTrajData.interpolate('time', 1.25, launch_pt, mid_pt, end_pt)\n</code></pre> Note <p>This class is designed for efficiency in calculation engines that may compute thousands of points over a trajectory. For detailed data with units and derived quantities, use TrajectoryData which can be constructed from BaseTrajData using from_base_data().</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.BaseTrajData.interpolate","title":"interpolate  <code>staticmethod</code>","text":"<pre><code>interpolate(\n    key_attribute: str,\n    key_value: float,\n    p0: BaseTrajData,\n    p1: BaseTrajData,\n    p2: BaseTrajData,\n    method: InterpolationMethod = \"pchip\",\n) -&gt; BaseTrajData\n</code></pre> <p>Interpolate a BaseTrajData point using monotone PCHIP (default) or linear.</p> <p>Parameters:</p> Name Type Description Default <code>key_attribute</code> <code>str</code> <p>Can be 'time', 'mach', or a vector component like 'position.x' or 'velocity.z'.</p> required <code>key_value</code> <code>float</code> <p>The value to interpolate for.</p> required <code>p0</code> <code>BaseTrajData</code> <p>First bracketing point.</p> required <code>p1</code> <code>BaseTrajData</code> <p>Second (middle) bracketing point.</p> required <code>p2</code> <code>BaseTrajData</code> <p>Third bracketing point.</p> required <code>method</code> <code>InterpolationMethod</code> <p>'pchip' (default, monotone cubic Hermite) or 'linear'.</p> <code>'pchip'</code> <p>Returns:</p> Type Description <code>BaseTrajData</code> <p>The interpolated data point.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the key_attribute is not a member of BaseTrajData.</p> <code>ZeroDivisionError</code> <p>If the interpolation fails due to zero division.                (This will result if two of the points are identical).</p> <code>ValueError</code> <p>If method is not one of 'pchip' or 'linear'.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef interpolate(key_attribute: str, key_value: float,\n                p0: BaseTrajData, p1: BaseTrajData, p2: BaseTrajData,\n                method: InterpolationMethod = \"pchip\") -&gt; BaseTrajData:\n    \"\"\"\n    Interpolate a BaseTrajData point using monotone PCHIP (default) or linear.\n\n    Args:\n        key_attribute: Can be 'time', 'mach', or a vector component like 'position.x' or 'velocity.z'.\n        key_value: The value to interpolate for.\n        p0: First bracketing point.\n        p1: Second (middle) bracketing point.\n        p2: Third bracketing point.\n        method: 'pchip' (default, monotone cubic Hermite) or 'linear'.\n\n    Returns:\n        The interpolated data point.\n\n    Raises:\n        AttributeError: If the key_attribute is not a member of BaseTrajData.\n        ZeroDivisionError: If the interpolation fails due to zero division.\n                           (This will result if two of the points are identical).\n        ValueError: If method is not one of 'pchip' or 'linear'.\n    \"\"\"\n    def get_key_val(td: \"BaseTrajData\", path: str) -&gt; float:\n        \"\"\"Helper to get the key value from a BaseTrajData point.\"\"\"\n        if '.' in path:\n            top, component = path.split('.', 1)\n            obj = getattr(td, top)\n            return getattr(obj, component)\n        return getattr(td, path)\n\n    # independent variable values\n    x0 = get_key_val(p0, key_attribute)\n    x1 = get_key_val(p1, key_attribute)\n    x2 = get_key_val(p2, key_attribute)\n    def _interp_scalar(y0, y1, y2):\n        if method == \"pchip\":\n            return interpolate_3_pt(key_value, x0, y0, x1, y1, x2, y2)\n        elif method == \"linear\":\n            pts = sorted(((x0, y0), (x1, y1), (x2, y2)), key=lambda p: p[0])\n            (sx0, sy0), (sx1, sy1), (sx2, sy2) = pts\n            if key_value &lt;= sx1:\n                return interpolate_2_pt(key_value, sx0, sy0, sx1, sy1)\n            else:\n                return interpolate_2_pt(key_value, sx1, sy1, sx2, sy2)\n        else:\n            raise ValueError(\"method must be 'pchip' or 'linear'\")\n\n    time = _interp_scalar(p0.time, p1.time, p2.time) if key_attribute != 'time' else key_value\n    px = _interp_scalar(p0.position.x, p1.position.x, p2.position.x)\n    py = _interp_scalar(p0.position.y, p1.position.y, p2.position.y)\n    pz = _interp_scalar(p0.position.z, p1.position.z, p2.position.z)\n    position = Vector(px, py, pz)\n    vx = _interp_scalar(p0.velocity.x, p1.velocity.x, p2.velocity.x)\n    vy = _interp_scalar(p0.velocity.y, p1.velocity.y, p2.velocity.y)\n    vz = _interp_scalar(p0.velocity.z, p1.velocity.z, p2.velocity.z)\n    velocity = Vector(vx, vy, vz)\n    mach = _interp_scalar(p0.mach, p1.mach, p2.mach) if key_attribute != 'mach' else key_value\n\n    return BaseTrajData(time=time, position=position, velocity=velocity, mach=mach)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData","title":"TrajectoryData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Data for one point in ballistic trajectory.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.x","title":"x  <code>property</code>","text":"<pre><code>x: Distance\n</code></pre> <p>Synonym for .distance.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.y","title":"y  <code>property</code>","text":"<pre><code>y: Distance\n</code></pre> <p>Synonym for .height.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.z","title":"z  <code>property</code>","text":"<pre><code>z: Distance\n</code></pre> <p>Synonym for .windage.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.look_distance","title":"look_distance","text":"<pre><code>look_distance() -&gt; Distance\n</code></pre> <p>Synonym for slant_distance.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use .slant_distance instead of .look_distance\", version=\"2.2.0\")\ndef look_distance(self) -&gt; Distance:\n    \"\"\"Synonym for slant_distance.\"\"\"\n    return self.slant_distance\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.target_drop","title":"target_drop  <code>property</code>","text":"<pre><code>target_drop: Distance\n</code></pre> <p>Synonym for slant_height.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.formatted","title":"formatted","text":"<pre><code>formatted() -&gt; Tuple[str, ...]\n</code></pre> <p>Return attributes as tuple of strings, formatted per PreferredUnits.</p> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>Tuple of formatted strings for this point, in PreferredUnits.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def formatted(self) -&gt; Tuple[str, ...]:\n    \"\"\"Return attributes as tuple of strings, formatted per PreferredUnits.\n\n    Returns:\n        Tuple of formatted strings for this point, in PreferredUnits.\n    \"\"\"\n\n    def _fmt(v: GenericDimension, u: Unit) -&gt; str:\n        \"\"\"Format Dimension as a string.\"\"\"\n        return f\"{v &gt;&gt; u:.{u.accuracy}f} {u.symbol}\"\n\n    return (\n        f'{self.time:.3f} s',\n        _fmt(self.distance, PreferredUnits.distance),\n        _fmt(self.velocity, PreferredUnits.velocity),\n        f'{self.mach:.2f} mach',\n        _fmt(self.height, PreferredUnits.drop),\n        _fmt(self.slant_height, PreferredUnits.drop),\n        _fmt(self.drop_adj, PreferredUnits.adjustment),\n        _fmt(self.windage, PreferredUnits.drop),\n        _fmt(self.windage_adj, PreferredUnits.adjustment),\n        _fmt(self.slant_distance, PreferredUnits.distance),\n        _fmt(self.angle, PreferredUnits.angular),\n        f'{self.density_ratio:.5e}',\n        f'{self.drag:.3e}',\n        _fmt(self.energy, PreferredUnits.energy),\n        _fmt(self.ogw, PreferredUnits.ogw),\n        TrajFlag.name(self.flag)\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.in_def_units","title":"in_def_units","text":"<pre><code>in_def_units() -&gt; Tuple[float, ...]\n</code></pre> <p>Return attributes as tuple of floats converting to PreferredUnits.</p> <p>Returns:</p> Type Description <code>Tuple[float, ...]</code> <p>Tuple of floats describing this point, in PreferredUnits.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def in_def_units(self) -&gt; Tuple[float, ...]:\n    \"\"\"Return attributes as tuple of floats converting to PreferredUnits.\n\n    Returns:\n        Tuple of floats describing this point, in PreferredUnits.\n    \"\"\"\n    return (\n        self.time,\n        self.distance &gt;&gt; PreferredUnits.distance,\n        self.velocity &gt;&gt; PreferredUnits.velocity,\n        self.mach,\n        self.height &gt;&gt; PreferredUnits.drop,\n        self.slant_height &gt;&gt; PreferredUnits.drop,\n        self.drop_adj &gt;&gt; PreferredUnits.adjustment,\n        self.windage &gt;&gt; PreferredUnits.drop,\n        self.windage_adj &gt;&gt; PreferredUnits.adjustment,\n        self.slant_distance &gt;&gt; PreferredUnits.distance,\n        self.angle &gt;&gt; PreferredUnits.angular,\n        self.density_ratio,\n        self.drag,\n        self.energy &gt;&gt; PreferredUnits.energy,\n        self.ogw &gt;&gt; PreferredUnits.ogw,\n        self.flag\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.get_correction","title":"get_correction  <code>staticmethod</code>","text":"<pre><code>get_correction(distance: float, offset: float) -&gt; float\n</code></pre> <p>Calculate the sight adjustment in radians.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to the target in feet.</p> required <code>offset</code> <code>float</code> <p>The offset from the target in feet.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sight adjustment in radians.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef get_correction(distance: float, offset: float) -&gt; float:\n    \"\"\"Calculate the sight adjustment in radians.\n\n    Args:\n        distance: The distance to the target in feet.\n        offset: The offset from the target in feet.\n\n    Returns:\n        The sight adjustment in radians.\n    \"\"\"\n    if distance != 0:\n        return math.atan(offset / distance)\n    return 0  # None\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.calculate_energy","title":"calculate_energy  <code>staticmethod</code>","text":"<pre><code>calculate_energy(\n    bullet_weight: float, velocity: float\n) -&gt; float\n</code></pre> <p>Calculate the kinetic energy of a projectile.</p> <p>Parameters:</p> Name Type Description Default <code>bullet_weight</code> <code>float</code> <p>Projectile weight in grains.</p> required <code>velocity</code> <code>float</code> <p>Projectile velocity in feet per second.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Kinetic energy in foot-pounds (ft\u00b7lbf).</p> Notes <p>Uses the standard small-arms approximation: E(ft\u00b7lbf) = weight(grains) * v(fps)^2 / 450400.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef calculate_energy(bullet_weight: float, velocity: float) -&gt; float:\n    \"\"\"Calculate the kinetic energy of a projectile.\n\n    Args:\n        bullet_weight: Projectile weight in grains.\n        velocity: Projectile velocity in feet per second.\n\n    Returns:\n        Kinetic energy in foot-pounds (ft\u00b7lbf).\n\n    Notes:\n        Uses the standard small-arms approximation:\n        E(ft\u00b7lbf) = weight(grains) * v(fps)^2 / 450400.\n    \"\"\"\n    return bullet_weight * math.pow(velocity, 2) / 450400\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.calculate_ogw","title":"calculate_ogw  <code>staticmethod</code>","text":"<pre><code>calculate_ogw(\n    bullet_weight: float, velocity: float\n) -&gt; float\n</code></pre> <p>Calculate the optimal game weight for a projectile.</p> <p>Parameters:</p> Name Type Description Default <code>bullet_weight</code> <code>float</code> <p>Bullet weight in grains (per common OGW formula).</p> required <code>velocity</code> <code>float</code> <p>Projectile velocity in feet per second.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The optimal game weight in pounds.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef calculate_ogw(bullet_weight: float, velocity: float) -&gt; float:\n    \"\"\"Calculate the optimal game weight for a projectile.\n\n    Args:\n        bullet_weight: Bullet weight in grains (per common OGW formula).\n        velocity: Projectile velocity in feet per second.\n\n    Returns:\n        The optimal game weight in pounds.\n    \"\"\"\n    return math.pow(bullet_weight, 2) * math.pow(velocity, 3) * 1.5e-12\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.from_base_data","title":"from_base_data  <code>staticmethod</code>","text":"<pre><code>from_base_data(\n    props: ShotProps,\n    data: BaseTrajData,\n    flag: Union[TrajFlag, int] = NONE,\n) -&gt; TrajectoryData\n</code></pre> <p>Create a TrajectoryData object from BaseTrajData.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef from_base_data(props: ShotProps, data: BaseTrajData,\n                   flag: Union[TrajFlag, int] = TrajFlag.NONE) -&gt; TrajectoryData:\n    \"\"\"Create a TrajectoryData object from BaseTrajData.\"\"\"\n    return TrajectoryData.from_props(props, data.time, data.position, data.velocity, data.mach, flag)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.from_props","title":"from_props  <code>staticmethod</code>","text":"<pre><code>from_props(\n    props: ShotProps,\n    time: float,\n    range_vector: Vector,\n    velocity_vector: Vector,\n    mach: float,\n    flag: Union[TrajFlag, int] = NONE,\n) -&gt; TrajectoryData\n</code></pre> <p>Create a TrajectoryData object.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef from_props(props: ShotProps,\n                time: float,\n                range_vector: Vector,\n                velocity_vector: Vector,\n                mach: float,\n                flag: Union[TrajFlag, int] = TrajFlag.NONE) -&gt; TrajectoryData:\n    \"\"\"Create a TrajectoryData object.\"\"\"\n    spin_drift = props.spin_drift(time)\n    velocity = velocity_vector.magnitude()\n    windage = range_vector.z + spin_drift\n    drop_adjustment = TrajectoryData.get_correction(range_vector.x, range_vector.y)\n    windage_adjustment = TrajectoryData.get_correction(range_vector.x, windage)\n    trajectory_angle = math.atan2(velocity_vector.y, velocity_vector.x)\n    look_angle_cos = math.cos(props.look_angle_rad)\n    look_angle_sin = math.sin(props.look_angle_rad)\n    density_ratio, _ = props.get_density_and_mach_for_altitude(range_vector.y)\n    drag = props.drag_by_mach(velocity / mach)\n    return TrajectoryData(\n        time=time,\n        distance=TrajectoryData._new_feet(range_vector.x),\n        velocity=TrajectoryData._new_fps(velocity),\n        mach=velocity / mach,\n        height=TrajectoryData._new_feet(range_vector.y),\n        slant_height=TrajectoryData._new_feet(range_vector.y * look_angle_cos - range_vector.x * look_angle_sin),\n        drop_adj=TrajectoryData._new_rad(drop_adjustment - (props.look_angle_rad if range_vector.x else 0)),\n        windage=TrajectoryData._new_feet(windage),\n        windage_adj=TrajectoryData._new_rad(windage_adjustment),\n        slant_distance=TrajectoryData._new_feet(range_vector.x * look_angle_cos + range_vector.y * look_angle_sin),\n        angle=TrajectoryData._new_rad(trajectory_angle),\n        density_ratio=density_ratio,\n        drag=drag,\n        energy=TrajectoryData._new_ft_lb(TrajectoryData.calculate_energy(props.weight_grains, velocity)),\n        ogw=TrajectoryData._new_lb(TrajectoryData.calculate_ogw(props.weight_grains, velocity)),\n        flag=flag\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.interpolate","title":"interpolate  <code>staticmethod</code>","text":"<pre><code>interpolate(\n    key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n    value: Union[float, GenericDimension],\n    p0: TrajectoryData,\n    p1: TrajectoryData,\n    p2: TrajectoryData,\n    flag: Union[TrajFlag, int] = NONE,\n    method: InterpolationMethod = \"pchip\",\n) -&gt; TrajectoryData\n</code></pre> <p>Interpolate TrajectoryData where key_attribute==value using PCHIP (default) or linear.</p> <p>Parameters:</p> Name Type Description Default <code>key_attribute</code> <code>TRAJECTORY_DATA_ATTRIBUTES</code> <p>Attribute to key on (e.g., 'time', 'distance').</p> required <code>value</code> <code>Union[float, GenericDimension]</code> <p>Target value for the key attribute. A bare float is treated as raw value for dimensioned fields.</p> required <code>p0</code> <code>TrajectoryData</code> <p>First bracketing point.</p> required <code>p1</code> <code>TrajectoryData</code> <p>Second (middle) bracketing point.</p> required <code>p2</code> <code>TrajectoryData</code> <p>Third bracketing point.</p> required <code>flag</code> <code>Union[TrajFlag, int]</code> <p>Flag to assign to the new point.</p> <code>NONE</code> <code>method</code> <code>InterpolationMethod</code> <p>'pchip' (monotone cubic Hermite) or 'linear'.</p> <code>'pchip'</code> <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>Interpolated point with key_attribute==value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If TrajectoryData doesn't have the specified attribute.</p> <code>KeyError</code> <p>If the key_attribute is 'flag'.</p> <code>ZeroDivisionError</code> <p>If interpolation fails due to zero division.</p> <code>ValueError</code> <p>If method is not one of 'pchip' or 'linear'.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef interpolate(key_attribute: TRAJECTORY_DATA_ATTRIBUTES, value: Union[float, GenericDimension],\n                p0: TrajectoryData, p1: TrajectoryData, p2: TrajectoryData,\n                flag: Union[TrajFlag, int]=TrajFlag.NONE,\n                method: InterpolationMethod = \"pchip\") -&gt; TrajectoryData:\n    \"\"\"\n    Interpolate TrajectoryData where key_attribute==value using PCHIP (default) or linear.\n\n    Args:\n        key_attribute: Attribute to key on (e.g., 'time', 'distance').\n        value: Target value for the key attribute. A bare float is treated as\n            raw value for dimensioned fields.\n        p0: First bracketing point.\n        p1: Second (middle) bracketing point.\n        p2: Third bracketing point.\n        flag: Flag to assign to the new point.\n        method: 'pchip' (monotone cubic Hermite) or 'linear'.\n\n    Returns:\n        Interpolated point with key_attribute==value.\n\n    Raises:\n        AttributeError: If TrajectoryData doesn't have the specified attribute.\n        KeyError: If the key_attribute is 'flag'.\n        ZeroDivisionError: If interpolation fails due to zero division.\n        ValueError: If method is not one of 'pchip' or 'linear'.\n    \"\"\"\n    key_attribute = TRAJECTORY_DATA_SYNONYMS.get(key_attribute, key_attribute)  # Resolve synonyms\n    if not hasattr(TrajectoryData, key_attribute):\n        raise AttributeError(f\"TrajectoryData has no attribute '{key_attribute}'\")\n    if key_attribute == 'flag':\n        raise KeyError(\"Cannot interpolate based on 'flag' attribute\")\n    key_value = value.raw_value if isinstance(value, GenericDimension) else value\n\n    def get_key_val(td):\n        \"\"\"Helper to get the raw value of the key attribute from a TrajectoryData point.\"\"\"\n        val = getattr(td, key_attribute)\n        return val.raw_value if hasattr(val, 'raw_value') else float(val)\n\n    # The independent variable for interpolation (x-axis)\n    x_val = key_value\n    x0, x1, x2 = get_key_val(p0), get_key_val(p1), get_key_val(p2)\n\n    # Use reflection to build the new TrajectoryData object\n    interpolated_fields: typing.Dict[str, typing.Any] = {}\n    for field_name in TrajectoryData._fields:\n        if field_name == 'flag':\n            continue\n\n        p0_field = getattr(p0, field_name)\n\n        if field_name == key_attribute:\n            if isinstance(value, GenericDimension):\n                interpolated_fields[field_name] = value\n            else:  # value is a float, assume it's in the same unit as the original data\n                if isinstance(p0_field, GenericDimension):\n                    interpolated_fields[field_name] = type(p0_field).new_from_raw(float(value), p0_field.units)\n                else:\n                    interpolated_fields[field_name] = float(value)\n            continue\n\n        # Interpolate all other fields\n        y0_val = p0_field\n        y1_val = getattr(p1, field_name)\n        y2_val = getattr(p2, field_name)\n\n        if isinstance(y0_val, GenericDimension):\n            y0, y1, y2 = y0_val.raw_value, y1_val.raw_value, y2_val.raw_value\n            if method == \"pchip\":\n                interpolated_raw = interpolate_3_pt(x_val, x0, y0, x1, y1, x2, y2)\n            elif method == \"linear\":\n                interpolated_raw = interpolate_2_pt(x_val, x0, y0, x1, y1) if x_val &lt;= x1 else interpolate_2_pt(x_val, x1, y1, x2, y2)\n            else:\n                raise ValueError(\"method must be 'pchip' or 'linear'\")\n            interpolated_fields[field_name] = type(y0_val).new_from_raw(interpolated_raw, y0_val.units)\n        elif isinstance(y0_val, (float, int)):\n            fy0, fy1, fy2 = float(y0_val), float(y1_val), float(y2_val)\n            if method == \"pchip\":\n                interpolated_fields[field_name] = interpolate_3_pt(x_val, x0, fy0, x1, fy1, x2, fy2)\n            elif method == \"linear\":\n                interpolated_fields[field_name] = interpolate_2_pt(x_val, x0, fy0, x1, fy1) if x_val &lt;= x1 else interpolate_2_pt(x_val, x1, fy1, x2, fy2)\n            else:\n                raise ValueError(\"method must be 'pchip' or 'linear'\")\n        else:\n            raise TypeError(f\"Cannot interpolate field '{field_name}' of type {type(y0_val)}\")\n\n    interpolated_fields['flag'] = flag\n    return TrajectoryData(**interpolated_fields)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.DangerSpace","title":"DangerSpace","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Stores the danger space data for distance specified.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.DangerSpace.overlay","title":"overlay","text":"<pre><code>overlay(ax: Axes, label: Optional[str] = None) -&gt; None\n</code></pre> <p>Highlights danger-space region on plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to overlay on.</p> required <code>label</code> <code>Optional[str]</code> <p>Label for the overlay. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If plotting dependencies are not installed.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def overlay(self, ax: Axes, label: Optional[str] = None) -&gt; None:\n    \"\"\"Highlights danger-space region on plot.\n\n    Args:\n        ax: The axes to overlay on.\n        label: Label for the overlay. Defaults to None.\n\n    Raises:\n        ImportError: If plotting dependencies are not installed.\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.plot import add_danger_space_overlay  # type: ignore[attr-defined]\n        add_danger_space_overlay(self, ax, label)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get results as a plot\"\n        ) from err\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult","title":"HitResult  <code>dataclass</code>","text":"<pre><code>HitResult(\n    props: ShotProps,\n    trajectory: list[TrajectoryData],\n    base_data: Optional[list[BaseTrajData]],\n    extra: bool = False,\n    error: Optional[RangeError] = None,\n)\n</code></pre> <p>Computed trajectory data of the shot.</p> <p>Attributes:</p> Name Type Description <code>shot</code> <p>The parameters of the shot calculation.</p> <code>trajectory</code> <code>list[TrajectoryData]</code> <p>Computed TrajectoryData points.</p> <code>base_data</code> <code>Optional[list[BaseTrajData]]</code> <p>Base trajectory data points for interpolation.</p> <code>extra</code> <code>bool</code> <p>[DEPRECATED] Whether extra_data was requested.</p> <code>error</code> <code>Optional[RangeError]</code> <p>RangeError, if any.</p> <p>TODO: * Implement dense_output in cythonized engines to populate base_data * Use base_data for interpolation if present</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.zeros","title":"zeros","text":"<pre><code>zeros() -&gt; list[TrajectoryData]\n</code></pre> <p>Get all zero crossing points.</p> <p>Returns:</p> Type Description <code>list[TrajectoryData]</code> <p>Zero crossing points.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If extra_data was not requested.</p> <code>ArithmeticError</code> <p>If zero crossing points are not found.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def zeros(self) -&gt; list[TrajectoryData]:\n    \"\"\"Get all zero crossing points.\n\n    Returns:\n        Zero crossing points.\n\n    Raises:\n        AttributeError: If extra_data was not requested.\n        ArithmeticError: If zero crossing points are not found.\n    \"\"\"\n    self._check_flag(TrajFlag.ZERO)\n    data = [row for row in self.trajectory if row.flag &amp; TrajFlag.ZERO]\n    if len(data) &lt; 1:\n        raise ArithmeticError(\"Can't find zero crossing points\")\n    return data\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.flag","title":"flag","text":"<pre><code>flag(\n    flag: Union[TrajFlag, int],\n) -&gt; Optional[TrajectoryData]\n</code></pre> <p>Get first TrajectoryData row with the specified flag.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Union[TrajFlag, int]</code> <p>The flag to search for.</p> required <p>Returns:</p> Type Description <code>Optional[TrajectoryData]</code> <p>First TrajectoryData row with the specified flag.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If flag was not requested.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def flag(self, flag: Union[TrajFlag, int]) -&gt; Optional[TrajectoryData]:\n    \"\"\"Get first TrajectoryData row with the specified flag.\n\n    Args:\n        flag: The flag to search for.\n\n    Returns:\n        First TrajectoryData row with the specified flag.\n\n    Raises:\n        AttributeError: If flag was not requested.\n    \"\"\"\n    self._check_flag(flag)\n    for row in self.trajectory:\n        if row.flag &amp; flag:\n            return row\n    return None\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.get_at","title":"get_at","text":"<pre><code>get_at(\n    key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n    value: Union[float, GenericDimension],\n    *,\n    epsilon: float = 1e-09,\n    start_from_time: float = 0.0,\n) -&gt; TrajectoryData\n</code></pre> <p>Get TrajectoryData where key_attribute==value.</p> <p>Interpolates to create new object if necessary. Preserves the units of the original trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>key_attribute</code> <code>TRAJECTORY_DATA_ATTRIBUTES</code> <p>The name of the TrajectoryData attribute to key on (e.g., 'time', 'distance').</p> required <code>value</code> <code>Union[float, GenericDimension]</code> <p>The value of the key attribute to find. If a float is provided    for a dimensioned attribute, it's assumed to be a .raw_value.</p> required <code>epsilon</code> <code>float</code> <p>Allowed key value difference to match existing TrajectoryData object without interpolating.</p> <code>1e-09</code> <code>start_from_time</code> <code>float</code> <p>The time to center the search from (default is 0.0).  If the target value is              at a local extremum then the search will only go forward in time.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>TrajectoryData where key_attribute==value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If TrajectoryData doesn't have the specified attribute.</p> <code>KeyError</code> <p>If the key_attribute is 'flag'.</p> <code>ValueError</code> <p>If interpolation is required and len(self.trajectory) &lt; 3.</p> <code>ArithmeticError</code> <p>If trajectory doesn't reach the requested value.</p> Notes <ul> <li>Not all attributes are monotonic: Height typically goes up and then down.     Velocity typically goes down, but for lofted trajectories can begin to increase.     Windage can wander back and forth in complex winds. We even have (see ExtremeExamples.ipynb)     backward-bending scenarios in which distance reverses!</li> <li>The only guarantee is that time is strictly increasing.</li> </ul> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def get_at(self, key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n                 value: Union[float, GenericDimension], *,\n                 epsilon: float = 1e-9,\n                 start_from_time: float=0.0) -&gt; TrajectoryData:\n    \"\"\"Get TrajectoryData where key_attribute==value.\n\n    Interpolates to create new object if necessary. Preserves the units of the original trajectory data.\n\n    Args:\n        key_attribute: The name of the TrajectoryData attribute to key on (e.g., 'time', 'distance').\n        value: The value of the key attribute to find. If a float is provided\n               for a dimensioned attribute, it's assumed to be a .raw_value.\n        epsilon: Allowed key value difference to match existing TrajectoryData object without interpolating.\n        start_from_time: The time to center the search from (default is 0.0).  If the target value is\n                         at a local extremum then the search will only go forward in time.\n\n    Returns:\n        TrajectoryData where key_attribute==value.\n\n    Raises:\n        AttributeError: If TrajectoryData doesn't have the specified attribute.\n        KeyError: If the key_attribute is 'flag'.\n        ValueError: If interpolation is required and len(self.trajectory) &lt; 3.\n        ArithmeticError: If trajectory doesn't reach the requested value.\n\n    Notes:\n        * Not all attributes are monotonic: Height typically goes up and then down.\n            Velocity typically goes down, but for lofted trajectories can begin to increase.\n            Windage can wander back and forth in complex winds. We even have (see ExtremeExamples.ipynb)\n            backward-bending scenarios in which distance reverses!\n        * The only guarantee is that time is strictly increasing.\n    \"\"\"\n    key_attribute = TRAJECTORY_DATA_SYNONYMS.get(key_attribute, key_attribute)  # Resolve synonyms\n    if not hasattr(TrajectoryData, key_attribute):\n        raise AttributeError(f\"TrajectoryData has no attribute '{key_attribute}'\")\n    if key_attribute == 'flag':\n        raise KeyError(\"Cannot interpolate based on 'flag' attribute\")\n\n    traj = self.trajectory\n    n = len(traj)\n    key_value = value.raw_value if isinstance(value, GenericDimension) else value\n\n    def get_key_val(td):\n        \"\"\"Helper to get the raw value of the key attribute from a TrajectoryData point.\"\"\"\n        val = getattr(td, key_attribute)\n        return val.raw_value if hasattr(val, 'raw_value') else val\n\n    if n &lt; 3:  # We won't interpolate on less than 3 points, but check for an exact match in the existing rows.\n        if abs(get_key_val(traj[0]) - key_value) &lt; epsilon:\n            return traj[0]\n        if n &gt; 1 and abs(get_key_val(traj[1]) - key_value) &lt; epsilon:\n            return traj[1]\n        raise ValueError(\"Interpolation requires at least 3 TrajectoryData points.\")\n\n    # Find the starting index based on start_from_time\n    start_idx = 0\n    if start_from_time &gt; 0:\n        start_idx = next((i for i, td in enumerate(traj) if td.time &gt;= start_from_time), 0)\n    curr_val = get_key_val(traj[start_idx])\n    if abs(curr_val - key_value) &lt; epsilon:  # Check for exact match\n        return traj[start_idx]\n    # Determine search direction from the starting point\n    search_forward = True  # Default to forward search\n    if start_idx == n - 1:  # We're at the last point, search backwards            \n        search_forward = False\n    if 0 &lt; start_idx &lt; n - 1:\n        # We're in the middle of the trajectory, determine local direction towards key_value\n        next_val = get_key_val(traj[start_idx + 1])\n        if (next_val &gt; curr_val and key_value &gt; curr_val) or (next_val &lt; curr_val and key_value &lt; curr_val):\n            search_forward = True\n        else:\n            search_forward = False\n\n    # Search for the target value in the determined direction\n    target_idx = -1\n    if search_forward:  # Search forward from start_idx            \n        for i in range(start_idx, n - 1):\n            curr_val = get_key_val(traj[i])\n            next_val = get_key_val(traj[i + 1])\n            # Check if key_value is between curr_val and next_val\n            if ((curr_val &lt; key_value &lt;= next_val) or (next_val &lt;= key_value &lt; curr_val)):\n                target_idx = i + 1\n                break\n    if not search_forward or target_idx == -1:  # Search backward from start_idx\n        for i in range(start_idx, 0, -1):\n            curr_val = get_key_val(traj[i])\n            prev_val = get_key_val(traj[i - 1])\n            # Check if key_value is between prev_val and curr_val\n            if ((prev_val &lt;= key_value &lt; curr_val) or (curr_val &lt; key_value &lt;= prev_val)):\n                target_idx = i\n                break\n\n    # Check if we found a valid index\n    if target_idx == -1:\n        raise ArithmeticError(f\"Trajectory does not reach {key_attribute} = {value}\")\n    # Check for exact match here\n    if abs(get_key_val(traj[target_idx]) - key_value) &lt; epsilon:\n        return traj[target_idx]\n    if target_idx == 0:  # Step forward from first point so we can interpolate\n        target_idx = 1\n    # Choose three bracketing points (p0, p1, p2)\n    if target_idx &gt;= n - 1:  # At or after the last point\n        p0, p1, p2 = traj[n - 3], traj[n - 2], traj[n - 1]\n    else:\n        p0, p1, p2 = traj[target_idx - 1], traj[target_idx], traj[target_idx + 1]\n    return TrajectoryData.interpolate(key_attribute, value, p0, p1, p2)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.index_at_distance","title":"index_at_distance","text":"<pre><code>index_at_distance(d: Distance) -&gt; int\n</code></pre> <p>Deprecated. Use get_at() instead.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Distance</code> <p>Distance for which we want Trajectory Data.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of first trajectory row with .distance &gt;= d; otherwise -1.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use get_at() instead for better flexibility.\")\ndef index_at_distance(self, d: Distance) -&gt; int:\n    \"\"\"Deprecated. Use get_at() instead.\n\n    Args:\n        d: Distance for which we want Trajectory Data.\n\n    Returns:\n        Index of first trajectory row with .distance &gt;= d; otherwise -1.\n    \"\"\"\n    epsilon = 1e-1  # small value to avoid floating point issues\n    return next((i for i in range(len(self.trajectory))\n                 if self.trajectory[i].distance.raw_value &gt;= d.raw_value - epsilon), -1)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.get_at_distance","title":"get_at_distance","text":"<pre><code>get_at_distance(d: Distance) -&gt; TrajectoryData\n</code></pre> <p>Deprecated. Use get_at('distance', d) instead.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Distance</code> <p>Distance for which we want Trajectory Data.</p> required <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>First trajectory row with .distance &gt;= d.</p> <p>Raises:</p> Type Description <code>ArithmeticError</code> <p>If trajectory doesn't reach requested distance.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use get_at('distance', d)\")\ndef get_at_distance(self, d: Distance) -&gt; TrajectoryData:\n    \"\"\"Deprecated. Use get_at('distance', d) instead.\n\n    Args:\n        d: Distance for which we want Trajectory Data.\n\n    Returns:\n        First trajectory row with .distance &gt;= d.\n\n    Raises:\n        ArithmeticError: If trajectory doesn't reach requested distance.\n    \"\"\"\n    if (i := self.index_at_distance(d)) &lt; 0:\n        raise ArithmeticError(\n            f\"Calculated trajectory doesn't reach requested distance {d}\"\n        )\n    return self.trajectory[i]\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.get_at_time","title":"get_at_time","text":"<pre><code>get_at_time(t: float) -&gt; TrajectoryData\n</code></pre> <p>Deprecated. Use get_at('time', t) instead.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time for which we want Trajectory Data.</p> required <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>First trajectory row with .time &gt;= t.</p> <p>Raises:</p> Type Description <code>ArithmeticError</code> <p>If trajectory doesn't reach requested time.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use get_at('time', t)\")\ndef get_at_time(self, t: float) -&gt; TrajectoryData:\n    \"\"\"Deprecated. Use get_at('time', t) instead.\n\n    Args:\n        t: Time for which we want Trajectory Data.\n\n    Returns:\n        First trajectory row with .time &gt;= t.\n\n    Raises:\n        ArithmeticError: If trajectory doesn't reach requested time.\n    \"\"\"\n    epsilon = 1e-6  # small value to avoid floating point issues\n    idx = next((i for i in range(len(self.trajectory))\n                 if self.trajectory[i].time &gt;= t - epsilon), -1)\n    if idx &lt; 0:\n        raise ArithmeticError(\n            f\"Calculated trajectory doesn't reach requested time {t}\"\n        )\n    return self.trajectory[idx]\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.danger_space","title":"danger_space","text":"<pre><code>danger_space(\n    at_range: Union[float, Distance],\n    target_height: Union[float, Distance],\n) -&gt; DangerSpace\n</code></pre> <p>Calculate the danger space for a target.</p> <pre><code>Assumes that the trajectory hits the center of a target at any distance.\nDetermines how much ranging error can be tolerated if the critical region\nof the target has target_height *h*. Finds how far forward and backward along the\nline of sight a target can move such that the trajectory is still within *h*/2\nof the original drop at_range.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>at_range</code> <code>Union[float, Distance]</code> <p>Danger space is calculated for a target centered at this sight distance.</p> required <code>target_height</code> <code>Union[float, Distance]</code> <p>Target height (h) determines danger space.</p> required <p>Returns:</p> Name Type Description <code>DangerSpace</code> <code>DangerSpace</code> <p>The calculated danger space.</p> <p>Raises:</p> Type Description <code>ArithmeticError</code> <p>If trajectory doesn't reach requested distance.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def danger_space(self,\n                 at_range: Union[float, Distance],\n                 target_height: Union[float, Distance],\n                 ) -&gt; DangerSpace:\n    \"\"\"Calculate the danger space for a target.\n\n        Assumes that the trajectory hits the center of a target at any distance.\n        Determines how much ranging error can be tolerated if the critical region\n        of the target has target_height *h*. Finds how far forward and backward along the\n        line of sight a target can move such that the trajectory is still within *h*/2\n        of the original drop at_range.\n\n    Args:\n        at_range: Danger space is calculated for a target centered at this sight distance.\n        target_height: Target height (*h*) determines danger space.\n\n    Returns:\n        DangerSpace: The calculated danger space.\n\n    Raises:\n        ArithmeticError: If trajectory doesn't reach requested distance.\n    \"\"\"\n    target_at_range = PreferredUnits.distance(at_range)\n    target_height = PreferredUnits.target_height(target_height)\n    target_height_half = target_height.raw_value / 2.0\n\n    target_row = self.get_at('slant_distance', target_at_range)\n    is_climbing = target_row.angle.raw_value - self.props.look_angle.raw_value &gt; 0\n    slant_height_begin = target_row.slant_height.raw_value + (-1 if is_climbing else 1) * target_height_half\n    slant_height_end = target_row.slant_height.raw_value - (-1 if is_climbing else 1) * target_height_half\n    try:\n        begin_row = self.get_at('slant_height', slant_height_begin, start_from_time=target_row.time)\n    except ArithmeticError:\n        begin_row = self.trajectory[0]\n    try:\n        end_row = self.get_at('slant_height', slant_height_end, start_from_time=target_row.time)\n    except ArithmeticError:\n        end_row = self.trajectory[-1]\n\n    return DangerSpace(target_row,\n                       target_height,\n                       begin_row,\n                       end_row,\n                       self.props.look_angle)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.dataframe","title":"dataframe","text":"<pre><code>dataframe(formatted: bool = False) -&gt; DataFrame\n</code></pre> <p>Return the trajectory table as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>formatted</code> <code>bool</code> <p>False for values as floats; True for strings in PreferredUnits. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The trajectory table as a DataFrame.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If pandas or plotting dependencies are not installed.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def dataframe(self, formatted: bool = False) -&gt; DataFrame:\n    \"\"\"Return the trajectory table as a DataFrame.\n\n    Args:\n        formatted: False for values as floats; True for strings in PreferredUnits. Default is False.\n\n    Returns:\n        The trajectory table as a DataFrame.\n\n    Raises:\n        ImportError: If pandas or plotting dependencies are not installed.\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.dataframe import hit_result_as_dataframe\n        return hit_result_as_dataframe(self, formatted)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get trajectory as pandas.DataFrame\"\n        ) from err\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.plot","title":"plot","text":"<pre><code>plot(look_angle: Optional[Angular] = None) -&gt; Axes\n</code></pre> <p>Return a graph of the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>look_angle</code> <code>Optional[Angular]</code> <p>Look angle for the plot. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The plot Axes object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If plotting dependencies are not installed.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def plot(self, look_angle: Optional[Angular] = None) -&gt; Axes:\n    \"\"\"Return a graph of the trajectory.\n\n    Args:\n        look_angle (Optional[Angular], optional): Look angle for the plot. Defaults to None.\n\n    Returns:\n        The plot Axes object.\n\n    Raises:\n        ImportError: If plotting dependencies are not installed.\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.plot import hit_result_as_plot  # type: ignore[attr-defined]\n        return hit_result_as_plot(self, look_angle)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get results as a plot\"\n        ) from err\n</code></pre>"},{"location":"api/unit/","title":"Unit System","text":"<p>Unit conversion system for ballistic calculations.</p> <p>This module provides a comprehensive type-safe unit conversion system, supporting physical dimensions including angles, distance, energy, pressure, temperature, time, velocity, and weight.</p> <p>The system uses a base class <code>GenericDimension</code> with specialized subclasses for each physical dimension. Each dimension maintains its values internally in a fixed raw unit (e.g., inches for distance, m/s for velocity) and provides conversion methods to any supported unit within that dimension.</p> Key Features <ul> <li>Type-safe unit conversions and arithmetic operators</li> <li>Flexible conversion syntax with operator overloading</li> <li>String parsing and unit alias resolution</li> <li>Default <code>PreferredUnits</code> configuration</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # ----------------- Creation and conversion -----------------\n&gt;&gt;&gt; d = Distance.Yard(100)  \n&gt;&gt;&gt; d.convert(Unit.Meter)      # Conversion method -&gt; Distance\n&lt;Distance: 91.4m (3600.0)&gt;\n&gt;&gt;&gt; d &lt;&lt; Distance.Feet         # Conversion operator -&gt; Distance\n&lt;Distance: 300.0ft (3600.0)&gt;\n&gt;&gt;&gt; d.get_in(Distance.Foot)    # Conversion method -&gt; float\n300.0\n&gt;&gt;&gt; d &gt;&gt; Distance.Inch         # Conversion operator -&gt; float\n3600.0\n&gt;&gt;&gt; # ----------------------- Arithmetic -----------------------\n&gt;&gt;&gt; d - 30\n&lt;Distance: 70.0yd (2520.0)&gt;\n&gt;&gt;&gt; d + Distance.Feet(2)\n&lt;Distance: 100.7yd (3624.0)&gt;\n&gt;&gt;&gt; 3 * d\n&lt;Distance: 300.0yd (10800.0)&gt;\n&gt;&gt;&gt; d / 2\n&lt;Distance: 50.0yd (1800.0)&gt;\n&gt;&gt;&gt; d / Unit.Foot(3)\n100.0\n</code></pre> Supported Dimensions <ul> <li>Angular: radian, degree, MOA, mil, mrad, thousandth, inch/100yd, cm/100m, o'clock</li> <li>Distance: inch, foot, yard, mile, nautical mile, mm, cm, m, km, line</li> <li>Energy: foot-pound, joule</li> <li>Pressure: mmHg, inHg, bar, hPa, PSI</li> <li>Temperature: Fahrenheit, Celsius, Kelvin, Rankine</li> <li>Time: second, minute, millisecond, microsecond, nanosecond, picosecond</li> <li>Velocity: m/s, km/h, ft/s, mph, knots</li> <li>Weight: grain, ounce, gram, pound, kilogram, newton</li> </ul>"},{"location":"api/unit/#py_ballisticcalc.unit.UnitTypeError","title":"UnitTypeError","text":"<p>               Bases: <code>TypeError</code></p> <p>Unit type error</p>"},{"location":"api/unit/#py_ballisticcalc.unit.UnitConversionError","title":"UnitConversionError","text":"<p>               Bases: <code>UnitTypeError</code></p> <p>Unit conversion error</p>"},{"location":"api/unit/#py_ballisticcalc.unit.UnitAliasError","title":"UnitAliasError","text":"<p>               Bases: <code>ValueError</code></p> <p>Unit alias error</p>"},{"location":"api/unit/#py_ballisticcalc.unit.counter","title":"counter","text":"<pre><code>counter(\n    start: Number = 0,\n    step: Number = 1,\n    end: Optional[Number] = None,\n) -&gt; Iterable[Number]\n</code></pre> <p>Generate a sequence of numbers with optional bounds.</p> <p>Creates an arithmetic sequence starting at 'start' with a constant increment/decrement of 'step'. Can generate infinite sequences or bounded sequences up to 'end'.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Number</code> <p>Initial value for the sequence. Defaults to 0.</p> <code>0</code> <code>step</code> <code>Number</code> <p>Increment/decrement step value. Cannot be 0 for infinite iteration.   Positive values create ascending sequences, negative values create descending sequences. Defaults to 1.</p> <code>1</code> <code>end</code> <code>Optional[Number]</code> <p>Final value (exclusive) for bounded sequences. If None, creates an infinite sequence. Defaults to None.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>Number</code> <code>Iterable[Number]</code> <p>The next value in the arithmetic sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'step' is 0 for infinite iteration, or if 'step' has the wrong sign         for the given 'start' and 'end' range (e.g., positive step with start &gt; end).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Finite ascending sequence\n&gt;&gt;&gt; list(counter(0, 1, 5))\n[0, 1, 2, 3, 4]\n</code></pre> <pre><code>&gt;&gt;&gt; # Finite descending sequence\n&gt;&gt;&gt; list(counter(10, -2, 0))\n[10, 8, 6, 4, 2]\n</code></pre> <pre><code>&gt;&gt;&gt; # Infinite sequence (first 3 values)\n&gt;&gt;&gt; iter_seq = counter(1, 0.5)\n&gt;&gt;&gt; [next(iter_seq) for _ in range(3)]\n[1, 1.5, 2.0]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def counter(start: Number = 0, step: Number = 1, end: Optional[Number] = None) -&gt; Iterable[Number]:\n    \"\"\"Generate a sequence of numbers with optional bounds.\n\n    Creates an arithmetic sequence starting at 'start' with a constant increment/decrement of 'step'.\n    Can generate infinite sequences or bounded sequences up to 'end'.\n\n    Args:\n        start: Initial value for the sequence. Defaults to 0.\n        step: Increment/decrement step value. Cannot be 0 for infinite iteration.\n              Positive values create ascending sequences, negative values create descending sequences. Defaults to 1.\n        end: Final value (exclusive) for bounded sequences. If None, creates an infinite sequence. Defaults to None.\n\n    Yields:\n        Number: The next value in the arithmetic sequence.\n\n    Raises:\n        ValueError: If 'step' is 0 for infinite iteration, or if 'step' has the wrong sign\n                    for the given 'start' and 'end' range (e.g., positive step with start &gt; end).\n\n    Examples:\n        &gt;&gt;&gt; # Finite ascending sequence\n        &gt;&gt;&gt; list(counter(0, 1, 5))\n        [0, 1, 2, 3, 4]\n\n        &gt;&gt;&gt; # Finite descending sequence\n        &gt;&gt;&gt; list(counter(10, -2, 0))\n        [10, 8, 6, 4, 2]\n\n        &gt;&gt;&gt; # Infinite sequence (first 3 values)\n        &gt;&gt;&gt; iter_seq = counter(1, 0.5)\n        &gt;&gt;&gt; [next(iter_seq) for _ in range(3)]\n        [1, 1.5, 2.0]\n    \"\"\"\n    if step == 0:\n        if end is None:\n            raise ValueError(\"For infinite iteration, 'step' cannot be zero.\")\n        else:\n            if (end &gt; start and start &lt;= end) or (end &lt; start and start &gt;= end) or (start == end):\n                yield start\n            return\n\n    current = start\n    if end is None:\n        while True:\n            yield current\n            current += step\n    else:\n        if step &gt; 0:\n            if start &gt; end:\n                raise ValueError(\"For an incremental step (step &gt; 0), 'start' cannot be greater than 'end'.\")\n            while current &lt; end:\n                yield current\n                current += step\n        else:  # step &lt; 0\n            if start &lt; end:\n                raise ValueError(\"For a decrementing step (step &lt; 0), 'start' cannot be less than 'end'.\")\n            while current &gt; end:\n                yield current\n                current += step\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.iterator","title":"iterator","text":"<pre><code>iterator(\n    items: Sequence[Number],\n    /,\n    *,\n    sort: bool = False,\n    key: Optional[Callable[[Number], Any]] = None,\n    reverse: bool = False,\n) -&gt; Generator[Number, None, None]\n</code></pre> <p>Create a generator from a sequence of numbers with optional sorting.</p> <p>Provides a flexible iterator interface for numeric sequences. Supports optional sorting with custom key functions and reverse ordering.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[Number]</code> <p>Sequence of numeric values (integers or floats) to iterate over.</p> required <code>sort</code> <code>bool</code> <p>If True, sort the items before iteration. Defaults to False.</p> <code>False</code> <code>key</code> <code>Optional[Callable[[Number], Any]]</code> <p>Optional function to extract comparison key from each item.  Used only when sort=True. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If True, reverse the iteration order (used with sorting).      Defaults to False.</p> <code>False</code> <p>Yields:</p> Name Type Description <code>Number</code> <code>Number</code> <p>Each numeric value from the sequence in the specified order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Basic iteration\n&gt;&gt;&gt; list(iterator([3, 1, 4, 2]))\n[3, 1, 4, 2]\n</code></pre> <pre><code>&gt;&gt;&gt; # Sorted iteration\n&gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True))\n[1, 2, 3, 4]\n</code></pre> <pre><code>&gt;&gt;&gt; # Reverse sorted iteration\n&gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True, reverse=True))\n[4, 3, 2, 1]\n</code></pre> <pre><code>&gt;&gt;&gt; # Custom key function\n&gt;&gt;&gt; list(iterator([-3, 1, -4, 2], sort=True, key=abs))\n[1, 2, -3, -4]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def iterator(items: Sequence[Number], /, *,\n             sort: bool = False,\n             key: Optional[Callable[[Number], Any]] = None,\n             reverse: bool = False) -&gt; Generator[Number, None, None]:\n    \"\"\"Create a generator from a sequence of numbers with optional sorting.\n\n    Provides a flexible iterator interface for numeric sequences.\n    Supports optional sorting with custom key functions and reverse ordering.\n\n    Args:\n        items: Sequence of numeric values (integers or floats) to iterate over.\n        sort: If True, sort the items before iteration. Defaults to False.\n        key: Optional function to extract comparison key from each item.\n             Used only when sort=True. Defaults to None.\n        reverse: If True, reverse the iteration order (used with sorting).\n                 Defaults to False.\n\n    Yields:\n        Number: Each numeric value from the sequence in the specified order.\n\n    Examples:\n        &gt;&gt;&gt; # Basic iteration\n        &gt;&gt;&gt; list(iterator([3, 1, 4, 2]))\n        [3, 1, 4, 2]\n\n        &gt;&gt;&gt; # Sorted iteration\n        &gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True))\n        [1, 2, 3, 4]\n\n        &gt;&gt;&gt; # Reverse sorted iteration\n        &gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True, reverse=True))\n        [4, 3, 2, 1]\n\n        &gt;&gt;&gt; # Custom key function\n        &gt;&gt;&gt; list(iterator([-3, 1, -4, 2], sort=True, key=abs))\n        [1, 2, -3, -4]\n    \"\"\"\n    if sort:\n        items = sorted(items, key=key, reverse=reverse)\n    for v in items:\n        yield v\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Unit","title":"Unit","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of all supported unit types.</p> <p>Angular Units: - Radian, Degree, MOA (Minute of Arc), Mil, MRad (Milliradian), Thousandth, InchesPer100Yd, CmPer100m, OClock</p> <p>Distance Units: - Inch, Foot, Yard, Mile, NauticalMile, Millimeter, Centimeter, Meter, Kilometer, Line</p> <p>Velocity Units: - MPS (meters/second), KMH (km/hour), FPS (feet/second), MPH (miles/hour), KT (knots)</p> <p>Weight Units: - Grain, Ounce, Gram, Pound, Kilogram, Newton</p> <p>Pressure Units: - MmHg, InHg, Bar, hPa (hectopascal), PSI</p> <p>Temperature Units: - Fahrenheit, Celsius, Kelvin, Rankin</p> <p>Energy Units: - FootPound, Joule</p> <p>Time Units: - Second, Minute, Millisecond, Microsecond, Nanosecond, Picosecond</p> <p>Each unit can be used as a callable constructor for creating unit instances:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create distance measurements\n&gt;&gt;&gt; distance = Unit.Meter(100)\n&gt;&gt;&gt; range_yards = Unit.Yard(109.4)\n</code></pre> <pre><code>&gt;&gt;&gt; # Create velocity measurements\n&gt;&gt;&gt; muzzle_velocity = Unit.FPS(2800)\n&gt;&gt;&gt; velocity_mps = Unit.MPS(853.4)\n</code></pre> <pre><code>&gt;&gt;&gt; # Angular measurements for ballistics\n&gt;&gt;&gt; elevation = Unit.MOA(2.5)\n&gt;&gt;&gt; windage = Unit.Mil(1.2)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Unit.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>Readable name of the unit of measure.</p>"},{"location":"api/unit/#py_ballisticcalc.unit.Unit.accuracy","title":"accuracy  <code>property</code>","text":"<pre><code>accuracy: int\n</code></pre> <p>Default accuracy of the unit of measure.</p>"},{"location":"api/unit/#py_ballisticcalc.unit.Unit.symbol","title":"symbol  <code>property</code>","text":"<pre><code>symbol: str\n</code></pre> <p>Short symbol of the unit of measure.</p>"},{"location":"api/unit/#py_ballisticcalc.unit.Unit.counter","title":"counter","text":"<pre><code>counter(\n    start: Number,\n    step: Number,\n    end: Optional[Number] = None,\n    include_end: bool = True,\n) -&gt; Generator[GenericDimension, None, None]\n</code></pre> <p>Generate a finite or infinite sequence of <code>GenericDimension</code> objects.</p> <p>This function acts as a counter for measurements, yielding <code>GenericDimension</code> instances at specified intervals, defined by <code>start</code>, <code>step</code>, and <code>end</code>. The underlying numeric values are handled as raw values of the given unit.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Number</code> <p>The starting raw value for the sequence. Defaults to 0.</p> required <code>step</code> <code>Number</code> <p>The increment/decrement step for the sequence.                 Must not be 0 for an infinite sequence. Defaults to 0.</p> required <code>end</code> <code>Optional[Number]</code> <p>The raw value at which the sequence should stop (exclusive by default).                          If <code>None</code>, the sequence is infinite. Defaults to <code>None</code>.</p> <code>None</code> <code>include_end</code> <code>bool</code> <p>If <code>True</code> and <code>end</code> is provided, the <code>end</code> value will be                 included in the sequence. Defaults to <code>True</code>.</p> <code>True</code> <p>Yields:</p> Type Description <code>GenericDimension</code> <p>GenericDimension[Any]: A <code>GenericDimension</code> object representing the current measurement in the sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>step</code> is 0 for an infinite sequence, or if <code>step</code> has the wrong direction for the given <code>start</code> and <code>end</code> range.</p> <code>StopIteration</code> <p>If the iteration limit (<code>MAX_ITERATIONS</code>) is reached during an infinite sequence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(Unit.Millisecond.counter(start=0, step=10, end=30))   \n[&lt;Time: 0.0ms (0.0)&gt;, &lt;Time: 10.0ms (0.01)&gt;, &lt;Time: 20.0ms (0.02)&gt;, &lt;Time: 30.0ms (0.03)&gt;]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def counter(self, start: Number, step: Number,\n    end: Optional[Number] = None, include_end: bool = True) -&gt; Generator[GenericDimension, None, None]:\n    \"\"\"Generate a finite or infinite sequence of `GenericDimension` objects.\n\n    This function acts as a counter for measurements, yielding `GenericDimension`\n    instances at specified intervals, defined by `start`, `step`, and `end`.\n    The underlying numeric values are handled as raw values of the given unit.\n\n    Args:\n        start: The starting raw value for the sequence. Defaults to 0.\n        step: The increment/decrement step for the sequence.\n                            Must not be 0 for an infinite sequence. Defaults to 0.\n        end: The raw value at which the sequence should stop (exclusive by default).\n                                     If `None`, the sequence is infinite. Defaults to `None`.\n        include_end: If `True` and `end` is provided, the `end` value will be\n                            included in the sequence. Defaults to `True`.\n\n    Yields:\n        GenericDimension[Any]: A `GenericDimension` object representing the current measurement in the sequence.\n\n    Raises:\n        ValueError:\n            If `step` is 0 for an infinite sequence, or if `step` has the wrong\n            direction for the given `start` and `end` range.\n        StopIteration:\n            If the iteration limit (`MAX_ITERATIONS`) is reached during an infinite sequence.\n\n    Examples:\n        &gt;&gt;&gt; list(Unit.Millisecond.counter(start=0, step=10, end=30))   \n        [&lt;Time: 0.0ms (0.0)&gt;, &lt;Time: 10.0ms (0.01)&gt;, &lt;Time: 20.0ms (0.02)&gt;, &lt;Time: 30.0ms (0.03)&gt;]\n    \"\"\"\n    _start: GenericDimension = self(start)\n    _step: GenericDimension = self(step)\n    _end: Optional[GenericDimension] = self(end) if end is not None else None\n\n    _start_raw: Number = _start.raw_value\n    _step_raw: Number = _step.raw_value\n    _end_raw: Optional[Number] = _end.raw_value if _end is not None else None\n\n    if _end_raw is not None and include_end:\n        _end_raw += _step_raw\n    for i, raw_value in enumerate(counter(_start_raw, _step_raw, _end_raw)):\n        value: GenericDimension = self(0)\n        value._value = raw_value\n        yield value\n        if i == MAX_ITERATIONS:\n            raise StopIteration(\"Max counter iterations limit is %d\" % MAX_ITERATIONS)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Unit.iterator","title":"iterator","text":"<pre><code>iterator(\n    items: Sequence[Number],\n    /,\n    *,\n    sort: bool = False,\n    reverse: bool = False,\n) -&gt; Generator[\"GenericDimension[Any]\", None, None]\n</code></pre> <p>Create a sorted sequence of <code>GenericDimension</code> objects from raw numeric values.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[Number]</code> <p>A sequence of raw numeric values (integers or floats).</p> required <code>sort</code> <code>bool</code> <p>If set to <code>True</code>, the elements will be sorted before yield.</p> <code>False</code> <code>reverse</code> <code>bool</code> <p>If set to <code>True</code>, the elements are sorted in descending order. Defaults to <code>False</code>.</p> <code>False</code> <p>Yields:</p> Name Type Description <code>_GenericDimensionType</code> <code>'GenericDimension[Any]'</code> <p>A <code>GenericDimension</code> object of the specific type implied by <code>u</code>, in sorted order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(Unit.Foot.iterator([5, 1, 2], sort=True))  # Inferred as Iterable[Distance]\n[&lt;Distance: 1.0ft (12.0)&gt;, &lt;Distance: 2.0ft (24.0)&gt;, &lt;Distance: 5.0ft (60.0)&gt;]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def iterator(self, items: Sequence[Number], /, *,\n             sort: bool = False,\n             reverse: bool = False) -&gt; Generator[\"GenericDimension[Any]\", None, None]:\n    \"\"\"Create a sorted sequence of `GenericDimension` objects from raw numeric values.\n\n    Args:\n        items: A sequence of raw numeric values (integers or floats).\n        sort: If set to `True`, the elements will be sorted before yield.\n        reverse: If set to `True`, the elements are sorted in descending order. Defaults to `False`.\n\n    Yields:\n        _GenericDimensionType: A `GenericDimension` object of the specific type implied by `u`, in sorted order.\n\n    Examples:\n        &gt;&gt;&gt; list(Unit.Foot.iterator([5, 1, 2], sort=True))  # Inferred as Iterable[Distance]\n        [&lt;Distance: 1.0ft (12.0)&gt;, &lt;Distance: 2.0ft (24.0)&gt;, &lt;Distance: 5.0ft (60.0)&gt;]\n    \"\"\"\n    iter_ = iterator(items, sort=sort, reverse=reverse)\n    for v in iter_:\n        yield self(v)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.UnitProps","title":"UnitProps","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Properties and display characteristics for unit measurements.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Human-readable name of the unit (e.g., 'meter', 'foot-pound').</p> <code>accuracy</code> <code>int</code> <p>Number of decimal places for formatting values for display.</p> <code>symbol</code> <code>str</code> <p>Standard symbol or abbreviation for the unit (e.g., 'm', 'ft\u00b7lb').</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = Distance.Yard(600)\n&gt;&gt;&gt; print(d &lt;&lt; Distance.Kilometer)\n0.549km\n&gt;&gt;&gt; UnitPropsDict[Unit.Kilometer] = UnitProps(\"kilometer\", 5, \" kilometers\")\n&gt;&gt;&gt; print(d &lt;&lt; Distance.Kilometer)\n0.54864 kilometers\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension","title":"GenericDimension","text":"<pre><code>GenericDimension(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>Generic[_GenericDimensionType]</code></p> <p>Abstract base class for typed unit dimensions.</p> <p>This class provides the foundation for all unit measurements in the ballistic calculation system. Each dimension (Distance, Velocity, Angular, etc.) inherits from this class and defines its own conversion factors and raw unit representation.</p> <p>Attributes:</p> Name Type Description <code>_value</code> <code>Number</code> <p>Internal value stored in the dimension's raw unit.</p> <code>_defined_units</code> <code>Unit</code> <p>The unit type this instance was created with.</p> <code>_conversion_factors</code> <code>Mapping[Unit, float]</code> <p>Mapping of units to their conversion factors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Subclasses define their own conversion factors\n&gt;&gt;&gt; class Distance(GenericDimension):\n...     _conversion_factors = {Unit.Meter: 39.3701, Unit.Yard: 36.0}\n</code></pre> <pre><code>&gt;&gt;&gt; # Create and convert measurements\n&gt;&gt;&gt; meters = Distance(100, Unit.Meter)\n&gt;&gt;&gt; yards = meters.convert(Unit.Yard)\n&gt;&gt;&gt; print(f\"100m = {yards.unit_value:.1f} yards\")\n100m = 109.4 yards\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Number</code> <p>Numeric value of the measurement in the specified units.</p> required <code>units</code> <code>Unit</code> <p>Unit enum specifying the unit type for the value.</p> required Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.new_from_raw","title":"new_from_raw  <code>classmethod</code>","text":"<pre><code>new_from_raw(raw_value: float, to_units: Unit) -&gt; Self\n</code></pre> <p>Create a new instance from a raw value in base units.</p> <p>Parameters:</p> Name Type Description Default <code>raw_value</code> <code>float</code> <p>Value in the dimension's raw unit (e.g., inches for Distance).</p> required <code>to_units</code> <code>Unit</code> <p>Target unit type for the new instance.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New instance with the raw value converted to the specified units.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef new_from_raw(cls, raw_value: float, to_units: Unit) -&gt; Self:\n    \"\"\"Create a new instance from a raw value in base units.\n\n    Args:\n        raw_value: Value in the dimension's raw unit (e.g., inches for Distance).\n        to_units: Target unit type for the new instance.\n\n    Returns:\n        New instance with the raw value converted to the specified units.\n    \"\"\"\n    value_in_units = raw_value / cls._get_conversion_factor(to_units)\n    return cls(value_in_units, to_units)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.from_raw","title":"from_raw  <code>classmethod</code>","text":"<pre><code>from_raw(raw_value: float, unit: Unit) -&gt; Number\n</code></pre> <p>Convert a raw value to the specified units.</p> <p>Parameters:</p> Name Type Description Default <code>raw_value</code> <code>float</code> <p>Value in the dimension's raw unit.</p> required <code>unit</code> <code>Unit</code> <p>Target unit type for conversion.</p> required <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value converted to the specified units.</p> Note <p>Static conversion method that doesn't create a unit instance.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef from_raw(cls, raw_value: float, unit: Unit) -&gt; Number:\n    \"\"\"Convert a raw value to the specified units.\n\n    Args:\n        raw_value: Value in the dimension's raw unit.\n        unit: Target unit type for conversion.\n\n    Returns:\n        Numeric value converted to the specified units.\n\n    Note:\n        Static conversion method that doesn't create a unit instance.\n    \"\"\"\n    cls._validate_unit_type(unit)\n    return raw_value / cls._get_conversion_factor(unit)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.to_raw","title":"to_raw  <code>classmethod</code>","text":"<pre><code>to_raw(value: Number, units: Unit) -&gt; Number\n</code></pre> <p>Convert a value in specified units to the raw unit.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Number</code> <p>Numeric value to convert.</p> required <code>units</code> <code>Unit</code> <p>Unit type of the input value.</p> required <p>Returns:</p> Type Description <code>Number</code> <p>Value converted to the dimension's raw unit.</p> Note <p>Used internally for storing values in consistent raw units.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef to_raw(cls, value: Number, units: Unit) -&gt; Number:\n    \"\"\"Convert a value in specified units to the raw unit.\n\n    Args:\n        value: Numeric value to convert.\n        units: Unit type of the input value.\n\n    Returns:\n        Value converted to the dimension's raw unit.\n\n    Note:\n        Used internally for storing values in consistent raw units.\n    \"\"\"\n    cls._validate_unit_type(units)\n    return value * cls._get_conversion_factor(units)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.convert","title":"convert","text":"<pre><code>convert(units: Unit) -&gt; Self\n</code></pre> <p>Convert this measurement to different units within the same dimension.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Unit</code> <p>Target unit type for conversion.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New instance of the same dimension type with value in target units.</p> <p>Raises:</p> Type Description <code>UnitConversionError</code> <p>If target units are incompatible with this dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance = Distance.Meter(100)\n&gt;&gt;&gt; print(f\"100m = {distance.convert(Distance.Yard)}\")\n100m = 109.4yd\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def convert(self, units: Unit) -&gt; Self:\n    \"\"\"Convert this measurement to different units within the same dimension.\n\n    Args:\n        units: Target unit type for conversion.\n\n    Returns:\n        New instance of the same dimension type with value in target units.\n\n    Raises:\n        UnitConversionError: If target units are incompatible with this dimension.\n\n    Examples:\n        &gt;&gt;&gt; distance = Distance.Meter(100)\n        &gt;&gt;&gt; print(f\"100m = {distance.convert(Distance.Yard)}\")\n        100m = 109.4yd\n    \"\"\"\n    return self.__class__.new_from_raw(self._value, units)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.get_in","title":"get_in","text":"<pre><code>get_in(units: Unit) -&gt; Number\n</code></pre> <p>Get the numeric value of this measurement in specified units.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Unit</code> <p>Target unit type for the value.</p> required <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value in the specified units (float or int).</p> <p>Raises:</p> Type Description <code>UnitConversionError</code> <p>If target units are incompatible with this dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance = Distance.Meter(100)\n&gt;&gt;&gt; print(f\"100m = {distance.get_in(Distance.Yard):.5f} yards\")\n100m = 109.36133 yards\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def get_in(self, units: Unit) -&gt; Number:\n    \"\"\"Get the numeric value of this measurement in specified units.\n\n    Args:\n        units: Target unit type for the value.\n\n    Returns:\n        Numeric value in the specified units (float or int).\n\n    Raises:\n        UnitConversionError: If target units are incompatible with this dimension.\n\n    Examples:\n        &gt;&gt;&gt; distance = Distance.Meter(100)\n        &gt;&gt;&gt; print(f\"100m = {distance.get_in(Distance.Yard):.5f} yards\")\n        100m = 109.36133 yards\n    \"\"\"\n    return self.__class__.from_raw(self._value, units)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.units","title":"units  <code>property</code>","text":"<pre><code>units: Unit\n</code></pre> <p>Get the unit type this dimension instance was defined with.</p> <p>Returns:</p> Type Description <code>Unit</code> <p>Unit enum representing the unit type of this measurement.</p>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.unit_value","title":"unit_value  <code>property</code>","text":"<pre><code>unit_value: Number\n</code></pre> <p>Get the numeric value in the defined units.</p> <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value in the units this measurement was created with.</p> Note <p>Equivalent to get_in(self.units) but more efficient as a property.</p>"},{"location":"api/unit/#py_ballisticcalc.unit.GenericDimension.raw_value","title":"raw_value  <code>property</code>","text":"<pre><code>raw_value: Number\n</code></pre> <p>Get the internal raw value used for calculations.</p> <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value in the dimension's raw unit (e.g., inches for Distance).</p>"},{"location":"api/unit/#py_ballisticcalc.unit.Angular","title":"Angular","text":"<pre><code>Angular(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Angular measurements.  Raw value is radians.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Angular.to_raw","title":"to_raw  <code>classmethod</code>","text":"<pre><code>to_raw(value: Number, units: Unit) -&gt; Number\n</code></pre> <p>Normalize angle to (-\u03c0, \u03c0].</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@override\n@classmethod\ndef to_raw(cls, value: Number, units: Unit) -&gt; Number:\n    \"\"\"Normalize angle to (-\u03c0, \u03c0].\"\"\"\n    radians = super().to_raw(value, units)\n    # Normalize to [-\u03c0, \u03c0)\n    r = (radians + pi) % (2.0 * pi) - pi\n    return r if r &gt; -pi else pi  # move -\u03c0 to +\u03c0\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Energy","title":"Energy","text":"<pre><code>Energy(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Energy measurements.  Raw unit is foot-pounds.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Distance","title":"Distance","text":"<pre><code>Distance(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Distance measurements.  Raw value is inches.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Pressure","title":"Pressure","text":"<pre><code>Pressure(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Pressure unit.  Raw value is mmHg.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Temperature","title":"Temperature","text":"<pre><code>Temperature(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Temperature unit.  Raw value is Fahrenheit.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Temperature.new_from_raw","title":"new_from_raw  <code>classmethod</code>","text":"<pre><code>new_from_raw(\n    raw_value: float, to_units: Unit\n) -&gt; Temperature\n</code></pre> <p>Create Temperature from raw Fahrenheit value into target units.</p> <p>Unlike other dimensions, Temperature uses affine conversions; this method     relies on <code>from_raw</code> instead of dividing by a scale factor.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@override\n@classmethod\ndef new_from_raw(cls, raw_value: float, to_units: Unit) -&gt; Temperature:\n    \"\"\"Create Temperature from raw Fahrenheit value into target units.\n\n    Unlike other dimensions, Temperature uses affine conversions; this method\n        relies on `from_raw` instead of dividing by a scale factor.\n    \"\"\"\n    # Temperature conversion uses affine transforms; do not divide by a factor.\n    value_in_units = cls.from_raw(raw_value, to_units)\n    return cls(value_in_units, to_units)\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Time","title":"Time","text":"<pre><code>Time(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Time measurements.  Raw unit is seconds.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Velocity","title":"Velocity","text":"<pre><code>Velocity(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Velocity measurements.  Raw unit is meters per second.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.Weight","title":"Weight","text":"<pre><code>Weight(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Weight unit.  Raw value is grains.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.PreferredUnits","title":"PreferredUnits  <code>dataclass</code>","text":"<pre><code>PreferredUnits(\n    angular: Unit = Degree,\n    distance: Unit = Yard,\n    velocity: Unit = FPS,\n    pressure: Unit = InHg,\n    temperature: Unit = Fahrenheit,\n    diameter: Unit = Inch,\n    length: Unit = Inch,\n    weight: Unit = Grain,\n    adjustment: Unit = Mil,\n    drop: Unit = Inch,\n    energy: Unit = FootPound,\n    ogw: Unit = Pound,\n    sight_height: Unit = Inch,\n    target_height: Unit = Inch,\n    twist: Unit = Inch,\n    time: Unit = Second,\n)\n</code></pre> <p>Configuration class for default units used throughout ballistic calculations.</p> <p>This class defines the default units that will be used when creating measurements without explicitly specifying units, and for displaying results in user interfaces. It provides a centralized way to configure unit preferences for an entire ballistic calculation session. This allows users to set their preferred unit system once and have it apply to all subsequent calculations.</p> Default Configuration <ul> <li>angular: Degree (for look-angle and barrel elevation)</li> <li>distance: Yard (traditional ballistic range unit)</li> <li>velocity: FPS (feet per second)</li> <li>pressure: InHg (inches of mercury, for barometric pressure)</li> <li>temperature: Fahrenheit</li> <li>diameter: Inch (bullet and bore diameter)</li> <li>length: Inch (bullet length, barrel length)</li> <li>weight: Grain (bullet weight, powder charge)</li> <li>adjustment: Mil (scope adjustment increments)</li> <li>drop: Inch (trajectory vertical measurements)</li> <li>energy: FootPound (kinetic energy)</li> <li>ogw: Pound (optimal game weight)</li> <li>sight_height: Inch (scope height above bore)</li> <li>target_height: Inch (target dimensions)</li> <li>twist: Inch (barrel twist rate)</li> <li>time: Second (flight time)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set metric preferences\n&gt;&gt;&gt; PreferredUnits.distance = Unit.Meter\n&gt;&gt;&gt; PreferredUnits.velocity = Unit.MPS\n</code></pre> <pre><code>&gt;&gt;&gt; # Reset to defaults\n&gt;&gt;&gt; PreferredUnits.restore_defaults()\n</code></pre> <pre><code>&gt;&gt;&gt; # Bulk configuration\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance='meter',\n...     velocity='mps',\n...     temperature='celsius'\n... )\n</code></pre> Note <p>Changing preferred units affects all subsequent unit creation and display.</p>"},{"location":"api/unit/#py_ballisticcalc.unit.PreferredUnits.restore_defaults","title":"restore_defaults  <code>classmethod</code>","text":"<pre><code>restore_defaults()\n</code></pre> <p>Reset all preferred units to their default values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Changing default distance units:\n&gt;&gt;&gt; PreferredUnits.distance = Unit.Meter\n&gt;&gt;&gt; # Reset to defaults\n&gt;&gt;&gt; PreferredUnits.restore_defaults()\n&gt;&gt;&gt; PreferredUnits.distance\nyard\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef restore_defaults(cls):\n    \"\"\"Reset all preferred units to their default values.\n\n    Examples:\n        &gt;&gt;&gt; # Changing default distance units:\n        &gt;&gt;&gt; PreferredUnits.distance = Unit.Meter\n        &gt;&gt;&gt; # Reset to defaults\n        &gt;&gt;&gt; PreferredUnits.restore_defaults()\n        &gt;&gt;&gt; PreferredUnits.distance\n        yard\n    \"\"\"\n    for f in fields(cls):\n        if f.default is not MISSING:\n            setattr(cls, f.name, f.default)\n        elif getattr(f, \"default_factory\", MISSING) is not MISSING:\n            setattr(cls, f.name, f.default_factory())  # type: ignore\n</code></pre>"},{"location":"api/unit/#py_ballisticcalc.unit.PreferredUnits.set","title":"set  <code>classmethod</code>","text":"<pre><code>set(**kwargs: Union[Unit, str, bool])\n</code></pre> <p>Set preferred units from keyword arguments.</p> <p>Allows bulk configuration of preferred units using either Unit enum values or string aliases. Invalid attributes or values are logged as warnings but do not raise exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Union[Unit, str, bool]</code> <p>Keyword arguments where keys are attribute names and values       are either Unit enum values or (string) UnitAliases.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set using Unit enums\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance=Unit.Meter,\n...     velocity=Unit.MPS,\n...     temperature=Unit.Celsius\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Set using string aliases\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance='meter',\n...     velocity='mps',\n...     weight='gram'\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Mixed types\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance=Unit.Yard,\n...     velocity='fps',\n...     adjustment='mil'\n... )\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef set(cls, **kwargs: Union[Unit, str, bool]):\n    \"\"\"Set preferred units from keyword arguments.\n\n    Allows bulk configuration of preferred units using either Unit enum values or string aliases.\n    Invalid attributes or values are logged as warnings but do not raise exceptions.\n\n    Args:\n        **kwargs: Keyword arguments where keys are attribute names and values\n                  are either Unit enum values or (string) UnitAliases.\n\n    Examples:\n        &gt;&gt;&gt; # Set using Unit enums\n        &gt;&gt;&gt; PreferredUnits.set(\n        ...     distance=Unit.Meter,\n        ...     velocity=Unit.MPS,\n        ...     temperature=Unit.Celsius\n        ... )\n\n        &gt;&gt;&gt; # Set using string aliases\n        &gt;&gt;&gt; PreferredUnits.set(\n        ...     distance='meter',\n        ...     velocity='mps',\n        ...     weight='gram'\n        ... )\n\n        &gt;&gt;&gt; # Mixed types\n        &gt;&gt;&gt; PreferredUnits.set(\n        ...     distance=Unit.Yard,\n        ...     velocity='fps',\n        ...     adjustment='mil'\n        ... )\n    \"\"\"\n    for attribute, value in kwargs.items():\n        if hasattr(PreferredUnits, attribute):\n            if isinstance(value, Unit):\n                setattr(PreferredUnits, attribute, value)\n            elif isinstance(value, str):\n                if _unit := _parse_unit(value):\n                    setattr(PreferredUnits, attribute, _unit)\n                else:\n                    logger.warning(f\"{value=} not a member of Unit\")\n            elif isinstance(value, bool):\n                setattr(PreferredUnits, attribute, value)\n            else:\n                logger.warning(f\"type of {value=} have not been converted to a member of Unit\")\n        else:\n            logger.warning(f\"{attribute=} not found in preferred_units\")\n</code></pre>"},{"location":"api/vector/","title":"Vector","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Immutable 3D vector for ballistic trajectory calculations.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Distance/horizontal component (positive = downrange direction).</p> <code>y</code> <code>float</code> <p>Vertical component (positive = upward direction).</p> <code>z</code> <code>float</code> <p>Horizontal component (positive = right lateral direction).</p> <p>Examples:</p> <p>Basic vector creation and operations:</p> <pre><code># Create position vector (100m downrange, 10m high)\nposition = Vector(100.0, 10.0, 0.0)\n\n# Create velocity vector (800 m/s muzzle velocity)\nvelocity = Vector(800.0, 0.0, 0.0)\n\n# Vector arithmetic\nnew_pos = position + velocity * 0.1  # Position after 0.1 seconds\n\n# Calculate magnitude\nspeed = velocity.magnitude()  # 800.0 m/s\n\n# Create unit vector for direction\ndirection = velocity.normalize()  # Vector(1.0, 0.0, 0.0)\n\n# Wind vector (5 m/s crosswind from left)\nwind = Vector(0.0, 0.0, 5.0)\n\n# Calculate wind effect angle\ncos_angle = velocity.mul_by_vector(wind) / (velocity.magnitude() * wind.magnitude())\n\n# Gravity vector\ngravity = Vector(0.0, -9.81, 0.0)  # m/s\u00b2\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y: float\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z: float\n</code></pre>"},{"location":"api/conditions/atmo/","title":"Atmo","text":"<p>Atmo </p> <p>Atmospheric conditions and density calculations</p> Properties <p>altitude: Altitude relative to sea level pressure: Unadjusted barometric pressure, a.k.a. station pressure temperature: Temperature humidity: Relative humidity [0% to 100%] powder_temp: Temperature of powder (if different from atmosphere).     (Used when Ammo.use_powder_sensitivity is True) density_ratio: Ratio of current density to standard atmospheric density mach: Velocity of sound (Mach 1) for current atmosphere</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Optional[Union[float, Distance]]</code> <p>Altitude relative to sea level</p> <code>None</code> <code>pressure</code> <code>Optional[Union[float, Pressure]]</code> <p>Atmospheric pressure</p> <code>None</code> <code>temperature</code> <code>Optional[Union[float, Temperature]]</code> <p>Atmospheric temperature</p> <code>None</code> <code>humidity</code> <code>float</code> <p>Atmospheric relative humidity [0% to 100%]</p> <code>0.0</code> <code>powder_t</code> <code>Optional[Union[float, Temperature]]</code> <p>Custom temperature of powder different to atmospheric. Used when Ammo.use_powder_sensitivity is True</p> <code>None</code> Example <pre><code>from py_ballisticcalc import Atmo\natmo = Atmo(\n    altitude=Unit.Meter(100),\n    pressure=Unit.hPa(1000),\n    temperature=Unit.Celsius(20),\n    humidity=50,\n    powder_t=Unit.Celsius(15)\n)\n</code></pre> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(self,\n             altitude: Optional[Union[float, Distance]] = None,\n             pressure: Optional[Union[float, Pressure]] = None,\n             temperature: Optional[Union[float, Temperature]] = None,\n             humidity: float = 0.0,\n             powder_t: Optional[Union[float, Temperature]] = None):\n    \"\"\"\n    Create a new Atmo instance with given parameters\n\n    Args:\n        altitude: Altitude relative to sea level\n        pressure: Atmospheric pressure\n        temperature: Atmospheric temperature\n        humidity: Atmospheric relative humidity [0% to 100%]\n        powder_t: Custom temperature of powder different to atmospheric.\n            Used when Ammo.use_powder_sensitivity is True\n\n    Example:\n        ```python\n        from py_ballisticcalc import Atmo\n        atmo = Atmo(\n            altitude=Unit.Meter(100),\n            pressure=Unit.hPa(1000),\n            temperature=Unit.Celsius(20),\n            humidity=50,\n            powder_t=Unit.Celsius(15)\n        )\n        ```\n    \"\"\"\n    self._initializing = True\n    self._altitude = PreferredUnits.distance(altitude or 0)\n    self._pressure = PreferredUnits.pressure(pressure or Atmo.standard_pressure(self.altitude))\n    self._temperature = PreferredUnits.temperature(temperature or Atmo.standard_temperature(self.altitude))\n    # If powder_temperature not provided we use atmospheric temperature:\n    self._powder_temp = PreferredUnits.temperature(powder_t or self.temperature)\n    self._t0 = self.temperature &gt;&gt; Temperature.Celsius\n    self._p0 = self.pressure &gt;&gt; Pressure.hPa\n    self._a0 = self.altitude &gt;&gt; Distance.Foot\n    self._mach = Atmo.machF(self._temperature &gt;&gt; Temperature.Fahrenheit)\n    self.humidity = humidity\n    self._initializing = False\n    self.update_density_ratio()\n</code></pre> <p>Vacuum </p> <p>               Bases: <code>Atmo</code></p> <p>Vacuum atmosphere has zero drag</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(self,\n             altitude: Optional[Union[float, Distance]] = None,\n             temperature: Optional[Union[float, Temperature]] = None):\n    super().__init__(altitude, 0, temperature, 0)\n    self._pressure = PreferredUnits.pressure(0)\n    self._density_ratio = 0\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.altitude","title":"altitude  <code>property</code>","text":"<pre><code>altitude: Distance\n</code></pre> <p>Altitude relative to sea level</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.pressure","title":"pressure  <code>property</code>","text":"<pre><code>pressure: Pressure\n</code></pre> <p>Unadjusted barometric pressure, a.k.a. station pressure</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: Temperature\n</code></pre> <p>Local air temperature</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.humidity","title":"humidity  <code>property</code> <code>writable</code>","text":"<pre><code>humidity: float\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>Relative humidity [0% to 100%]</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.powder_temp","title":"powder_temp  <code>property</code>","text":"<pre><code>powder_temp: Temperature\n</code></pre> <p>Powder temperature</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_ratio","title":"density_ratio  <code>property</code>","text":"<pre><code>density_ratio: float\n</code></pre> <p>Ratio of current density to standard atmospheric density</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.mach","title":"mach  <code>property</code>","text":"<pre><code>mach: Velocity\n</code></pre> <p>Velocity of sound (Mach 1) for current atmosphere</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_metric","title":"density_metric  <code>property</code>","text":"<pre><code>density_metric: float\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>density in kg/m^3</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_imperial","title":"density_imperial  <code>property</code>","text":"<pre><code>density_imperial: float\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>density in lb/ft^3</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.temperature_at_altitude","title":"temperature_at_altitude","text":"<pre><code>temperature_at_altitude(altitude: float) -&gt; float\n</code></pre> <p>Temperature at altitude interpolated from zero conditions using lapse rate.</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>ASL in ft</p> required <p>Returns:</p> Type Description <code>float</code> <p>temperature in \u00b0C</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def temperature_at_altitude(self, altitude: float) -&gt; float:\n    \"\"\"Temperature at altitude interpolated from zero conditions using lapse rate.\n\n    Args:\n        altitude: ASL in ft\n\n    Returns:\n        temperature in \u00b0C\n    \"\"\"\n    t = (altitude - self._a0) * cLapseRateKperFoot + self._t0\n    if t &lt; Atmo.cLowestTempC:\n        t = Atmo.cLowestTempC\n        warnings.warn(f\"Temperature interpolated from altitude fell below minimum temperature limit.  \"\n                      f\"Model not accurate here.  Temperature bounded at cLowestTempF: {cLowestTempF}\u00b0F.\",\n                      RuntimeWarning)\n    return t\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.update_density_ratio","title":"update_density_ratio","text":"<pre><code>update_density_ratio() -&gt; None\n</code></pre> <p>Updates the density ratio based on current conditions.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def update_density_ratio(self) -&gt; None:\n    \"\"\"Updates the density ratio based on current conditions.\"\"\"\n    self._density_ratio = Atmo.calculate_air_density(self._t0, self._p0, self.humidity) / cStandardDensityMetric\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.pressure_at_altitude","title":"pressure_at_altitude","text":"<pre><code>pressure_at_altitude(altitude: float) -&gt; float\n</code></pre> <p>Pressure at altitude interpolated from zero conditions using lapse rate.</p> <p>Ref: https://en.wikipedia.org/wiki/Barometric_formula#Pressure_equations</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>ASL in ft</p> required <p>Returns:</p> Type Description <code>float</code> <p>pressure in hPa</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def pressure_at_altitude(self, altitude: float) -&gt; float:\n    \"\"\"Pressure at altitude interpolated from zero conditions using lapse rate.\n\n    Ref: https://en.wikipedia.org/wiki/Barometric_formula#Pressure_equations\n\n    Args:\n        altitude: ASL in ft\n\n    Returns:\n        pressure in hPa\n    \"\"\"\n    p = self._p0 * math.pow(1 + cLapseRateKperFoot * (altitude - self._a0) / (self._t0 + cDegreesCtoK),\n                            cPressureExponent)\n    return p\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.get_density_and_mach_for_altitude","title":"get_density_and_mach_for_altitude","text":"<pre><code>get_density_and_mach_for_altitude(\n    altitude: float,\n) -&gt; Tuple[float, float]\n</code></pre> <p>Calculate density ratio and Mach 1 for the specified altitude.</p> <p>Ref: https://en.wikipedia.org/wiki/Barometric_formula#Density_equations</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>ASL in units of feet. Note: Altitude above 36,000 ft not modelled this way.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>density ratio and Mach 1 (fps) for the specified altitude</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def get_density_and_mach_for_altitude(self, altitude: float) -&gt; Tuple[float, float]:\n    \"\"\"Calculate density ratio and Mach 1 for the specified altitude.\n\n    Ref: https://en.wikipedia.org/wiki/Barometric_formula#Density_equations\n\n    Args:\n        altitude: ASL in units of feet.\n            Note: Altitude above 36,000 ft not modelled this way.\n\n    Returns:\n        density ratio and Mach 1 (fps) for the specified altitude\n    \"\"\"\n    # Within 30 ft of initial altitude use initial values to save compute\n    if math.fabs(self._a0 - altitude) &lt; 30:\n        mach = self._mach\n        density_ratio = self._density_ratio\n    else:\n        if altitude &gt; 36089:\n            warnings.warn(\"Density request for altitude above troposphere.\"\n                          \" Atmospheric model not valid here.\", RuntimeWarning)\n        t = self.temperature_at_altitude(altitude) + cDegreesCtoK\n        mach = Velocity.MPS(Atmo.machK(t)) &gt;&gt; Velocity.FPS\n        p = self.pressure_at_altitude(altitude)\n        density_delta = ((self._t0 + cDegreesCtoK) * p) / (self._p0 * t)\n        density_ratio = self._density_ratio * density_delta\n        # # Alternative simplified model:\n        # # Ref https://en.wikipedia.org/wiki/Density_of_air#Exponential_approximation\n        # # see doc/'Air Density Models.svg' for comparison\n        # density_ratio = self._density_ratio * math.exp(-(altitude - self._a0) / 34122)\n    return density_ratio, mach\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard_temperature","title":"standard_temperature  <code>staticmethod</code>","text":"<pre><code>standard_temperature(altitude: Distance) -&gt; Temperature\n</code></pre> <p>Calculate ICAO standard temperature for altitude.</p> <p>Note: This model only valid up to troposphere (~36,000 ft).</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Distance</code> <p>ASL in units of feet.</p> required <p>Returns:</p> Type Description <code>Temperature</code> <p>ICAO standard temperature for altitude</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef standard_temperature(altitude: Distance) -&gt; Temperature:\n    \"\"\"Calculate ICAO standard temperature for altitude.\n\n    Note: This model only valid up to troposphere (~36,000 ft).\n\n    Args:\n        altitude: ASL in units of feet.\n\n    Returns:\n        ICAO standard temperature for altitude\n    \"\"\"\n    return Temperature.Fahrenheit(cStandardTemperatureF\n                                  + (altitude &gt;&gt; Distance.Foot) * cLapseRateImperial)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard_pressure","title":"standard_pressure  <code>staticmethod</code>","text":"<pre><code>standard_pressure(altitude: Distance) -&gt; Pressure\n</code></pre> <p>Calculate ICAO standard pressure for altitude.</p> <p>Note: This model only valid up to troposphere (~36,000 ft). Ref: https://en.wikipedia.org/wiki/Barometric_formula#Pressure_equations</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Distance</code> <p>Distance above sea level (ASL)</p> required <p>Returns:</p> Type Description <code>Pressure</code> <p>ICAO standard pressure for altitude</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef standard_pressure(altitude: Distance) -&gt; Pressure:\n    \"\"\"Calculate ICAO standard pressure for altitude.\n\n    Note: This model only valid up to troposphere (~36,000 ft).\n    Ref: https://en.wikipedia.org/wiki/Barometric_formula#Pressure_equations\n\n    Args:\n        altitude: Distance above sea level (ASL)\n\n    Returns:\n        ICAO standard pressure for altitude\n    \"\"\"\n    return Pressure.hPa(cStandardPressureMetric\n                        * math.pow(1 + cLapseRateMetric * (altitude &gt;&gt; Distance.Meter) /\n                                       (cStandardTemperatureC + cDegreesCtoK),\n                                   cPressureExponent))\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.icao","title":"icao  <code>staticmethod</code>","text":"<pre><code>icao(\n    altitude: Union[float, Distance] = 0,\n    temperature: Optional[Temperature] = None,\n    humidity: float = cStandardHumidity,\n) -&gt; Atmo\n</code></pre> <p>Create Atmo instance of standard ICAO atmosphere at given altitude.</p> <p>Note: This model only valid up to troposphere (~36,000 ft).</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Union[float, Distance]</code> <p>relative to sea level</p> <code>0</code> <code>temperature</code> <code>Optional[Temperature]</code> <p>air temperature</p> <code>None</code> <p>Returns:</p> Type Description <code>Atmo</code> <p>Atmo instance of standard ICAO atmosphere at given altitude.</p> <code>Atmo</code> <p>If temperature not specified uses standard temperature.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef icao(altitude: Union[float, Distance] = 0, temperature: Optional[Temperature] = None,\n         humidity: float = cStandardHumidity) -&gt; Atmo:\n    \"\"\"Create Atmo instance of standard ICAO atmosphere at given altitude.\n\n    Note: This model only valid up to troposphere (~36,000 ft).\n\n    Args:\n        altitude: relative to sea level\n        temperature: air temperature\n\n    Returns:\n        Atmo instance of standard ICAO atmosphere at given altitude.\n        If temperature not specified uses standard temperature.\n    \"\"\"\n    altitude = PreferredUnits.distance(altitude)\n    if temperature is None:\n        temperature = Atmo.standard_temperature(altitude)\n    pressure = Atmo.standard_pressure(altitude)\n\n    return Atmo(altitude, pressure, temperature, humidity)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machF","title":"machF  <code>staticmethod</code>","text":"<pre><code>machF(fahrenheit: float) -&gt; float\n</code></pre> <p>Calculate Mach 1 in fps for given Fahrenheit temperature.</p> <p>Parameters:</p> Name Type Description Default <code>fahrenheit</code> <code>float</code> <p>Fahrenheit temperature</p> required <p>Returns:</p> Type Description <code>float</code> <p>Mach 1 in fps for given temperature</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef machF(fahrenheit: float) -&gt; float:\n    \"\"\"Calculate Mach 1 in fps for given Fahrenheit temperature.\n\n    Args:\n        fahrenheit: Fahrenheit temperature\n\n    Returns:\n        Mach 1 in fps for given temperature\n    \"\"\"\n    if fahrenheit &lt; -cDegreesFtoR:\n        bad_temp = fahrenheit\n        fahrenheit = cLowestTempF\n        warnings.warn(f\"Invalid temperature: {bad_temp}\u00b0F. Adjusted to ({cLowestTempF}\u00b0F).\", RuntimeWarning)\n    return math.sqrt(fahrenheit + cDegreesFtoR) * cSpeedOfSoundImperial\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machC","title":"machC  <code>staticmethod</code>","text":"<pre><code>machC(celsius: float) -&gt; float\n</code></pre> <p>Calculate Mach 1 in mps for given Celsius temperature.</p> <p>Parameters:</p> Name Type Description Default <code>celsius</code> <code>float</code> <p>Celsius temperature</p> required <p>Returns:</p> Type Description <code>float</code> <p>Mach 1 in mps for given temperature</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef machC(celsius: float) -&gt; float:\n    \"\"\"Calculate Mach 1 in mps for given Celsius temperature.\n\n    Args:\n        celsius: Celsius temperature\n\n    Returns:\n        Mach 1 in mps for given temperature\n    \"\"\"\n    if celsius &lt; -cDegreesCtoK:\n        bad_temp = celsius\n        celsius = Atmo.cLowestTempC\n        warnings.warn(f\"Invalid temperature: {bad_temp}\u00b0C. Adjusted to ({celsius}\u00b0C).\", RuntimeWarning)\n    return Atmo.machK(celsius + cDegreesCtoK)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machK","title":"machK  <code>staticmethod</code>","text":"<pre><code>machK(kelvin: float) -&gt; float\n</code></pre> <p>Calculate Mach 1 in mps for given Kelvin temperature.</p> <p>Parameters:</p> Name Type Description Default <code>kelvin</code> <code>float</code> <p>Kelvin temperature</p> required <p>Returns:</p> Type Description <code>float</code> <p>Mach 1 in mps for given temperature</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef machK(kelvin: float) -&gt; float:\n    \"\"\"Calculate Mach 1 in mps for given Kelvin temperature.\n\n    Args:\n        kelvin: Kelvin temperature\n\n    Returns:\n        Mach 1 in mps for given temperature\n    \"\"\"\n    return math.sqrt(kelvin) * cSpeedOfSoundMetric\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.calculate_air_density","title":"calculate_air_density  <code>staticmethod</code>","text":"<pre><code>calculate_air_density(\n    t: float, p_hpa: float, humidity: float\n) -&gt; float\n</code></pre> <p>Calculate air density from temperature, pressure, and humidity.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Temperature in degrees Celsius.</p> required <code>p_hpa</code> <code>float</code> <p>Pressure in hPa (hectopascals). Internally converted to Pa.</p> required <code>humidity</code> <code>float</code> <p>Relative humidity. Accepts either fraction [0..1] or percent [0..100].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Air density in kg/m\u00b3.</p> Notes <ul> <li>Divide result by cDensityImperialToMetric to get density in lb/ft\u00b3</li> <li>Source: https://www.nist.gov/system/files/documents/calibrations/CIPM-2007.pdf</li> </ul> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef calculate_air_density(t: float, p_hpa: float, humidity: float) -&gt; float:\n    \"\"\"Calculate air density from temperature, pressure, and humidity.\n\n    Args:\n        t: Temperature in degrees Celsius.\n        p_hpa: Pressure in hPa (hectopascals). Internally converted to Pa.\n        humidity: Relative humidity. Accepts either fraction [0..1] or percent [0..100].\n\n    Returns:\n        Air density in kg/m\u00b3.\n\n    Notes:\n        - Divide result by cDensityImperialToMetric to get density in lb/ft\u00b3\n        - Source: https://www.nist.gov/system/files/documents/calibrations/CIPM-2007.pdf\n    \"\"\"\n    R = 8.314472  # J/(mol\u00b7K), universal gas constant\n    M_a = 28.96546e-3  # kg/mol, molar mass of dry air\n    M_v = 18.01528e-3  # kg/mol, molar mass of water vapor\n\n    def saturation_vapor_pressure(T):\n        # Calculation of saturated vapor pressure according to CIPM 2007\n        A = [1.2378847e-5, -1.9121316e-2, 33.93711047, -6.3431645e3]\n        return math.exp(A[0] * T ** 2 + A[1] * T + A[2] + A[3] / T)\n\n    def enhancement_factor(p, T):\n        # Calculation of enhancement factor according to CIPM 2007\n        alpha = 1.00062\n        beta = 3.14e-8\n        gamma = 5.6e-7\n        return alpha + beta * p + gamma * T ** 2\n\n    def compressibility_factor(p, T, x_v):\n        # Calculation of compressibility factor according to CIPM 2007\n        a0 = 1.58123e-6\n        a1 = -2.9331e-8\n        a2 = 1.1043e-10\n        b0 = 5.707e-6\n        b1 = -2.051e-8\n        c0 = 1.9898e-4\n        c1 = -2.376e-6\n        d = 1.83e-11\n        e = -0.765e-8\n\n        t = T - cDegreesCtoK\n        Z = 1 - (p / T) * (a0 + a1 * t + a2 * t ** 2 + (b0 + b1 * t) * x_v + (c0 + c1 * t) * x_v ** 2) \\\n            + (p / T) ** 2 * (d + e * x_v ** 2)\n        return Z\n\n    # Normalize humidity to fraction [0..1]\n    rh = float(humidity)\n    rh_frac = rh / 100.0 if rh &gt; 1.0 else rh\n    rh_frac = max(0.0, min(1.0, rh_frac))\n\n    # Convert inputs for CIPM equations\n    T_K = t + cDegreesCtoK           # Kelvin\n    p = float(p_hpa) * 100.0         # hPa -&gt; Pa\n\n    # Calculation of saturated vapor pressure and enhancement factor\n    p_sv = saturation_vapor_pressure(T_K)  # Pa (saturated vapor pressure)\n    f = enhancement_factor(p, t)           # Enhancement factor (p in Pa, t in \u00b0C)\n\n    # Partial pressure of water vapor and mole fraction\n    p_v = rh_frac * f * p_sv               # Pa\n    x_v = p_v / p                          # Mole fraction of water vapor\n\n    # Calculation of compressibility factor\n    Z = compressibility_factor(p, T_K, x_v)\n\n    # Density (kg/m^3) using moist air composition and compressibility factor\n    density = (p * M_a) / (Z * R * T_K) * (1.0 - x_v * (1.0 - M_v / M_a))\n    return density\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Vacuum.update_density_ratio","title":"update_density_ratio","text":"<pre><code>update_density_ratio() -&gt; None\n</code></pre> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def update_density_ratio(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/conditions/shot/","title":"Shot","text":"<p>Shot </p> <p>A base class for creating Shot. Stores shot parameters for the trajectory calculation.</p> <p>Attributes:</p> Name Type Description <code>look_angle</code> <code>Angular</code> <p>Angle of sight line relative to horizontal. If the look_angle != 0 then any target in sight crosshairs will be at a different altitude:     With target_distance = sight distance to a target (i.e., as through a rangefinder):         * Horizontal distance X to target = cos(look_angle) * target_distance         * Vertical distance Y to target = sin(look_angle) * target_distance</p> <code>relative_angle</code> <code>Angular</code> <p>Elevation adjustment added to weapon.zero_elevation for a particular shot.</p> <code>cant_angle</code> <code>Angular</code> <p>Tilt of gun from vertical, which shifts any barrel elevation from the vertical plane into the horizontal plane by sine(cant_angle)</p> <code>ammo</code> <code>Ammo</code> <p>Ammo instance used for making shot</p> <code>weapon</code> <code>Weapon</code> <p>Weapon instance used for making shot</p> <code>atmo</code> <code>Atmo</code> <p>Atmo instance used for making shot</p> <p>Parameters:</p> Name Type Description Default <code>ammo</code> <code>Ammo</code> <p>Ammo instance used for making shot</p> required <code>weapon</code> <code>Optional[Weapon]</code> <p>Weapon instance used for making shot</p> <code>None</code> <code>look_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Angle of sight line relative to horizontal. If the look_angle != 0 then any target in sight crosshairs will be at a different altitude:     With target_distance = sight distance to a target (i.e., as through a rangefinder):         * Horizontal distance X to target = cos(look_angle) * target_distance         * Vertical distance Y to target = sin(look_angle) * target_distance</p> <code>None</code> <code>relative_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Elevation adjustment added to weapon.zero_elevation for a particular shot.</p> <code>None</code> <code>cant_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Tilt of gun from vertical, which shifts any barrel elevation from the vertical plane into the horizontal plane by sine(cant_angle)</p> <code>None</code> <code>atmo</code> <code>Optional[Atmo]</code> <p>Atmo instance used for making shot</p> <code>None</code> <code>winds</code> <code>Optional[Sequence[Wind]]</code> <p>list of winds used for making shot</p> <code>None</code> Example <p>This is how you can create a shot <pre><code>from py_ballisticcalc import Weapon, Ammo, Atmo, Wind\nshot = Shot(\n    ammo=Ammo(...),\n    weapon=Weapon(...),\n    look_angle=Unit.Degree(5),\n    relative_angle=Unit.Degree(0),\n    cant_angle=Unit.Degree(0),\n    atmo=Atmo(...),\n    winds=[Wind(...), ... ]\n)\n</code></pre></p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(self,\n             ammo: Ammo,\n             weapon: Optional[Weapon] = None,\n             look_angle: Optional[Union[float, Angular]] = None,\n             relative_angle: Optional[Union[float, Angular]] = None,\n             cant_angle: Optional[Union[float, Angular]] = None,\n             atmo: Optional[Atmo] = None,\n             winds: Optional[Sequence[Wind]] = None\n             ):\n    \"\"\"\n    A base class for creating Shot.\n    Stores shot parameters for the trajectory calculation.\n\n    Args:\n        ammo: Ammo instance used for making shot\n        weapon: Weapon instance used for making shot\n        look_angle: Angle of sight line relative to horizontal.\n            If the look_angle != 0 then any target in sight crosshairs will be at a different altitude:\n                With target_distance = sight distance to a target (i.e., as through a rangefinder):\n                    * Horizontal distance X to target = cos(look_angle) * target_distance\n                    * Vertical distance Y to target = sin(look_angle) * target_distance\n        relative_angle: Elevation adjustment added to weapon.zero_elevation for a particular shot.\n        cant_angle: Tilt of gun from vertical, which shifts any barrel elevation\n            from the vertical plane into the horizontal plane by sine(cant_angle)\n        atmo: Atmo instance used for making shot\n        winds: list of winds used for making shot\n\n    Example:\n        This is how you can create a shot\n        ```python\n        from py_ballisticcalc import Weapon, Ammo, Atmo, Wind\n        shot = Shot(\n            ammo=Ammo(...),\n            weapon=Weapon(...),\n            look_angle=Unit.Degree(5),\n            relative_angle=Unit.Degree(0),\n            cant_angle=Unit.Degree(0),\n            atmo=Atmo(...),\n            winds=[Wind(...), ... ]\n        )\n        ```\n    \"\"\"\n    self.ammo = ammo\n    self.weapon = weapon or Weapon()\n    self.look_angle = PreferredUnits.angular(look_angle or 0)\n    self.relative_angle = PreferredUnits.angular(relative_angle or 0)\n    self.cant_angle = PreferredUnits.angular(cant_angle or 0)\n    self.atmo = atmo or Atmo.icao()\n    self.winds = winds or [Wind()]\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.look_angle","title":"look_angle  <code>instance-attribute</code>","text":"<pre><code>look_angle: Angular = angular(look_angle or 0)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.relative_angle","title":"relative_angle  <code>instance-attribute</code>","text":"<pre><code>relative_angle: Angular = angular(relative_angle or 0)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.cant_angle","title":"cant_angle  <code>instance-attribute</code>","text":"<pre><code>cant_angle: Angular = angular(cant_angle or 0)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.weapon","title":"weapon  <code>instance-attribute</code>","text":"<pre><code>weapon: Weapon = weapon or Weapon()\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.ammo","title":"ammo  <code>instance-attribute</code>","text":"<pre><code>ammo: Ammo = ammo\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.atmo","title":"atmo  <code>instance-attribute</code>","text":"<pre><code>atmo: Atmo = atmo or icao()\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.winds","title":"winds  <code>property</code> <code>writable</code>","text":"<pre><code>winds: Sequence[Wind]\n</code></pre> <p>Returns:</p> Type Description <code>Sequence[Wind]</code> <p>Sequence[Wind] sorted by until_distance</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.barrel_elevation","title":"barrel_elevation  <code>property</code> <code>writable</code>","text":"<pre><code>barrel_elevation: Angular\n</code></pre> <p>Total barrel elevation (in vertical plane) from horizontal     = look_angle + cos(cant_angle) * zero_elevation + relative_angle</p> <p>Returns:</p> Type Description <code>Angular</code> <p>Angle of barrel elevation in vertical plane from horizontal</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.barrel_azimuth","title":"barrel_azimuth  <code>property</code>","text":"<pre><code>barrel_azimuth: Angular\n</code></pre> <p>Horizontal angle of barrel relative to sight line</p> <p>Returns:</p> Type Description <code>Angular</code> <p>Horizontal angle of barrel relative to sight line</p>"},{"location":"api/conditions/wind/","title":"Wind","text":"<p>Wind </p> <p>A base class for creating Wind. Wind direction and velocity by down-range distance.</p> <p>Attributes:</p> Name Type Description <code>velocity</code> <code>Velocity</code> <p>speed of wind</p> <code>direction_from</code> <code>Angular</code> <p>0 is blowing from behind shooter. 90 degrees is blowing from shooter's left towards right.</p> <code>until_distance</code> <code>Distance</code> <p>until which distance the specified wind blows</p> <code>MAX_DISTANCE_FEET</code> <code>float</code> <p>Optional custom max wind distance</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>Optional[Union[float, Velocity]]</code> <p>speed of wind</p> <code>None</code> <code>direction_from</code> <code>Optional[Union[float, Angular]]</code> <p>0 is blowing from behind shooter. 90 degrees is blowing from shooter's left towards right.</p> <code>None</code> <code>until_distance</code> <code>Optional[Union[float, Distance]]</code> <p>until which distance the specified wind blows</p> <code>None</code> <code>max_distance_feet</code> <code>Optional[float]</code> <p>Optional custom max wind distance</p> <code>cMaxWindDistanceFeet</code> Example <p>This is how you can create a wind <pre><code>from py_ballisticcalc import Wind\nwind = Wind(\n    velocity=Unit.FPS(2700),\n    direction_from=Unit.Degree(20)\n)\n</code></pre></p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(self,\n             velocity: Optional[Union[float, Velocity]] = None,\n             direction_from: Optional[Union[float, Angular]] = None,\n             until_distance: Optional[Union[float, Distance]] = None,\n             *,\n             max_distance_feet: Optional[float] = cMaxWindDistanceFeet):\n    \"\"\"\n    Create a new wind instance with given parameters\n\n    Args:\n        velocity: speed of wind\n        direction_from: 0 is blowing from behind shooter.\n            90 degrees is blowing from shooter's left towards right.\n        until_distance: until which distance the specified wind blows\n        max_distance_feet: Optional custom max wind distance\n\n    Example:\n        This is how you can create a wind\n        ```python\n        from py_ballisticcalc import Wind\n        wind = Wind(\n            velocity=Unit.FPS(2700),\n            direction_from=Unit.Degree(20)\n        )\n        ```\n    \"\"\"\n\n    self.MAX_DISTANCE_FEET = float(max_distance_feet or cMaxWindDistanceFeet)\n    self.velocity = PreferredUnits.velocity(velocity or 0)\n    self.direction_from = PreferredUnits.angular(direction_from or 0)\n    self.until_distance = PreferredUnits.distance(until_distance or Distance.Foot(self.MAX_DISTANCE_FEET))\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.velocity","title":"velocity  <code>instance-attribute</code>","text":"<pre><code>velocity: Velocity = velocity(velocity or 0)\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.direction_from","title":"direction_from  <code>instance-attribute</code>","text":"<pre><code>direction_from: Angular = angular(direction_from or 0)\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.until_distance","title":"until_distance  <code>instance-attribute</code>","text":"<pre><code>until_distance: Distance = distance(\n    until_distance or Foot(MAX_DISTANCE_FEET)\n)\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.MAX_DISTANCE_FEET","title":"MAX_DISTANCE_FEET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_DISTANCE_FEET: float = float(\n    max_distance_feet or cMaxWindDistanceFeet\n)\n</code></pre>"},{"location":"api/munition/ammo/","title":"Ammo","text":"<p>Ammunition configuration for ballistic calculations.</p> <p>This class represents the physical and ballistic properties of ammunition, including the drag model, muzzle velocity, and powder temperature sensitivity. It provides methods for calculating temperature-dependent velocity adjustments.</p> <p>Attributes:</p> Name Type Description <code>dm</code> <code>DragModel</code> <p>DragModel instance defining the projectile's ballistic coefficient and drag characteristics.</p> <code>mv</code> <code>Velocity</code> <p>Muzzle velocity at the baseline powder temperature.</p> <code>powder_temp</code> <code>Temperature</code> <p>Baseline temperature that produces the given muzzle velocity.</p> <code>temp_modifier</code> <code>float</code> <p>Change in velocity with temperature as a percentage per 15\u00b0C.           Can be computed using calc_powder_sens() method.</p> <code>use_powder_sensitivity</code> <code>bool</code> <p>Flag to enable automatic muzzle velocity adjustment                    based on powder temperature.</p> Note <p>When use_powder_sensitivity is True, the actual muzzle velocity will be automatically adjusted based on the difference between the current powder temperature and the baseline powder_temp using the temp_modifier.</p> Example <pre><code>ammo = Ammo(\n    dm=DragModel(0.381, TableG7, Unit.Grain(300), Unit.Inch(0.338)),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>DragModel</code> <p>DragModel instance defining projectile ballistic characteristics.</p> required <code>mv</code> <code>Union[float, Velocity]</code> <p>Muzzle velocity at the baseline powder temperature.</p> required <code>powder_temp</code> <code>Optional[Union[float, Temperature]]</code> <p>Baseline temperature that produces the given muzzle velocity.         If None, defaults to 15\u00b0C.</p> <code>None</code> <code>temp_modifier</code> <code>float</code> <p>Change in velocity with temperature as percentage per 15\u00b0C.           Can be computed with calc_powder_sens() method.           Only applies if use_powder_sensitivity is True.</p> <code>0</code> <code>use_powder_sensitivity</code> <code>bool</code> <p>If True, automatically adjust muzzle velocity                    based on powder temperature differences.</p> <code>False</code> Example <pre><code>from py_ballisticcalc import Ammo, DragModel, TableG7, Unit\n\n# Basic ammunition without temperature sensitivity\nammo = Ammo(dm=DragModel(0.381, TableG7), mv=Unit.MPS(815))\n\n# Advanced ammunition with powder temperature sensitivity\nammo = Ammo(\n    dm=DragModel(0.381, TableG7, Unit.Grain(300), Unit.Inch(0.338)),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True\n)\n# Calculate sensitivity from known data points\nammo.calc_powder_sens(Unit.MPS(830), Unit.Celsius(30))\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def __init__(self,\n             dm: DragModel,\n             mv: Union[float, Velocity],\n             powder_temp: Optional[Union[float, Temperature]] = None,\n             temp_modifier: float = 0,\n             use_powder_sensitivity: bool = False):\n    \"\"\"Initialize an Ammo instance with given parameters.\n\n    Args:\n        dm: DragModel instance defining projectile ballistic characteristics.\n        mv: Muzzle velocity at the baseline powder temperature.\n        powder_temp: Baseline temperature that produces the given muzzle velocity.\n                    If None, defaults to 15\u00b0C.\n        temp_modifier: Change in velocity with temperature as percentage per 15\u00b0C.\n                      Can be computed with calc_powder_sens() method.\n                      Only applies if use_powder_sensitivity is True.\n        use_powder_sensitivity: If True, automatically adjust muzzle velocity\n                               based on powder temperature differences.\n\n    Example:\n        ```python\n        from py_ballisticcalc import Ammo, DragModel, TableG7, Unit\n\n        # Basic ammunition without temperature sensitivity\n        ammo = Ammo(dm=DragModel(0.381, TableG7), mv=Unit.MPS(815))\n\n        # Advanced ammunition with powder temperature sensitivity\n        ammo = Ammo(\n            dm=DragModel(0.381, TableG7, Unit.Grain(300), Unit.Inch(0.338)),\n            mv=Unit.MPS(815),\n            powder_temp=Unit.Celsius(15),\n            temp_modifier=0.123,\n            use_powder_sensitivity=True\n        )\n        # Calculate sensitivity from known data points\n        ammo.calc_powder_sens(Unit.MPS(830), Unit.Celsius(30))\n        ```\n    \"\"\"\n    self.dm = dm\n    self.mv = PreferredUnits.velocity(mv or 0)\n    self.powder_temp = PreferredUnits.temperature(powder_temp or Temperature.Celsius(15))\n    self.temp_modifier = temp_modifier or 0\n    self.use_powder_sensitivity = use_powder_sensitivity\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.dm","title":"dm  <code>instance-attribute</code>","text":"<pre><code>dm: DragModel = dm\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.mv","title":"mv  <code>instance-attribute</code>","text":"<pre><code>mv: Velocity = velocity(mv or 0)\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.powder_temp","title":"powder_temp  <code>instance-attribute</code>","text":"<pre><code>powder_temp: Temperature = temperature(\n    powder_temp or Celsius(15)\n)\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.temp_modifier","title":"temp_modifier  <code>instance-attribute</code>","text":"<pre><code>temp_modifier: float = temp_modifier or 0\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.use_powder_sensitivity","title":"use_powder_sensitivity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>use_powder_sensitivity: bool = use_powder_sensitivity\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.calc_powder_sens","title":"calc_powder_sens","text":"<pre><code>calc_powder_sens(\n    other_velocity: Union[float, Velocity],\n    other_temperature: Union[float, Temperature],\n) -&gt; float\n</code></pre> <p>Calculate velocity temperature sensitivity and update temp_modifier.</p> <p>This method calculates the powder temperature sensitivity coefficient based on two known velocity/temperature data points and assigns the result to the temp_modifier attribute.</p> <p>Parameters:</p> Name Type Description Default <code>other_velocity</code> <code>Union[float, Velocity]</code> <p>Known velocity at other_temperature.</p> required <code>other_temperature</code> <code>Union[float, Temperature]</code> <p>Temperature corresponding to other_velocity.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature modifier in terms of percentage velocity change per 15\u00b0C.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If other_velocity and temperature are the same as baseline,        making calculation impossible.</p> Note <p>The calculation uses the formula: temp_modifier = (velocity_delta / temperature_delta) * (15 / lower_velocity)</p> <p>This provides a normalized sensitivity value representing the percentage change in velocity per 15\u00b0C temperature change.</p> Example <pre><code># Calculate sensitivity from known velocity drop in cold weather\nsensitivity = ammo.calc_powder_sens(\n    other_velocity=Unit.MPS(800),  # Velocity at cold temp\n    other_temperature=Unit.Celsius(0)  # Cold temperature\n)\nprint(f\"Powder sensitivity: {sensitivity:.4f}% per 15\u00b0C\")\n\n# The temp_modifier is now automatically set\nprint(f\"Current temp_modifier: {ammo.temp_modifier}\")\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def calc_powder_sens(self, other_velocity: Union[float, Velocity],\n                     other_temperature: Union[float, Temperature]) -&gt; float:\n    \"\"\"Calculate velocity temperature sensitivity and update temp_modifier.\n\n    This method calculates the powder temperature sensitivity coefficient\n    based on two known velocity/temperature data points and assigns the\n    result to the temp_modifier attribute.\n\n    Args:\n        other_velocity: Known velocity at other_temperature.\n        other_temperature: Temperature corresponding to other_velocity.\n\n    Returns:\n        Temperature modifier in terms of percentage velocity change per 15\u00b0C.\n\n    Raises:\n        ValueError: If other_velocity and temperature are the same as baseline,\n                   making calculation impossible.\n\n    Note:\n        The calculation uses the formula:\n        temp_modifier = (velocity_delta / temperature_delta) * (15 / lower_velocity)\n\n        This provides a normalized sensitivity value representing the percentage\n        change in velocity per 15\u00b0C temperature change.\n\n    Example:\n        ```python\n        # Calculate sensitivity from known velocity drop in cold weather\n        sensitivity = ammo.calc_powder_sens(\n            other_velocity=Unit.MPS(800),  # Velocity at cold temp\n            other_temperature=Unit.Celsius(0)  # Cold temperature\n        )\n        print(f\"Powder sensitivity: {sensitivity:.4f}% per 15\u00b0C\")\n\n        # The temp_modifier is now automatically set\n        print(f\"Current temp_modifier: {ammo.temp_modifier}\")\n        ```\n    \"\"\"\n    v0 = self.mv &gt;&gt; Velocity.MPS\n    t0 = self.powder_temp &gt;&gt; Temperature.Celsius\n    v1 = PreferredUnits.velocity(other_velocity) &gt;&gt; Velocity.MPS\n    t1 = PreferredUnits.temperature(other_temperature) &gt;&gt; Temperature.Celsius\n\n    if v0 &lt;= 0 or v1 &lt;= 0:\n        raise ValueError(\"calc_powder_sens requires positive muzzle velocities\")\n    v_delta = math.fabs(v0 - v1)\n    t_delta = math.fabs(t0 - t1)\n    v_lower = v1 if v1 &lt; v0 else v0\n\n    if v_delta == 0 or t_delta == 0:\n        raise ValueError(\"other_velocity and temperature can't be same as default\")\n    self.temp_modifier = v_delta / t_delta * (15 / v_lower)  # * 100\n    return self.temp_modifier\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.get_velocity_for_temp","title":"get_velocity_for_temp","text":"<pre><code>get_velocity_for_temp(\n    current_temp: Union[float, Temperature],\n) -&gt; Velocity\n</code></pre> <p>Calculate muzzle velocity adjusted for powder temperature.</p> <p>This method calculates the muzzle velocity at a given temperature based on the baseline velocity, powder temperature, and temperature sensitivity modifier. If powder sensitivity is disabled, returns the baseline velocity.</p> <p>Parameters:</p> Name Type Description Default <code>current_temp</code> <code>Union[float, Temperature]</code> <p>Temperature of the cartridge powder.</p> required <p>Returns:</p> Type Description <code>Velocity</code> <p>Muzzle velocity corrected for the specified temperature.</p> Note <p>The calculation uses the formula: adjusted_velocity = baseline_velocity + (temp_modifier / (15 / baseline_velocity)) * temp_delta ... where temp_delta is the difference between current_temp and powder_temp.</p> <p>If use_powder_sensitivity is False, returns the baseline muzzle velocity regardless of temperature.</p> Example <pre><code># Get velocity for current conditions\ncold_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\nhot_velocity = ammo.get_velocity_for_temp(Unit.Celsius(35))\n\nprint(f\"Baseline velocity: {ammo.mv}\")\nprint(f\"Cold weather velocity: {cold_velocity}\")\nprint(f\"Hot weather velocity: {hot_velocity}\")\n\n# With powder sensitivity disabled\nammo.use_powder_sensitivity = False\nconstant_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\n# constant_velocity equals ammo.mv regardless of temperature\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def get_velocity_for_temp(self, current_temp: Union[float, Temperature]) -&gt; Velocity:\n    \"\"\"Calculate muzzle velocity adjusted for powder temperature.\n\n    This method calculates the muzzle velocity at a given temperature based\n    on the baseline velocity, powder temperature, and temperature sensitivity\n    modifier. If powder sensitivity is disabled, returns the baseline velocity.\n\n    Args:\n        current_temp: Temperature of the cartridge powder.\n\n    Returns:\n        Muzzle velocity corrected for the specified temperature.\n\n    Note:\n        The calculation uses the formula:\n        adjusted_velocity = baseline_velocity + (temp_modifier / (15 / baseline_velocity)) * temp_delta\n        ... where temp_delta is the difference between current_temp and powder_temp.\n\n        If use_powder_sensitivity is False, returns the baseline muzzle velocity regardless of temperature.\n\n    Example:\n        ```python\n        # Get velocity for current conditions\n        cold_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\n        hot_velocity = ammo.get_velocity_for_temp(Unit.Celsius(35))\n\n        print(f\"Baseline velocity: {ammo.mv}\")\n        print(f\"Cold weather velocity: {cold_velocity}\")\n        print(f\"Hot weather velocity: {hot_velocity}\")\n\n        # With powder sensitivity disabled\n        ammo.use_powder_sensitivity = False\n        constant_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\n        # constant_velocity equals ammo.mv regardless of temperature\n        ```\n    \"\"\"\n    if not self.use_powder_sensitivity:\n        return self.mv\n    try:\n        v0 = self.mv &gt;&gt; Velocity.MPS\n        t0 = self.powder_temp &gt;&gt; Temperature.Celsius\n        t1 = PreferredUnits.temperature(current_temp) &gt;&gt; Temperature.Celsius\n        t_delta = t1 - t0\n        muzzle_velocity = self.temp_modifier / (15 / v0) * t_delta + v0\n    except ZeroDivisionError:\n        muzzle_velocity = 0\n    return Velocity.MPS(muzzle_velocity)\n</code></pre>"},{"location":"api/munition/weapon/","title":"Weapon","text":"<p>Weapon configuration for ballistic calculations.</p> <p>This class represents the physical characteristics of a gun that affect trajectory calculations, including sight height, barrel twist rate, zero elevation, and optional sight system configuration.</p> <p>Attributes:</p> Name Type Description <code>sight_height</code> <code>Distance</code> <p>Vertical distance from line of sight to center of bore,          measured at the muzzle perpendicular to the line of sight.</p> <code>twist</code> <code>Distance</code> <p>Distance for barrel rifling to complete one complete turn.    Positive values indicate right-hand twist, negative for left-hand.</p> <code>zero_elevation</code> <code>Angular</code> <p>Angle of barrel centerline relative to line of sight            when the sight is set to \"zero\" position.</p> <code>sight</code> <code>Optional[Sight]</code> <p>Optional Sight instance for advanced sight calculations.</p> Note <p>The sight height is critical for trajectory calculations as it determines the offset between the line of sight and the bullet's initial trajectory. Barrel twist affects spin drift calculations for long-range shots.</p> Example <pre><code>weapon = Weapon(\n    sight_height=Unit.Inch(2.5),\n    twist=Unit.Inch(10),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight('FFP', 100, Unit.Mil(0.2), Unit.Mil(0.2))\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sight_height</code> <code>Optional[Union[float, Distance]]</code> <p>Vertical distance from line of sight to center of bore,          measured at the muzzle. Defaults to 0 if not specified.</p> <code>None</code> <code>twist</code> <code>Optional[Union[float, Distance]]</code> <p>Distance for barrel rifling to complete one complete turn.   Positive value for right-hand twist, negative for left-hand.   Defaults to 0 if not specified.</p> <code>None</code> <code>zero_elevation</code> <code>Optional[Union[float, Angular]]</code> <p>Angle of barrel relative to sight line when sight            is set to \"zero.\" Typically computed by Calculator.set_weapon_zero().            Defaults to 0 if not specified.</p> <code>None</code> <code>sight</code> <code>Optional[Sight]</code> <p>Optional Sight properties for advanced sight calculations.</p> <code>None</code> Example <pre><code>from py_ballisticcalc import Weapon, Unit, Sight\n\n# Basic weapon configuration\nweapon = Weapon(\n    sight_height=Unit.Inch(2.5),\n    twist=Unit.Inch(10)\n)\n\n# Advanced weapon with sight system\nweapon = Weapon(\n    sight_height=Unit.Inch(2.5),\n    twist=Unit.Inch(10),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight(\n        'FFP', \n        scale_factor=Unit.Meter(100),\n        h_click_size=Unit.Mil(0.2),\n        v_click_size=Unit.Mil(0.2)\n    )\n)\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def __init__(self,\n             sight_height: Optional[Union[float, Distance]] = None,\n             twist: Optional[Union[float, Distance]] = None,\n             zero_elevation: Optional[Union[float, Angular]] = None,\n             sight: Optional[Sight] = None):\n    \"\"\"Initialize a Weapon instance with given parameters.\n\n    Args:\n        sight_height: Vertical distance from line of sight to center of bore,\n                     measured at the muzzle. Defaults to 0 if not specified.\n        twist: Distance for barrel rifling to complete one complete turn.\n              Positive value for right-hand twist, negative for left-hand.\n              Defaults to 0 if not specified.\n        zero_elevation: Angle of barrel relative to sight line when sight\n                       is set to \"zero.\" Typically computed by Calculator.set_weapon_zero().\n                       Defaults to 0 if not specified.\n        sight: Optional Sight properties for advanced sight calculations.\n\n    Example:\n        ```python\n        from py_ballisticcalc import Weapon, Unit, Sight\n\n        # Basic weapon configuration\n        weapon = Weapon(\n            sight_height=Unit.Inch(2.5),\n            twist=Unit.Inch(10)\n        )\n\n        # Advanced weapon with sight system\n        weapon = Weapon(\n            sight_height=Unit.Inch(2.5),\n            twist=Unit.Inch(10),\n            zero_elevation=Unit.Mil(0),\n            sight=Sight(\n                'FFP', \n                scale_factor=Unit.Meter(100),\n                h_click_size=Unit.Mil(0.2),\n                v_click_size=Unit.Mil(0.2)\n            )\n        )\n        ```\n    \"\"\"\n    self.sight_height = PreferredUnits.sight_height(sight_height or 0)\n    self.twist = PreferredUnits.twist(twist or 0)\n    self.zero_elevation = PreferredUnits.angular(zero_elevation or 0)\n    self.sight = sight\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.sight_height","title":"sight_height  <code>instance-attribute</code>","text":"<pre><code>sight_height: Distance = sight_height(sight_height or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.twist","title":"twist  <code>instance-attribute</code>","text":"<pre><code>twist: Distance = twist(twist or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.zero_elevation","title":"zero_elevation  <code>instance-attribute</code>","text":"<pre><code>zero_elevation: Angular = angular(zero_elevation or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.sight","title":"sight  <code>instance-attribute</code>","text":"<pre><code>sight: Optional[Sight] = sight\n</code></pre>"},{"location":"concepts/constants/","title":"Constants","text":"<p>API Documentation</p> <p><code>py_ballisticcalc.constants</code></p>"},{"location":"concepts/drag_model/","title":"DragModel","text":"API Documentation <p><code>py_ballisticcalc.drag_model</code></p>"},{"location":"concepts/trajectory_data/","title":"TrajectoryData","text":"API Documentation <p><code>py_ballisticcalc.trajectory_data</code></p>"},{"location":"concepts/unit/","title":"Units and Dimensions","text":"<p>This project uses a lightweight, explicit unit system with strongly-typed quantities like <code>Distance</code>, <code>Velocity</code>, and <code>Angular</code>. Preferred display/IO units are configurable via <code>PreferredUnits</code>.</p> <p>Common patterns:</p> <ul> <li>Arithmetic between compatible dimensions returns the same type.</li> <li>Use shift operators to convert: <code>distance &gt;&gt; Unit.Yard</code>.</li> <li>Create values with helpers: <code>Distance.Yard(100)</code>, <code>Velocity.FPS(2600)</code>.</li> </ul> <p>See the full API reference:</p> API Reference: py_ballisticcalc.unit <p><code>py_ballisticcalc.unit</code></p>"},{"location":"concepts/vector/","title":"Vector","text":"<p>API Documentation</p> <p><code>py_ballisticcalc.vector.Vector</code></p>"},{"location":"concepts/conditions/atmo/","title":"\ud83c\udf21\ufe0f Atmo","text":"API Documentation <p><code>py_ballisticcalc.conditions.Atmo</code></p>"},{"location":"concepts/conditions/shot/","title":"\ud83c\udfaf Shot","text":"API Documentation <p><code>py_ballisticcalc.conditions.Shot</code></p>"},{"location":"concepts/conditions/wind/","title":"\ud83d\udca8 Wind","text":"API Documentation <p><code>py_ballisticcalc.conditions.Wind</code></p>"},{"location":"concepts/munition/ammo/","title":"\ud83d\udca3 Ammo","text":"API Documentation <p><code>py_ballisticcalc.munition.Ammo</code></p> <p>The way to define <code>projectile</code> properties in py-ballisticcalc is via Ammo dataclass. Ammo instances are simply and reusable.</p>"},{"location":"concepts/munition/ammo/#ammo-initialization","title":"Ammo initialization","text":"<p>Import the necessary types to create a Weapon instance <pre><code>from py_ballisticcalc import Ammo, Unit, DragModel\n</code></pre></p> <p>Then create a weapon <pre><code>ammo = Ammo(\n    dm=DragModel(\n        bc=0.381,\n        drag_table=TableG7,\n        weight=Unit.Grain(300),\n        length=Unit.Inch(1.7),\n        diameter=Unit.Inch(0.338),\n    ),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True,\n)\n</code></pre> In this example, we use calls to <code>Unit</code> to initialize <code>Ammo</code> fields with specific unit types. We also can do it using <code>float</code>'s then fields will be initialized with unit types defined in <code>PreferredUnit</code> class, or we can directly specify the dimension with referencing to dimension type class</p> <p>Fields of a <code>Ammo</code> can be accessed as normal attributes of <code>ammo</code> instance</p> <p>Ammo instance is mutable object and field values can be changed through attribute assignment</p> <p>Warning</p> <p>Direct values assignment to attributes of <code>ammo</code> is restricted and not recommended, it can be not reinitialized properly after that</p> <p>Weapon possess the following methods and attributes:</p> <ul> <li><code>dm</code>: DragModel for projectile</li> <li><code>mv</code>: Muzzle Velocity</li> <li><code>powder_temp</code>: Baseline temperature that produces the given mv</li> <li><code>temp_modifier</code>: Change in velocity w temperature: % per 15\u00b0C.</li> <li><code>use_powder_sensitivity</code>: Flag to enable adjusting muzzle velocity to powder temperature</li> <li><code>calc_powder_sens</code>: Method to calculate powder temperature sensitivity coefficient</li> <li><code>get_velocity_for_temp</code>: Method to get adjusted muzzle velocity to powder sensitivity</li> </ul> <p>Note</p> <p>See the API documentation of <code>Ammo</code> for the class definition including a full list of methods and attributes.</p>"},{"location":"concepts/munition/weapon/","title":"\ud83d\udd2b Weapon","text":"API Documentation <p><code>py_ballisticcalc.munition.Weapon</code></p>"},{"location":"concepts/munition/weapon/#weapon-initialization","title":"Weapon initialization","text":"<p>Import the necessary types to create a Weapon instance <pre><code>from py_ballisticcalc import Weapon, Unit, Sight\n</code></pre></p> <p>Then create a weapon <pre><code>weapon = Weapon(\n    sight_height=Unit.Inch(2.),\n    twist=Unit.Inch(10.),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight(\n        'FFP', 2,\n        h_click_size=Unit.Mil(0.2),\n        v_click_size=Unit.Mil(0.2)\n    )\n)\n</code></pre> In this example, we use calls to <code>Unit</code> to initialize <code>Weapon</code> fields with specific unit types. We also can do it using <code>float</code>s then fields will be initialized with unit types defined in <code>PreferredUnit</code> class, or we can directly specify the dimension with referencing to dimension type class.</p> <p>Fields of a <code>Weapon</code> can be accessed as normal attributes of <code>weapon</code> instance.</p> <p>Weapon instance is mutable object and field values can be changed through attribute assignment.</p>"},{"location":"concepts/munition/weapon/#weapon-methods-and-properties","title":"Weapon methods and properties","text":"<p>Weapon possess the following methods and attributes:</p> <ul> <li> <p><code>sight_height</code>: Sight height, which is the distance between the line of sight and barrel center at the muzzle, measured perpendicular to the line of sight as shown in the following figure:</p> </li> <li> <p><code>twist</code>: Twist rate of barrel rifling, in terms of length to complete 1 rotation.  Positive values indicate right-hand twist, negative values indicate left-hand twist.</p> </li> <li><code>zero_elevation</code>: Angle of barrel centerline relative to line of sight when the sight is set to \"zero.\" </li> <li><code>sight</code>: Sight type and properties.</li> </ul> <p>Note</p> <p>See the API documentation of <code>Weapon</code> for the class definition including a full list of methods and attributes.</p>"}]}