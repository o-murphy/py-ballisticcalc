{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuickStart","text":"py_ballisticcalc  <p>LGPL library for small arms ballistic calculations based on point-mass (3 DoF) plus spin drift.</p>"},{"location":"#quickstart","title":"QuickStart","text":"<p>This QuickStart gets you from a fresh environment to running basic ballistic calculations.</p>"},{"location":"#install","title":"Install","text":"<p>Prerequisites: Python 3.10+.</p> <ul> <li>Latest release (PyPI):</li> </ul> pipuv <pre><code>pip install py-ballisticcalc\n</code></pre> <pre><code>uv add py-ballisticcalc\n</code></pre> <ul> <li>With performance extensions (recommended for production/benchmarks):</li> </ul> pipuv <pre><code>pip install \"py-ballisticcalc[exts]\"\n</code></pre> <pre><code>uv add py-ballisticcalc[exts]\n</code></pre> <ul> <li>From local sources (editable), useful when developing or running tests:</li> </ul> pipuv <pre><code># from repo root\npy -m pip install -e .[dev]                        # main package editable\npy -m pip install -e ./py_ballisticcalc.exts[dev]  # build/install C extensions (optional)\n</code></pre> <pre><code># from repo root\nuv sync --dev                        # main package editable\nuv sync --dev --extra exts           # build/install C extensions (optional)\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#simple-zero","title":"Simple Zero","text":"<pre><code>from py_ballisticcalc import *\n\n# Define a standard .308 Winchester shot: G7 BC=0.22, muzzle velocity = 2600fps\nzero = Shot(weapon=Weapon(sight_height=2), ammo=Ammo(DragModel(0.22, TableG7), mv=Velocity.FPS(2600)))\ncalc = Calculator()\n# Zero the gun for 100 yards\nzero_distance = Distance.Yard(100)\nzero_elevation = calc.set_weapon_zero(zero, zero_distance)\nprint(f'Barrel elevation for {zero_distance} zero: {zero_elevation &lt;&lt; PreferredUnits.adjustment}')\n</code></pre> <pre><code>Barrel elevation for 100.0yd zero: 1.33mil\n</code></pre>"},{"location":"#print-range-card","title":"Print Range Card","text":"<pre><code># Generate Range card for this zero with a 5mph cross-wind from left to right\nzero.winds = [Wind(Velocity.MPH(5), Angular.OClock(3))]\nrange_card = calc.fire(zero, trajectory_range=500, trajectory_step=100)\nrange_card.dataframe(True)[['distance', 'velocity', 'mach', 'time', 'height', 'drop_angle', 'windage', 'windage_angle']]\n</code></pre> distance velocity mach time height drop_angle windage windage_angle 0.0 yd 2600.0 ft/s 2.33 mach 0.000 s -2.0 inch 0.00 mil -0.0 inch 0.00 mil 100.0 yd 2398.1 ft/s 2.15 mach 0.120 s -0.0 inch -0.00 mil 0.4 inch 0.12 mil 200.0 yd 2205.5 ft/s 1.98 mach 0.251 s -4.1 inch -0.57 mil 1.7 inch 0.25 mil 300.0 yd 2022.3 ft/s 1.81 mach 0.393 s -15.3 inch -1.44 mil 4.1 inch 0.39 mil 400.0 yd 1847.5 ft/s 1.65 mach 0.548 s -35.0 inch -2.48 mil 7.6 inch 0.54 mil 500.0 yd 1680.1 ft/s 1.50 mach 0.718 s -65.0 inch -3.68 mil 12.4 inch 0.70 mil"},{"location":"#more-examples","title":"More Examples","text":"<p>See <code>examples\\Examples.ipynb</code> and <code>examples\\ExtremeExamples.ipynb</code> for more detailed examples.</p>"},{"location":"#support-issues","title":"Support / Issues","text":"<ul> <li>Open an issue on the GitHub repository if you encounter bugs or unexpected behavior.</li> </ul>"},{"location":"about/","title":"About project","text":"<p>This library provides trajectory calculation for ballistic projectiles launched by airguns, bows, firearms, artillery, etc.</p> <p>The core point-mass (3DoF) ballistic model underlying this project was used on the earliest digital computers.  Notable implementations that preceded this one:</p> <ul> <li>Robert McCoy (author of Modern Exterior Ballistics) implemented one in BASIC.</li> <li>JBM published code in C.</li> <li>Nikolay Gekht ported that to C#, extended it with formulas from Bryan Litz's Applied Ballistics, and ported it to Go.</li> <li>Alexandre Trofimov implemented a calculator in JavaScript.</li> </ul> <p>This Python3 implementation has been expanded to support multiple ballistic coefficients and custom drag functions, such as those derived from Doppler radar data.</p> <p>RISK NOTICE</p> <p>The library performs very limited simulation of a complex physical process and so it performs a lot of approximations. Therefore, the calculation results MUST NOT be considered as completely and reliably reflecting actual behavior or characteristics of projectiles. While these results may be used for educational purpose, they must NOT be considered as reliable for the areas where incorrect calculation may cause making a wrong decision, financial harm, or can put a human life at risk.</p> <p>THE CODE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We'd love for you to contribute to py_ballisticcalc!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"from importlib.metadata import metadata; print(metadata('py-ballisticcalc')['Version'])\"\n</code></pre> <p>Please try to always include the above unless you're unable to install py-ballisticcalc or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be extremely simple to get started and create a Pull Request. py-ballisticcalc is released regularly so you should see your improvements release in a matter of days or weeks \ud83d\ude80.</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily, py-ballisticcalc has few dependencies, and tests don't need access to databases, etc. Because of this, setting up and running the tests should be very simple.</p> <p>Note</p> <p>For high performance, the py-ballisticcalc.exts subproject requires cython to create compiled calculation engines.</p> <p>Following are the basics of creating a Pull Request.  For more developer guidance see Developer Details and Architecture.</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>You'll need the following prerequisites:</p> <ul> <li>Any Python version &gt;= Python 3.10</li> <li>venv or uv or other virtual environment tool</li> <li>git</li> </ul> <p>For the Cythonized/C-based engines, you must have the following build dependencies installed:</p> LinuxWindowsmacOS <ul> <li>GCC (e.g., <code>build-essential</code> for Ubuntu/Debian or <code>build-base</code> for Alpine)</li> <li><code>python3-dev</code> (or equivalent Python development headers)</li> </ul> <ul> <li>Microsoft Visual C++ (MSVC) build tools</li> </ul> <ul> <li>Xcode Command Line Tools (installs Clang/GCC, <code>make</code>, etc.)</li> </ul>"},{"location":"contributing/#installation-and-setup","title":"Installation and setup","text":"<p>Fork the repository on GitHub and clone your fork locally.</p> <pre><code># Clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/py-ballisticcalc.git\ncd py-ballisticcalc\n</code></pre> pipuv <pre><code># Setup virtual environment (we will use `venv` there)\npython -m venv .venv\nsource .venv/bin/activate\n\n# Install package in editable mode with `dev` requirements to local environment \npip install -e .[dev]\n</code></pre> <pre><code># Sync project\nuv sync --dev\n# Activate `venv`\nsource .venv/bin/activate\n</code></pre> <p>If you want to contribute to cythonized extensions you can also install them in editable mode:</p> pipuv <pre><code>pip install -e ./py_ballisticcalc.exts[dev]\n</code></pre> <pre><code>uv sync --dev --extra exts\n</code></pre>"},{"location":"contributing/#check-out-a-new-branch-and-make-your-changes","title":"Check out a new branch and make your changes","text":"<p>Create a new branch for your changes.</p> <pre><code># Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# Make your changes...\n</code></pre>"},{"location":"contributing/#run-tests-and-linting","title":"Run tests and linting","text":"<p>Run tests and linting locally to make sure everything is working as expected.</p> <pre><code># Run automated code linting\nruff check\n\n# Run mypy static analysing \nmypy\n\n# Run automated tests\npytest\n\n# Run automated tests for specific engine\npytest --engine=\"cythonized_rk4_engine\"  # via project.entry-points\npytest --engine=\"my_lib.my_engine:MyEngineClass\"  # via entry point path \n</code></pre>"},{"location":"contributing/#coverage","title":"Coverage","text":"<p>We use <code>pytest-cov</code> to get coverage reports: <pre><code>pytest --cov=py_ballisticcalc --cov-report=html  # for default engine\npytest --cov=py_ballisticcalc --cov-report=html --engine=\"scipy_engine\"  # for custom engine \n</code></pre></p> <p>To get coverage of Cython, set the environment variable <code>CYTHON_COVERAGE = '1'</code>, rebuild <code>py_ballisticcalc.exts</code> (from project root: <code>pip install -e py_ballisticcalc.exts</code>), then run:</p> <pre><code>python scripts/sync_cython_sources.py\npytest --engine=\"cythonized_rk4_engine\" --cov=py_ballisticcalc --cov=py_ballisticcalc_exts --cov-report=html\n</code></pre>"},{"location":"contributing/#cython-extensions-safety-stress","title":"Cython extensions: safety &amp; stress","text":"<p>For diagnosing low-level issues (bounds, None checks, overflows) and for opt-in long-running stress tests, use the safety and stress workflows below. Commands are shown for Windows PowerShell.</p> <pre><code># Rebuild Cython extensions with safety checks enabled\n$env:CYTHON_SAFETY = '1'\n# Optional: force Cython to regenerate C code even if sources look unchanged\n$env:CYTHON_FORCE_REGEN = '1'\n\n# Reinstall extensions in editable mode (from project root)\npip install -e ./py_ballisticcalc.exts\n\n# Run extension test suite (stress tests excluded by default via markers)\npytest ./py_ballisticcalc.exts\\tests -q\n\n# Run only the stress tests (opt-in). These are longer and more memory-heavy.\npytest ./py_ballisticcalc.exts\\tests -m stress -q\n\n# Clear env after testing\nRemove-Item Env:CYTHON_SAFETY; Remove-Item Env:CYTHON_FORCE_REGEN\n</code></pre> <p>Notes:</p> <ul> <li>Safety build toggles bounds checking, wraparound, initialization checks, None checks, disables cdivision, and adds overflow checks; it trades speed for correctness to surface bugs.</li> <li>The extension test suite enables <code>faulthandler</code> for better tracebacks on crashes.</li> <li>Stress tests are marked with <code>@pytest.mark.stress</code> and are excluded by default.</li> </ul>"},{"location":"contributing/#build-documentation","title":"Build Documentation","text":"<p>If you have made any changes affecting the documentation (including changes to function signatures, class definitions, or docstrings that will appear in the API documentation), make sure the documentation builds successfully.</p> <p>We use <code>mkdocs-material[imaging]</code> to support social previews. You can find directions on how to install the required dependencies here.</p> pipuv <pre><code># Install dependencies for docs building\npip install -e .[docs]\n</code></pre> <pre><code># Install dependencies for docs building\nuv sync --extra docs \n</code></pre> <ul> <li><code>mkdocs build</code> will populate a <code>./site</code> folder with HTML.</li> <li><code>mkdocs serve</code> will build and serve the HTML via local connection.</li> </ul> <p>If this isn't working due to issues with the imaging plugin, try commenting out the <code>social</code> plugin line in <code>mkdocs.yml</code> and running <code>mkdocs build</code> again.</p>"},{"location":"contributing/#commit-and-push-your-changes","title":"Commit and push your changes","text":"<p>Commit your changes, push your branch to GitHub, and create a pull request.</p> <p>Please follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.</p> <p>When your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is written in Markdown and built using Material for MkDocs. API documentation is build from docstrings using mkdocstrings.</p> <p>In general, documentation should be written in a friendly, approachable style. It should be easy to read and understand, and should be as concise as possible while still being complete.</p>"},{"location":"contributing/#code-documentation","title":"Code documentation","text":"<p>When contributing to py-ballisticcalc, please make sure that all code is well documented. The following should be documented using properly formatted docstrings:</p> <ul> <li>Modules</li> <li>Class definitions</li> <li>Function definitions</li> <li>Module-level variables</li> </ul> <p>py-ballisticcalc uses Google-style docstrings formatted according to PEP 257 guidelines. (See Example Google Style Python Docstrings for further examples.)</p> <p>pydocstyle is used for linting docstrings. You can run <code>pydocstyle ./py_ballisticcalc\\</code> to check your docstrings.</p> <p>Where this is a conflict between Google-style docstrings and pydocstyle linting, follow the pydocstyle linting hints.</p> <p>Class attributes and function arguments should be documented in the format \"name: description.\" When applicable, a return type should be documented with just a description. Types are inferred from the signature/type-hints.</p> <ul> <li> <p>Class attributes should be documented in the class docstring.</p> </li> <li> <p>Instance attributes should be documented as \"Args\" in the <code>__init__</code> docstring.</p> </li> </ul> <pre><code>class Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n</code></pre> <pre><code>def bar(self, baz: int) -&gt; str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n</code></pre> <p>Code examples are encouraged but should be kept short and simple. However, every code example should be complete, self-contained, and runnable. (If you're not sure how to do this, ask for help!) We prefer print output to naked asserts, but if you're testing something that doesn't have a useful print output, asserts are fine. Code examples should pass doctest, which you can run via <code>scripts\\run_doctest.py</code>.</p>"},{"location":"contributing/#mermaid","title":"Mermaid","text":"<p>We support Mermaid diagrams in Markdown using Material for MkDocs. Use triple backticks with the <code>mermaid</code> fence; no plugin installation is required beyond our existing theme config.</p> <pre><code>graph LR\n    A[Start] --&gt; B{Mermaid enabled?}\n    B -- Yes --&gt; C[Write diagrams]\n    B -- No --&gt; D[Check mkdocs.yml]</code></pre> <p>Tips:</p> <ul> <li>Keep fences as ```mermaid (no extra indentation).</li> <li>Build locally to preview:     <pre><code>mkdocs build\nmkdocs serve\n</code></pre></li> <li>If a diagram renders as plain text, ensure the <code>mermaid</code> fence is exactly specified and not wrapped in another code block.</li> </ul>"},{"location":"contributors/","title":"Our People","text":"<p>py-ballisticcalc has an amazing community of contributors, reviewers, and experts that help propel the project forward. Here, we celebrate those people and their contributions.</p>"},{"location":"contributors/#contributors","title":"Contributors","text":"<p>This project exists thanks to all the people who contribute.</p> <p></p> <p>Special thanks to:</p> <ul> <li>David Bookstaber - Ballistics Expert  For help understanding and improving the functionality</li> <li>Serhiy Yevtushenko - Applied Mathematician  For helping in consultations, testing and improving edge cases compatibility</li> <li>Nikolay Gekht For the sources code on C# and GO-lang from which this project firstly was forked</li> </ul>"},{"location":"help/","title":"Getting help with py-ballisticcalc","text":"<p>If you need help getting started with py-ballisticcalc or with advanced usage, the following sources may be useful.</p>"},{"location":"help/#usage-documentation","title":"Usage Documentation","text":"<p>The usage documentation is the most complete guide on how to use py-ballisticcalc.</p>"},{"location":"help/#github-discussions","title":"GitHub Discussions","text":"<p>GitHub discussions are useful for asking questions, your question and the answer will help everyone.</p>"},{"location":"install/","title":"Installation","text":"<p>Installation is as simple as:</p> pipuv <pre><code>pip install py-ballisticcalc\n</code></pre> <pre><code>uv add py-ballisticcalc \n</code></pre> <p>If you have Python 3.10+ and <code>pip</code> installed, you're good to go.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>py-ballisticcalc has the following optional dependencies:</p> <ul> <li><code>exts</code>: Cython based implementation of some classes to increase performance. py_ballisticcalc.exts package.</li> <li><code>charts</code>: Includes matplotlib for creating <code>charts</code> and pandas for creating <code>DataFrame tables</code>.</li> <li><code>scipy</code>: Installs support for the <code>SciPyIntegrationEngine</code>.</li> </ul> <p>To install optional dependencies along with py-ballisticcalc:</p> pipuv <pre><code># with the cython extensions:\npip install \"py-ballisticcalc[exts]\"\n</code></pre> <pre><code># with dependencies for charting:\npip install \"py-ballisticcalc[charts]\"\n</code></pre> <pre><code># with the cython extensions:\nuv add \"py-ballisticcalc[exts]\"\n</code></pre> <pre><code># with dependencies for charting:\nuv add \"py-ballisticcalc[charts]\"\n</code></pre> <p>You can also install requirements manually.  For example:</p> pipuv <pre><code>pip install py-ballisticcalc.exts pandas matplotlib\n</code></pre> <pre><code>uv add py-ballisticcalc.exts pandas matplotlib\n</code></pre> <p>To install latest version from sources in editable mode:</p> <pre><code>git clone https://github.com/o-murphy/py-ballisticcalc\ncd py-ballisticcalc\n</code></pre> pipuv <pre><code># from repo root\npy -m pip install -e .[dev]                        # main package editable\npy -m pip install -e ./py_ballisticcalc.exts[dev]  # build/install C extensions (optional)\n</code></pre> <pre><code># from repo root\nuv sync --dev                        # main package editable\nuv sync --dev --extra exts           # build/install C extensions (optional)\n</code></pre>"},{"location":"api/","title":"Overview","text":"<p>This page summarizes the primary classes for this project and how they fit together at runtime.</p>"},{"location":"api/#core-workflow","title":"Core Workflow","text":"<ul> <li><code>Calculator</code>: High-level entry point to compute trajectories. Accepts a <code>Shot</code> (scene) and returns a <code>HitResult</code> with trajectory rows and helpers.</li> <li><code>Shot</code>: Details a shooting scenario \u2013 <code>Ammo</code>, <code>Atmo</code>, <code>Weapon</code>, <code>Wind</code>, and angles (look/slant, relative, cant).</li> <li><code>HitResult</code>: Wrapper for accessing and displaying calculated results, including a list of <code>TrajectoryData</code> (which are detailed characteristics of points on the ballistic trajectory).</li> </ul>"},{"location":"api/#projectile-environment","title":"Projectile &amp; Environment","text":"<pre><code>classDiagram\n    class Shot {\n        look_angle\n        relative_angle\n    }\n    class Ammo {\n        mv\n        temp_modifier\n    }\n    class Atmo {\n        altitude\n        temperature\n        pressure\n        humidity\n    }\n    class Wind\n    class Weapon {\n        zero_elevation\n        sight_height\n        twist\n    }\n    class DragModel\n    class Sight\n\n    Shot o-- Ammo\n    Shot o-- Atmo\n    Shot o-- \"0..n\" Wind\n    Shot o-- \"0..1\" Weapon\n    Ammo o-- DragModel\n    Weapon o-- \"0..1\" Sight</code></pre> <p>The classes that comprise a <code>Shot</code>:</p> <ul> <li><code>Ammo</code>: Wraps muzzle velocity, including optional powder temperature sensitivity, together with a DragModel.<ul> <li><code>DragModel</code>: Physical details of a projectile, including aerodynamic drag as a function of velocity.  (Drag is typically modelled via Ballistic Coefficient and standard drag tables \u2013 G1, G7, etc.)</li> </ul> </li> <li><code>Atmo</code>: Standard or custom atmosphere.</li> <li><code>Wind</code>: Piecewise-constant winds by distance.</li> <li><code>Weapon</code>: Gun specifications (sight height, rifle twist rate, zero elevation, <code>Sight</code> details).</li> </ul>"},{"location":"api/#engines","title":"Engines","text":"<p>Calculation engines implement different algorithms for integration and targeting.  All inherit from <code>BaseIntegrationEngine</code>.</p> <ul> <li>RK4IntegrationEngine</li> <li>EulerIntegrationEngine</li> <li>VelocityVerletIntegrationEngine</li> <li>SciPyIntegrationEngine</li> </ul> Selected API references <p><code>py_ballisticcalc.interface.Calculator</code> <code>py_ballisticcalc.shot.Shot</code> <code>py_ballisticcalc.munition.Ammo</code> <code>py_ballisticcalc.conditions.Atmo</code> <code>py_ballisticcalc.munition.Weapon</code> <code>py_ballisticcalc.trajectory_data.HitResult</code> <code>py_ballisticcalc.trajectory_data.TrajectoryData</code></p>"},{"location":"api/constants/","title":"Constants","text":""},{"location":"api/constants/#py_ballisticcalc.constants","title":"constants","text":"<p>Global physical and atmospheric constants for ballistic calculations.</p> <p>This module defines scientific constants used throughout the ballistic calculations, including atmospheric model constants, physical constants, and runtime limits. All constants follow international standards (ISA, ICAO) where applicable.</p> Constant Categories <ul> <li>Global atmosphere constants: Standard conditions and coefficients</li> <li>ISA metric constants: International Standard Atmosphere in metric units</li> <li>ICAO constants: International Civil Aviation Organization standards</li> <li>Conversion factors: Unit conversion constants</li> <li>Runtime limits: Computational bounds and validation limits</li> </ul> References <ul> <li>ISA: https://www.engineeringtoolbox.com/international-standard-atmosphere-d_985.html</li> <li>ICAO: International Civil Aviation Organization standards</li> <li>Physical constants: NIST and other authoritative sources</li> </ul> <p>Attributes:</p> Name Type Description <code>cGravityImperial</code> <code>Final[float]</code> <p>Standard gravity (g) in ft/s\u00b2</p> <code>cEarthAngularVelocityRadS</code> <code>Final[float]</code> <p>Earth's rotational speed (\u03a9) in radians per second (rad/s)</p> <code>cStandardHumidity</code> <code>Final[float]</code> <p>Standard relative humidity used in atmospheric calculations (%)</p> <code>cPressureExponent</code> <code>Final[float]</code> <p>Pressure exponent constant for barometric formula (dimensionless)</p> <code>cStandardTemperatureC</code> <code>Final[float]</code> <p>Standard temperature at sea level in Celsius (\u00b0C)</p> <code>cLapseRateKperFoot</code> <code>Final[float]</code> <p>Temperature lapse rate in Kelvin per foot (K/ft)</p> <code>cLapseRateMetric</code> <code>Final[float]</code> <p>Temperature lapse rate in metric units (\u00b0C/m)</p> <code>cStandardPressureMetric</code> <code>Final[float]</code> <p>Standard atmospheric pressure at sea level (hPa)</p> <code>cSpeedOfSoundMetric</code> <code>Final[float]</code> <p>Speed of sound coefficient in metric units (m/s per \u221aK)</p> <code>cStandardDensityMetric</code> <code>Final[float]</code> <p>Standard air density at sea level in metric units (kg/m\u00b3)</p> <code>cStandardTemperatureF</code> <code>Final[float]</code> <p>Standard temperature at sea level in Fahrenheit (\u00b0F)</p> <code>cLapseRateImperial</code> <code>Final[float]</code> <p>Temperature lapse rate in imperial units (\u00b0F/ft)</p> <code>cStandardPressure</code> <code>Final[float]</code> <p>Standard atmospheric pressure at sea level (InHg)</p> <code>cSpeedOfSoundImperial</code> <code>Final[float]</code> <p>Speed of sound coefficient in imperial units (fps per \u221a\u00b0R)</p> <code>cStandardDensity</code> <code>Final[float]</code> <p>Standard air density at sea level in imperial units (lb/ft\u00b3)</p> <code>cDegreesCtoK</code> <code>Final[float]</code> <p>Celsius to Kelvin conversion constant (K)</p> <code>cDegreesFtoR</code> <code>Final[float]</code> <p>Fahrenheit to Rankine conversion constant (\u00b0R)</p> <code>cDensityImperialToMetric</code> <code>Final[float]</code> <p>Density conversion factor from imperial to metric units (kg/m\u00b3 per lb/ft\u00b3)</p> <code>cLowestTempF</code> <code>Final[float]</code> <p>Minimum allowed temperature for atmospheric calculations (\u00b0F)</p> <code>cMaxWindDistanceFeet</code> <code>Final[float]</code> <p>Maximum wind effect distance for computational limits (ft)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cGravityImperial","title":"cGravityImperial  <code>module-attribute</code>","text":"<pre><code>cGravityImperial: Final[float] = 32.17405\n</code></pre> <p>Standard gravity (g) in ft/s\u00b2</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cEarthAngularVelocityRadS","title":"cEarthAngularVelocityRadS  <code>module-attribute</code>","text":"<pre><code>cEarthAngularVelocityRadS: Final[float] = 7.2921159e-05\n</code></pre> <p>Earth's rotational speed (\u03a9) in radians per second (rad/s)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardHumidity","title":"cStandardHumidity  <code>module-attribute</code>","text":"<pre><code>cStandardHumidity: Final[float] = 0.0\n</code></pre> <p>Standard relative humidity used in atmospheric calculations (%)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cPressureExponent","title":"cPressureExponent  <code>module-attribute</code>","text":"<pre><code>cPressureExponent: Final[float] = 5.255876\n</code></pre> <p>Pressure exponent constant for barometric formula (dimensionless)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardTemperatureC","title":"cStandardTemperatureC  <code>module-attribute</code>","text":"<pre><code>cStandardTemperatureC: Final[float] = 15.0\n</code></pre> <p>Standard temperature at sea level in Celsius (\u00b0C)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLapseRateKperFoot","title":"cLapseRateKperFoot  <code>module-attribute</code>","text":"<pre><code>cLapseRateKperFoot: Final[float] = -0.0019812\n</code></pre> <p>Temperature lapse rate in Kelvin per foot (K/ft)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLapseRateMetric","title":"cLapseRateMetric  <code>module-attribute</code>","text":"<pre><code>cLapseRateMetric: Final[float] = -0.0065\n</code></pre> <p>Temperature lapse rate in metric units (\u00b0C/m)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardPressureMetric","title":"cStandardPressureMetric  <code>module-attribute</code>","text":"<pre><code>cStandardPressureMetric: Final[float] = 1013.25\n</code></pre> <p>Standard atmospheric pressure at sea level (hPa)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cSpeedOfSoundMetric","title":"cSpeedOfSoundMetric  <code>module-attribute</code>","text":"<pre><code>cSpeedOfSoundMetric: Final[float] = 20.0467\n</code></pre> <p>Speed of sound coefficient in metric units (m/s per \u221aK)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardDensityMetric","title":"cStandardDensityMetric  <code>module-attribute</code>","text":"<pre><code>cStandardDensityMetric: Final[float] = 1.225\n</code></pre> <p>Standard air density at sea level in metric units (kg/m\u00b3)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardTemperatureF","title":"cStandardTemperatureF  <code>module-attribute</code>","text":"<pre><code>cStandardTemperatureF: Final[float] = 59.0\n</code></pre> <p>Standard temperature at sea level in Fahrenheit (\u00b0F)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLapseRateImperial","title":"cLapseRateImperial  <code>module-attribute</code>","text":"<pre><code>cLapseRateImperial: Final[float] = -0.00356616\n</code></pre> <p>Temperature lapse rate in imperial units (\u00b0F/ft)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardPressure","title":"cStandardPressure  <code>module-attribute</code>","text":"<pre><code>cStandardPressure: Final[float] = 29.92\n</code></pre> <p>Standard atmospheric pressure at sea level (InHg)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cSpeedOfSoundImperial","title":"cSpeedOfSoundImperial  <code>module-attribute</code>","text":"<pre><code>cSpeedOfSoundImperial: Final[float] = 49.0223\n</code></pre> <p>Speed of sound coefficient in imperial units (fps per \u221a\u00b0R)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cStandardDensity","title":"cStandardDensity  <code>module-attribute</code>","text":"<pre><code>cStandardDensity: Final[float] = 0.076474\n</code></pre> <p>Standard air density at sea level in imperial units (lb/ft\u00b3)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cDegreesCtoK","title":"cDegreesCtoK  <code>module-attribute</code>","text":"<pre><code>cDegreesCtoK: Final[float] = 273.15\n</code></pre> <p>Celsius to Kelvin conversion constant (K)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cDegreesFtoR","title":"cDegreesFtoR  <code>module-attribute</code>","text":"<pre><code>cDegreesFtoR: Final[float] = 459.67\n</code></pre> <p>Fahrenheit to Rankine conversion constant (\u00b0R)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cDensityImperialToMetric","title":"cDensityImperialToMetric  <code>module-attribute</code>","text":"<pre><code>cDensityImperialToMetric: Final[float] = 16.0185\n</code></pre> <p>Density conversion factor from imperial to metric units (kg/m\u00b3 per lb/ft\u00b3)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cLowestTempF","title":"cLowestTempF  <code>module-attribute</code>","text":"<pre><code>cLowestTempF: Final[float] = -130\n</code></pre> <p>Minimum allowed temperature for atmospheric calculations (\u00b0F)</p>"},{"location":"api/constants/#py_ballisticcalc.constants.cMaxWindDistanceFeet","title":"cMaxWindDistanceFeet  <code>module-attribute</code>","text":"<pre><code>cMaxWindDistanceFeet: Final[float] = 100000000.0\n</code></pre> <p>Maximum wind effect distance for computational limits (ft)</p>"},{"location":"api/constants/#global-atmosphere-constants","title":"Global atmosphere constants","text":"Constant Description Value Unit / Notes <code>cStandardHumidity</code> Relative Humidity in percents 0.0 % <code>cPressureExponent</code> =gM/RL 5.255876 - <code>cA0</code> Coefficient A0 1.24871 - <code>cA1</code> Coefficient A1 0.0988438 - <code>cA2</code> Coefficient A2 0.00152907 - <code>cA3</code> Coefficient A3 -3.07031e-06 - <code>cA4</code> Coefficient A4 4.21329e-07 - <code>cA5</code> Coefficient A5 3.342e-04 -"},{"location":"api/constants/#isa-metric-prefer_units","title":"ISA, metric prefer_units","text":"Constant Description Value Unit / Notes <code>cDegreesCtoK</code> Celsius to Kelvin conversion 273.15 \u00b0K = \u00b0C + 273.15 <code>cStandardTemperatureC</code> Standard temperature in Celsius 15.0 \u00b0C <code>cLapseRateMetric</code> Metric lapse rate -6.5e-03 \u00b0C/m <code>cStandardPressureMetric</code> Standard pressure (metric) 1013.25 hPa <code>cSpeedOfSoundMetric</code> Speed of sound in metric 331.3 m/s <code>cStandardDensityMetric</code> Standard air density (metric) 1.2250 kg/m\u00b3 <code>cDensityImperialToMetric</code> Density conversion (imperial to metric) 16.0185 lb/ft\u00b3 to kg/m\u00b3"},{"location":"api/constants/#icao-standard-atmosphere","title":"ICAO standard atmosphere","text":"Constant Description Value Unit / Notes <code>cDegreesFtoR</code> Fahrenheit to Rankine conversion 459.67 \u00b0R = \u00b0F + 459.67 <code>cStandardTemperatureF</code> Standard temperature in Fahrenheit 59.0 \u00b0F <code>cLapseRateImperial</code> Imperial lapse rate -3.56616e-03 \u00b0F/ft <code>cStandardPressure</code> Standard pressure (imperial) 29.92 InHg <code>cSpeedOfSoundImperial</code> Speed of sound (imperial) 49.0223 fps <code>cStandardDensity</code> Standard air density (imperial) 0.076474 lb/ft\u00b3"},{"location":"api/constants/#runtime-limits-constants","title":"Runtime limits constants","text":"Constant Description Value Unit / Notes <code>cLowestTempF</code> Lowest temperature recorded -130 \u00b0F <code>cMaxWindDistanceFeet</code> Maximum wind distance 1e8 ft"},{"location":"api/drag_model/","title":"DragModel","text":""},{"location":"api/drag_model/#py_ballisticcalc.drag_model","title":"drag_model","text":"<p>Drag model implementations for ballistic projectiles.</p> <p>This module provides classes and functions for modeling aerodynamic drag of projectiles, including single and multi-BC (ballistic coefficient) models. Supports standard drag tables and custom drag data points.</p> Key Components <ul> <li>DragDataPoint: Individual drag coefficient at specific Mach number</li> <li>BCPoint: Ballistic coefficient point for multi-BC models</li> <li>DragModel: Primary drag model with ballistic coefficient and drag table</li> <li>DragModelMultiBC: Multi-BC drag model for varying ballistic coefficients</li> </ul> <p>Functions:</p> Name Description <code>- make_data_points</code> <p>Convert drag table data to DragDataPoint objects</p> <code>- sectional_density</code> <p>Calculate sectional density from weight and diameter</p> <code>- linear_interpolation</code> <p>Linear interpolation utility function</p> <p>The drag models use standard ballistic reference tables (G1, G7, etc.) and allow for custom drag functions based on Mach number vs drag coefficient data.</p> <p>Classes:</p> Name Description <code>DragDataPoint</code> <p>Drag coefficient at a specific Mach number.</p> <code>DragModel</code> <p>Aerodynamic drag model for ballistic projectiles.</p> <code>BCPoint</code> <p>Ballistic coefficient point for multi-BC drag models.</p>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model-attributes","title":"Attributes","text":""},{"location":"api/drag_model/#py_ballisticcalc.drag_model-classes","title":"Classes","text":""},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragDataPoint","title":"DragDataPoint  <code>dataclass</code>","text":"<pre><code>DragDataPoint(Mach: float, CD: float)\n</code></pre> <p>Drag coefficient at a specific Mach number.</p> <p>Attributes:</p> Name Type Description <code>Mach</code> <code>float</code> <p>Velocity in Mach units (dimensionless)</p> <code>CD</code> <code>float</code> <p>Drag coefficient (dimensionless)</p>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragModel","title":"DragModel","text":"<pre><code>DragModel(\n    bc: float,\n    drag_table: DragTableDataType,\n    weight: Union[float, Weight] = 0,\n    diameter: Union[float, Distance] = 0,\n    length: Union[float, Distance] = 0,\n)\n</code></pre> <p>Aerodynamic drag model for ballistic projectiles.</p> <p>Represents the drag characteristics of a projectile using a ballistic coefficient and drag table.</p> <p>The ballistic coefficient (BC) is defined as:     BC = weight / (diameter^2 * form_factor) where weight is in pounds, diameter is in inches, and form_factor is relative to the selected drag model.</p> <p>Attributes:</p> Name Type Description <code>BC</code> <p>Ballistic coefficient (scales drag model for a particular projectile)</p> <code>drag_table</code> <p>List of DragDataPoint objects defining Mach vs CD</p> <code>weight</code> <p>Projectile weight (only needed for spin drift calculations)</p> <code>diameter</code> <p>Projectile diameter (only needed for spin drift calculations)</p> <code>length</code> <p>Projectile length (only needed for spin drift calculations)</p> <code>sectional_density</code> <p>Calculated sectional density (lb/in\u00b2)</p> <code>form_factor</code> <p>Calculated form factor (dimensionless)</p> Note <p>The weight, diameter, and length parameters are only required when computing spin drift. For basic trajectory calculations, only BC and drag_table are needed.</p> <p>Parameters:</p> Name Type Description Default <code>bc</code> <code>float</code> <p>Ballistic coefficient</p> required <code>drag_table</code> <code>DragTableDataType</code> <p>Either list of DragDataPoint objects or list of         dictionaries with 'Mach' and 'CD' keys</p> required <code>weight</code> <code>Union[float, Weight]</code> <p>Projectile weight in grains (default: 0)</p> <code>0</code> <code>diameter</code> <code>Union[float, Distance]</code> <p>Projectile diameter in inches (default: 0)</p> <code>0</code> <code>length</code> <code>Union[float, Distance]</code> <p>Projectile length in inches (default: 0)</p> <code>0</code> <p>Examples:</p> <pre><code># Constant drag curve with C_d = 0.3:\ndm = DragModel(1, [DragDataPoint(1, 0.3)])\n\nfrom py_ballisticcalc.drag_tables import TableG7\n# Standard 155gr OTM bullet:\ndm = DragModel(0.23, TableG7, weight=155, diameter=0.308, length=1.2)\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If BC is not positive or drag_table is empty</p> <code>TypeError</code> <p>If drag_table format is invalid</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def __init__(\n    self,\n    bc: float,\n    drag_table: DragTableDataType,\n    weight: Union[float, Weight] = 0,\n    diameter: Union[float, Distance] = 0,\n    length: Union[float, Distance] = 0,\n) -&gt; None:\n    \"\"\"Initialize a drag model with ballistic coefficient and drag table.\n\n    Args:\n        bc: Ballistic coefficient\n        drag_table: Either list of DragDataPoint objects or list of\n                    dictionaries with 'Mach' and 'CD' keys\n        weight: Projectile weight in grains (default: 0)\n        diameter: Projectile diameter in inches (default: 0)\n        length: Projectile length in inches (default: 0)\n\n    Examples:\n        ```python\n        # Constant drag curve with C_d = 0.3:\n        dm = DragModel(1, [DragDataPoint(1, 0.3)])\n\n        from py_ballisticcalc.drag_tables import TableG7\n        # Standard 155gr OTM bullet:\n        dm = DragModel(0.23, TableG7, weight=155, diameter=0.308, length=1.2)\n        ```\n\n    Raises:\n        ValueError: If BC is not positive or drag_table is empty\n        TypeError: If drag_table format is invalid\n    \"\"\"\n    if len(drag_table) &lt;= 0:\n        raise ValueError(\"Received empty drag table\")\n    if bc &lt;= 0:\n        raise ValueError(\"Ballistic coefficient must be positive\")\n\n    self.drag_table = make_data_points(drag_table)\n\n    if len(self.drag_table) &lt; 2:\n        # Add second point with constant C_d to avoid interpolator complaints\n        self.drag_table.append(DragDataPoint(self.drag_table[0].Mach + 0.1, self.drag_table[0].CD))\n\n    self.BC = bc\n    self.length = PreferredUnits.length(length)\n    self.weight = PreferredUnits.weight(weight)\n    self.diameter = PreferredUnits.diameter(diameter)\n    if weight &gt; 0 and diameter &gt; 0:\n        self.sectional_density = self._get_sectional_density()\n        self.form_factor = self._get_form_factor(self.BC)\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.BCPoint","title":"BCPoint  <code>dataclass</code>","text":"<pre><code>BCPoint(\n    BC: float,\n    Mach: Optional[float] = None,\n    V: Optional[Union[float, Velocity]] = None,\n)\n</code></pre> <p>Ballistic coefficient point for multi-BC drag models.</p> <p>Represents a single ballistic coefficient at a specific velocity or Mach number.     Sorts by Mach number for constructing drag models (see <code>DragModelMultiBC</code>).</p> <p>Attributes:</p> Name Type Description <code>BC</code> <code>float</code> <p>Ballistic coefficient</p> <code>Mach</code> <code>float</code> <p>Mach number corresponding to this BC measurement</p> <code>V</code> <code>Optional[Velocity]</code> <p>Velocity corresponding to this BC measurement (optional)</p> <p>Examples:</p> <pre><code># Create a BCPoint with BC=0.5 at Mach 2.0\npoint1 = BCPoint(BC=0.5, Mach=2.0)\n\n# Create a BCPoint with BC=0.4 at 1500fps\npoint2 = BCPoint(BC=0.4, V=Velocity.FPS(1500))\n\n# Sort points by Mach number\npoints = [point2, point1]\npoints.sort()  # point1 will come before point2 since Mach 2.0 &lt; Mach at 1500fps\n</code></pre> Note <p>Either <code>Mach</code> or <code>V</code> must be specified, but not both. If <code>V</code> is provided then <code>Mach</code>     will be calculated automatically using standard atmospheric conditions.</p> <p>Parameters:</p> Name Type Description Default <code>BC</code> <code>float</code> <p>Ballistic coefficient (must be positive)</p> required <code>Mach</code> <code>Optional[float]</code> <p>Mach number (optional, mutually exclusive with <code>V</code>)</p> <code>None</code> <code>V</code> <code>Optional[Union[float, Velocity]]</code> <p>Velocity (optional, mutually exclusive with <code>Mach</code>)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>BC</code> is not positive, or if both or neither of <code>Mach</code> and <code>V</code> are specified.</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def __init__(self, BC: float, Mach: Optional[float] = None, V: Optional[Union[float, Velocity]] = None) -&gt; None:\n    \"\"\"Initialize a BCPoint.\n\n    Args:\n        BC: Ballistic coefficient (must be positive)\n        Mach: Mach number (optional, mutually exclusive with `V`)\n        V: Velocity (optional, mutually exclusive with `Mach`)\n\n    Raises:\n        ValueError: If `BC` is not positive, or if both or neither of `Mach` and `V` are specified.\n    \"\"\"\n    if BC &lt;= 0:\n        raise ValueError(\"Ballistic coefficient must be positive\")\n    if Mach and V:\n        raise ValueError(\"You cannot specify both 'Mach' and 'V' at the same time\")\n    if not Mach and not V:\n        raise ValueError(\"One of 'Mach' and 'V' must be specified\")\n\n    self.BC = BC\n    self.V = PreferredUnits.velocity(V or 0)\n    if V:\n        self.Mach = (self.V &gt;&gt; Velocity.MPS) / self._machC()\n    elif Mach:\n        self.Mach = Mach\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model-functions","title":"Functions","text":""},{"location":"api/drag_model/#py_ballisticcalc.drag_model.make_data_points","title":"make_data_points","text":"<pre><code>make_data_points(\n    drag_table: DragTableDataType,\n) -&gt; List[DragDataPoint]\n</code></pre> <p>Convert drag table from list of dictionaries to list of DragDataPoints.</p> <p>Handles both DragDataPoint objects and dictionaries with 'Mach' and 'CD' keys. Validates input format and provides clear error messages for invalid data.</p> <p>Parameters:</p> Name Type Description Default <code>drag_table</code> <code>DragTableDataType</code> <p>Either list of DragDataPoint objects or list of dictionaries         with 'Mach' and 'CD' keys</p> required <p>Returns:</p> Type Description <code>List[DragDataPoint]</code> <p>List of DragDataPoint objects ready for use in ballistic calculations</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If drag_table items are not DragDataPoint objects or valid        dictionaries with required keys</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def make_data_points(drag_table: DragTableDataType) -&gt; List[DragDataPoint]:\n    \"\"\"Convert drag table from list of dictionaries to list of DragDataPoints.\n\n    Handles both DragDataPoint objects and dictionaries with 'Mach' and 'CD' keys.\n    Validates input format and provides clear error messages for invalid data.\n\n    Args:\n        drag_table: Either list of DragDataPoint objects or list of dictionaries\n                    with 'Mach' and 'CD' keys\n\n    Returns:\n        List of DragDataPoint objects ready for use in ballistic calculations\n\n    Raises:\n        TypeError: If drag_table items are not DragDataPoint objects or valid\n                   dictionaries with required keys\n    \"\"\"\n    try:\n        return [\n            point if isinstance(point, DragDataPoint) else DragDataPoint(point[\"Mach\"], point[\"CD\"])\n            for point in drag_table\n        ]\n    except (KeyError, TypeError) as exc:\n        raise TypeError(\n            \"All items in drag_table must be of type DragDataPoint or dict with 'Mach' and 'CD' keys\"\n        ) from exc\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.sectional_density","title":"sectional_density","text":"<pre><code>sectional_density(weight: float, diameter: float) -&gt; float\n</code></pre> <p>Calculate sectional density of a projectile.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>float</code> <p>Projectile weight in grains</p> required <code>diameter</code> <code>float</code> <p>Projectile diameter in inches</p> required <p>Returns:</p> Type Description <code>float</code> <p>Sectional density in lb/in\u00b2 (pounds per square inch)</p> Note <p>Formula: SD = weight / (diameter\u00b2 * 7000) where 7000 converts grains to pounds (7000 grains = 1 pound)</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def sectional_density(weight: float, diameter: float) -&gt; float:\n    \"\"\"Calculate sectional density of a projectile.\n\n    Args:\n        weight: Projectile weight in grains\n        diameter: Projectile diameter in inches\n\n    Returns:\n        Sectional density in lb/in\u00b2 (pounds per square inch)\n\n    Note:\n        Formula: SD = weight / (diameter\u00b2 * 7000)\n        where 7000 converts grains to pounds (7000 grains = 1 pound)\n    \"\"\"\n    return weight / math.pow(diameter, 2) / 7000\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragModelMultiBC","title":"DragModelMultiBC","text":"<pre><code>DragModelMultiBC(\n    bc_points: List[BCPoint],\n    drag_table: DragTableDataType,\n    weight: Union[float, Weight] = 0,\n    diameter: Union[float, Distance] = 0,\n    length: Union[float, Distance] = 0,\n) -&gt; DragModel\n</code></pre> <p>Create a drag model with multiple ballistic coefficients.</p> <p>Constructs a DragModel using multiple BC measurements at different velocities, interpolating between them to create a more accurate drag function.</p> <p>Parameters:</p> Name Type Description Default <code>bc_points</code> <code>List[BCPoint]</code> <p>List of BCPoint objects with BC measurements at specific velocities</p> required <code>drag_table</code> <code>DragTableDataType</code> <p>Standard drag table (G1, G7, etc.) or custom drag data</p> required <code>weight</code> <code>Union[float, Weight]</code> <p>Projectile weight in grains (default: 0)</p> <code>0</code> <code>diameter</code> <code>Union[float, Distance]</code> <p>Projectile diameter in inches (default: 0)</p> <code>0</code> <code>length</code> <code>Union[float, Distance]</code> <p>Projectile length in inches (default: 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>DragModel</code> <p>DragModel with interpolated drag coefficients based on multiple BCs</p> Example <pre><code>from py_ballisticcalc.drag_tables import TableG7\nDragModelMultiBC([BCPoint(.21, V=Velocity.FPS(1500)), BCPoint(.22, V=Velocity.FPS(2500))],\n                 drag_table=TableG7)\n</code></pre> Note <p>If weight and diameter are provided, BC is set to sectional density. Otherwise, BC=1 and the drag_table contains final drag terms. BC points are automatically sorted by Mach number for interpolation.</p> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def DragModelMultiBC(\n    bc_points: List[BCPoint],\n    drag_table: DragTableDataType,\n    weight: Union[float, Weight] = 0,\n    diameter: Union[float, Distance] = 0,\n    length: Union[float, Distance] = 0,\n) -&gt; DragModel:\n    \"\"\"Create a drag model with multiple ballistic coefficients.\n\n    Constructs a DragModel using multiple BC measurements at different velocities,\n    interpolating between them to create a more accurate drag function.\n\n    Args:\n        bc_points: List of BCPoint objects with BC measurements at specific velocities\n        drag_table: Standard drag table (G1, G7, etc.) or custom drag data\n        weight: Projectile weight in grains (default: 0)\n        diameter: Projectile diameter in inches (default: 0)\n        length: Projectile length in inches (default: 0)\n\n    Returns:\n        DragModel with interpolated drag coefficients based on multiple BCs\n\n    Example:\n        ```python\n        from py_ballisticcalc.drag_tables import TableG7\n        DragModelMultiBC([BCPoint(.21, V=Velocity.FPS(1500)), BCPoint(.22, V=Velocity.FPS(2500))],\n                         drag_table=TableG7)\n        ```\n\n    Note:\n        If weight and diameter are provided, BC is set to sectional density.\n        Otherwise, BC=1 and the drag_table contains final drag terms.\n        BC points are automatically sorted by Mach number for interpolation.\n    \"\"\"\n    weight = PreferredUnits.weight(weight)\n    diameter = PreferredUnits.diameter(diameter)\n    if weight &gt; 0 and diameter &gt; 0:\n        bc = sectional_density(weight &gt;&gt; Weight.Grain, diameter &gt;&gt; Distance.Inch)\n    else:\n        bc = 1.0\n\n    drag_table = make_data_points(drag_table)  # Convert from list of dicts to list of DragDataPoints\n\n    bc_points.sort(key=lambda p: p.Mach)  # Make sure bc_points are sorted for linear interpolation\n    bc_interp = linear_interpolation(\n        [x.Mach for x in drag_table], [x.Mach for x in bc_points], [x.BC / bc for x in bc_points]\n    )\n\n    for i, point in enumerate(drag_table):\n        point.CD = point.CD / bc_interp[i]\n    return DragModel(bc, drag_table, weight, diameter, length)\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.linear_interpolation","title":"linear_interpolation","text":"<pre><code>linear_interpolation(\n    x: Union[List[float], Tuple[float]],\n    xp: Union[List[float], Tuple[float]],\n    yp: Union[List[float], Tuple[float]],\n) -&gt; Union[List[float], Tuple[float]]\n</code></pre> <p>Perform piecewise linear interpolation.</p> <p>Interpolates y-values for given x-values using linear interpolation between known data points. Handles extrapolation by returning boundary values for x-values outside the range of xp.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[List[float], Tuple[float]]</code> <p>List of points for which we want interpolated values</p> required <code>xp</code> <code>Union[List[float], Tuple[float]]</code> <p>List of existing x-coordinates (must be sorted in ascending order)</p> required <code>yp</code> <code>Union[List[float], Tuple[float]]</code> <p>List of corresponding y-values for existing points</p> required <p>Returns:</p> Type Description <code>Union[List[float], Tuple[float]]</code> <p>List of interpolated y-values corresponding to input x-values</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>xp</code> and <code>yp</code> lists have different lengths</p> Note <ul> <li>For x-values below <code>min(xp)</code>, returns <code>yp[0]</code></li> <li>For x-values above <code>max(xp)</code>, returns <code>yp[-1]</code></li> <li>Uses binary search for efficient interval location</li> </ul> Source code in <code>py_ballisticcalc/drag_model.py</code> <pre><code>def linear_interpolation(\n    x: Union[List[float], Tuple[float]], xp: Union[List[float], Tuple[float]], yp: Union[List[float], Tuple[float]]\n) -&gt; Union[List[float], Tuple[float]]:\n    \"\"\"Perform piecewise linear interpolation.\n\n    Interpolates y-values for given x-values using linear interpolation between known data points.\n    Handles extrapolation by returning boundary values for x-values outside the range of xp.\n\n    Args:\n        x: List of points for which we want interpolated values\n        xp: List of existing x-coordinates (must be sorted in ascending order)\n        yp: List of corresponding y-values for existing points\n\n    Returns:\n        List of interpolated y-values corresponding to input x-values\n\n    Raises:\n        AssertionError: If `xp` and `yp` lists have different lengths\n\n    Note:\n        - For x-values below `min(xp)`, returns `yp[0]`\n        - For x-values above `max(xp)`, returns `yp[-1]`\n        - Uses binary search for efficient interval location\n    \"\"\"\n    assert len(xp) == len(yp), \"xp and yp lists must have same length\"\n    # Validate xp strictly increasing to prevent zero-division and undefined intervals\n    for i in range(1, len(xp)):\n        if xp[i] &lt;= xp[i - 1]:\n            raise ValueError(\"xp must be strictly increasing with no duplicates\")\n\n    y = []\n    for xi in x:\n        if xi &lt;= xp[0]:\n            y.append(yp[0])\n        elif xi &gt;= xp[-1]:\n            y.append(yp[-1])\n        else:\n            # Binary search to find interval containing xi\n            left, right = 0, len(xp) - 1\n            while left &lt; right:\n                mid = (left + right) // 2\n                if xp[mid] &lt;= xi &lt; xp[mid + 1]:\n                    slope = (yp[mid + 1] - yp[mid]) / (xp[mid + 1] - xp[mid])\n                    y.append(yp[mid] + slope * (xi - xp[mid]))  # Interpolated value for xi\n                    break\n                if xi &lt; xp[mid]:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == right:\n                y.append(yp[left])\n    return y\n</code></pre>"},{"location":"api/drag_tables/","title":"DragTables","text":""},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables","title":"drag_tables","text":"<p>Drag tables for common projectile profiles.</p> <p>Drag tables define the relationship between Mach number and drag coefficient for specific projectile shapes, allowing accurate ballistic calculations across the full velocity range from subsonic to supersonic.</p> <p>This module provides standardized drag coefficient tables (\\(C_d\\) vs Mach number) for different projectile shapes and profiles commonly used in ballistics.</p> Standard Tables <ul> <li><code>TableG1</code>: Flat-base bullet (most common sporting ammunition)</li> <li><code>TableG7</code>: Boat-tail, spitzer (long-range match bullets)</li> <li><code>TableG2</code>: Conical, banded, boat-tail artillery projectile</li> <li><code>TableG5</code>: Round-nose, boat-tail</li> <li><code>TableG6</code>: Flat-base, spire-point</li> <li><code>TableG8</code>: Flat-base, 10 caliber secant ogive</li> <li><code>TableGI</code>: Ingalls G1</li> <li><code>TableGS</code>: 9/16\" smooth sphere</li> <li><code>TableRA4</code>: .22LR 40gr</li> </ul> Types <p>DragTablePointDictType: TypedDict for drag table data points</p> <p>Functions:</p> Name Description <code>get_drag_tables_names</code> <p>Returns list of available drag table names</p> Note <ul> <li>Drag coefficients are dimensionless and vary with velocity.</li> <li>Mach numbers typically range from 0.0 to 4.0+ for ballistic applications.</li> </ul>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables-functions","title":"Functions","text":""},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.get_drag_tables_names","title":"get_drag_tables_names","text":"<pre><code>get_drag_tables_names() -&gt; List[str]\n</code></pre> <p>List all available drag table names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of drag table names as strings (e.g., ['TableG1', 'TableG7', ...])</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tables = get_drag_tables_names()\n&gt;&gt;&gt; 'TableG1' in tables\nTrue\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.DragTablePointDictType","title":"DragTablePointDictType  <code>module-attribute</code>","text":"<pre><code>DragTablePointDictType = TypedDict(\n    \"DragTablePointDictType\", {\"Mach\": float, \"CD\": float}\n)\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableG1","title":"TableG1  <code>module-attribute</code>","text":"<pre><code>TableG1: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableG2","title":"TableG2  <code>module-attribute</code>","text":"<pre><code>TableG2: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableG5","title":"TableG5  <code>module-attribute</code>","text":"<pre><code>TableG5: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableG6","title":"TableG6  <code>module-attribute</code>","text":"<pre><code>TableG6: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableG7","title":"TableG7  <code>module-attribute</code>","text":"<pre><code>TableG7: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableG8","title":"TableG8  <code>module-attribute</code>","text":"<pre><code>TableG8: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableGI","title":"TableGI  <code>module-attribute</code>","text":"<pre><code>TableGI: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableGS","title":"TableGS  <code>module-attribute</code>","text":"<pre><code>TableGS: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/drag_tables/#py_ballisticcalc.drag_tables.TableRA4","title":"TableRA4  <code>module-attribute</code>","text":"<pre><code>TableRA4: List[DragTablePointDictType]\n</code></pre>"},{"location":"api/hit_result/","title":"HitResult","text":""},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult","title":"HitResult  <code>dataclass</code>","text":"<pre><code>HitResult(\n    props: ShotProps,\n    trajectory: list[TrajectoryData],\n    base_data: Optional[list[BaseTrajData]],\n    extra: bool = False,\n    error: Optional[RangeError] = None,\n)\n</code></pre> <p>Computed trajectory data of the shot.</p> <p>Attributes:</p> Name Type Description <code>shot</code> <p>The parameters of the shot calculation.</p> <code>trajectory</code> <code>list[TrajectoryData]</code> <p>Computed TrajectoryData points.</p> <code>base_data</code> <code>Optional[list[BaseTrajData]]</code> <p>Base trajectory data points for interpolation.</p> <code>extra</code> <code>bool</code> <p>[DEPRECATED] Whether extra_data was requested.</p> <code>error</code> <code>Optional[RangeError]</code> <p>RangeError, if any.</p> <p>Methods:</p> Name Description <code>flag</code> <p>Get first TrajectoryData row with the specified flag.</p> <code>get_at</code> <p>Get TrajectoryData where key_attribute==value.</p> <code>zeros</code> <p>Get all zero crossing points.</p> <code>index_at_distance</code> <p>Deprecated. Use get_at() instead.</p> <code>get_at_distance</code> <p>Deprecated. Use get_at('distance', d) instead.</p> <code>get_at_time</code> <p>Deprecated. Use get_at('time', t) instead.</p> <code>danger_space</code> <p>Calculate the danger space for a target.</p> <code>dataframe</code> <p>Return the trajectory table as a DataFrame.</p> <code>plot</code> <p>Return a graph of the trajectory.</p>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult-functions","title":"Functions","text":""},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.flag","title":"flag","text":"<pre><code>flag(\n    flag: Union[TrajFlag, int],\n) -&gt; Optional[TrajectoryData]\n</code></pre> <p>Get first TrajectoryData row with the specified flag.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Union[TrajFlag, int]</code> <p>The flag to search for.</p> required <p>Returns:</p> Type Description <code>Optional[TrajectoryData]</code> <p>First TrajectoryData row with the specified flag.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If flag was not requested.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def flag(self, flag: Union[TrajFlag, int]) -&gt; Optional[TrajectoryData]:\n    \"\"\"Get first TrajectoryData row with the specified flag.\n\n    Args:\n        flag: The flag to search for.\n\n    Returns:\n        First TrajectoryData row with the specified flag.\n\n    Raises:\n        AttributeError: If flag was not requested.\n    \"\"\"\n    self._check_flag(flag)\n    for row in self.trajectory:\n        if row.flag &amp; flag:\n            return row\n    return None\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.get_at","title":"get_at","text":"<pre><code>get_at(\n    key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n    value: Union[float, GenericDimension],\n    *,\n    epsilon: float = 1e-09,\n    start_from_time: float = 0.0,\n) -&gt; TrajectoryData\n</code></pre> <p>Get TrajectoryData where key_attribute==value.</p> <p>Interpolates to create new object if necessary. Preserves the units of the original trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>key_attribute</code> <code>TRAJECTORY_DATA_ATTRIBUTES</code> <p>The name of the TrajectoryData attribute to key on (e.g., 'time', 'distance').</p> required <code>value</code> <code>Union[float, GenericDimension]</code> <p>The value of the key attribute to find. If a float is provided    for a dimensioned attribute, it's assumed to be a .raw_value.</p> required <code>epsilon</code> <code>float</code> <p>Allowed key value difference to match existing TrajectoryData object without interpolating.</p> <code>1e-09</code> <code>start_from_time</code> <code>float</code> <p>The time to center the search from (default is 0.0).  If the target value is              at a local extremum then the search will only go forward in time.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>TrajectoryData where key_attribute==value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If TrajectoryData doesn't have the specified attribute.</p> <code>KeyError</code> <p>If the key_attribute is 'flag'.</p> <code>ValueError</code> <p>If interpolation is required and len(self.trajectory) &lt; 3.</p> <code>ArithmeticError</code> <p>If trajectory doesn't reach the requested value.</p> Notes <ul> <li>Not all attributes are monotonic: Height typically goes up and then down.     Velocity typically goes down, but for lofted trajectories can begin to increase.     Windage can wander back and forth in complex winds. We even have (see ExtremeExamples.ipynb)     backward-bending scenarios in which distance reverses!</li> <li>The only guarantee is that time is strictly increasing.</li> </ul> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def get_at(\n    self,\n    key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n    value: Union[float, GenericDimension],\n    *,\n    epsilon: float = 1e-9,\n    start_from_time: float = 0.0,\n) -&gt; TrajectoryData:\n    \"\"\"Get TrajectoryData where key_attribute==value.\n\n    Interpolates to create new object if necessary. Preserves the units of the original trajectory data.\n\n    Args:\n        key_attribute: The name of the TrajectoryData attribute to key on (e.g., 'time', 'distance').\n        value: The value of the key attribute to find. If a float is provided\n               for a dimensioned attribute, it's assumed to be a .raw_value.\n        epsilon: Allowed key value difference to match existing TrajectoryData object without interpolating.\n        start_from_time: The time to center the search from (default is 0.0).  If the target value is\n                         at a local extremum then the search will only go forward in time.\n\n    Returns:\n        TrajectoryData where key_attribute==value.\n\n    Raises:\n        AttributeError: If TrajectoryData doesn't have the specified attribute.\n        KeyError: If the key_attribute is 'flag'.\n        ValueError: If interpolation is required and len(self.trajectory) &lt; 3.\n        ArithmeticError: If trajectory doesn't reach the requested value.\n\n    Notes:\n        * Not all attributes are monotonic: Height typically goes up and then down.\n            Velocity typically goes down, but for lofted trajectories can begin to increase.\n            Windage can wander back and forth in complex winds. We even have (see ExtremeExamples.ipynb)\n            backward-bending scenarios in which distance reverses!\n        * The only guarantee is that time is strictly increasing.\n    \"\"\"\n    key_attribute = TRAJECTORY_DATA_SYNONYMS.get(key_attribute, key_attribute)  # Resolve synonyms\n    if not hasattr(TrajectoryData, key_attribute):\n        raise AttributeError(f\"TrajectoryData has no attribute '{key_attribute}'\")\n    if key_attribute == \"flag\":\n        raise KeyError(\"Cannot interpolate based on 'flag' attribute\")\n\n    traj = self.trajectory\n    n = len(traj)\n    key_value = value.raw_value if isinstance(value, GenericDimension) else value\n\n    def get_key_val(td):\n        \"\"\"Helper to get the raw value of the key attribute from a TrajectoryData point.\"\"\"\n        val = getattr(td, key_attribute)\n        return val.raw_value if hasattr(val, \"raw_value\") else val\n\n    if n &lt; 3:  # We won't interpolate on less than 3 points, but check for an exact match in the existing rows.\n        if abs(get_key_val(traj[0]) - key_value) &lt; epsilon:\n            return traj[0]\n        if n &gt; 1 and abs(get_key_val(traj[1]) - key_value) &lt; epsilon:\n            return traj[1]\n        raise ValueError(\"Interpolation requires at least 3 TrajectoryData points.\")\n\n    # Find the starting index based on start_from_time\n    start_idx = 0\n    if start_from_time &gt; 0:\n        start_idx = next((i for i, td in enumerate(traj) if td.time &gt;= start_from_time), 0)\n    curr_val = get_key_val(traj[start_idx])\n    if abs(curr_val - key_value) &lt; epsilon:  # Check for exact match\n        return traj[start_idx]\n    # Determine search direction from the starting point\n    search_forward = True  # Default to forward search\n    if start_idx == n - 1:  # We're at the last point, search backwards\n        search_forward = False\n    if 0 &lt; start_idx &lt; n - 1:\n        # We're in the middle of the trajectory, determine local direction towards key_value\n        next_val = get_key_val(traj[start_idx + 1])\n        if (next_val &gt; curr_val and key_value &gt; curr_val) or (next_val &lt; curr_val and key_value &lt; curr_val):\n            search_forward = True\n        else:\n            search_forward = False\n\n    # Search for the target value in the determined direction\n    target_idx = -1\n    if search_forward:  # Search forward from start_idx\n        for i in range(start_idx, n - 1):\n            curr_val = get_key_val(traj[i])\n            next_val = get_key_val(traj[i + 1])\n            # Check if key_value is between curr_val and next_val\n            if (curr_val &lt; key_value &lt;= next_val) or (next_val &lt;= key_value &lt; curr_val):\n                target_idx = i + 1\n                break\n    if not search_forward or target_idx == -1:  # Search backward from start_idx\n        for i in range(start_idx, 0, -1):\n            curr_val = get_key_val(traj[i])\n            prev_val = get_key_val(traj[i - 1])\n            # Check if key_value is between prev_val and curr_val\n            if (prev_val &lt;= key_value &lt; curr_val) or (curr_val &lt; key_value &lt;= prev_val):\n                target_idx = i\n                break\n\n    # Check if we found a valid index\n    if target_idx == -1:\n        raise ArithmeticError(f\"Trajectory does not reach {key_attribute} = {value}\")\n    # Check for exact match here\n    if abs(get_key_val(traj[target_idx]) - key_value) &lt; epsilon:\n        return traj[target_idx]\n    if target_idx == 0:  # Step forward from first point so we can interpolate\n        target_idx = 1\n    # Choose three bracketing points (p0, p1, p2)\n    if target_idx &gt;= n - 1:  # At or after the last point\n        p0, p1, p2 = traj[n - 3], traj[n - 2], traj[n - 1]\n    else:\n        p0, p1, p2 = traj[target_idx - 1], traj[target_idx], traj[target_idx + 1]\n    return TrajectoryData.interpolate(key_attribute, value, p0, p1, p2)\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.zeros","title":"zeros","text":"<pre><code>zeros() -&gt; list[TrajectoryData]\n</code></pre> <p>Get all zero crossing points.</p> <p>Returns:</p> Type Description <code>list[TrajectoryData]</code> <p>Zero crossing points.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If extra_data was not requested.</p> <code>ArithmeticError</code> <p>If zero crossing points are not found.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def zeros(self) -&gt; list[TrajectoryData]:\n    \"\"\"Get all zero crossing points.\n\n    Returns:\n        Zero crossing points.\n\n    Raises:\n        AttributeError: If extra_data was not requested.\n        ArithmeticError: If zero crossing points are not found.\n    \"\"\"\n    self._check_flag(TrajFlag.ZERO)\n    data = [row for row in self.trajectory if row.flag &amp; TrajFlag.ZERO]\n    if len(data) &lt; 1:\n        raise ArithmeticError(\"Can't find zero crossing points\")\n    return data\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.index_at_distance","title":"index_at_distance","text":"<pre><code>index_at_distance(d: Distance) -&gt; int\n</code></pre> <p>Deprecated. Use get_at() instead.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Distance</code> <p>Distance for which we want Trajectory Data.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of first trajectory row with .distance &gt;= d; otherwise -1.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use get_at() instead for better flexibility.\")\ndef index_at_distance(self, d: Distance) -&gt; int:\n    \"\"\"Deprecated. Use get_at() instead.\n\n    Args:\n        d: Distance for which we want Trajectory Data.\n\n    Returns:\n        Index of first trajectory row with .distance &gt;= d; otherwise -1.\n    \"\"\"\n    epsilon = 1e-1  # small value to avoid floating point issues\n    return next(\n        (i for i in range(len(self.trajectory)) if self.trajectory[i].distance.raw_value &gt;= d.raw_value - epsilon),\n        -1,\n    )\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.get_at_distance","title":"get_at_distance","text":"<pre><code>get_at_distance(d: Distance) -&gt; TrajectoryData\n</code></pre> <p>Deprecated. Use get_at('distance', d) instead.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Distance</code> <p>Distance for which we want Trajectory Data.</p> required <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>First trajectory row with .distance &gt;= d.</p> <p>Raises:</p> Type Description <code>ArithmeticError</code> <p>If trajectory doesn't reach requested distance.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use get_at('distance', d)\")\ndef get_at_distance(self, d: Distance) -&gt; TrajectoryData:\n    \"\"\"Deprecated. Use get_at('distance', d) instead.\n\n    Args:\n        d: Distance for which we want Trajectory Data.\n\n    Returns:\n        First trajectory row with .distance &gt;= d.\n\n    Raises:\n        ArithmeticError: If trajectory doesn't reach requested distance.\n    \"\"\"\n    if (i := self.index_at_distance(d)) &lt; 0:\n        raise ArithmeticError(f\"Calculated trajectory doesn't reach requested distance {d}\")\n    return self.trajectory[i]\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.get_at_time","title":"get_at_time","text":"<pre><code>get_at_time(t: float) -&gt; TrajectoryData\n</code></pre> <p>Deprecated. Use get_at('time', t) instead.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time for which we want Trajectory Data.</p> required <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>First trajectory row with .time &gt;= t.</p> <p>Raises:</p> Type Description <code>ArithmeticError</code> <p>If trajectory doesn't reach requested time.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use get_at('time', t)\")\ndef get_at_time(self, t: float) -&gt; TrajectoryData:\n    \"\"\"Deprecated. Use get_at('time', t) instead.\n\n    Args:\n        t: Time for which we want Trajectory Data.\n\n    Returns:\n        First trajectory row with .time &gt;= t.\n\n    Raises:\n        ArithmeticError: If trajectory doesn't reach requested time.\n    \"\"\"\n    epsilon = 1e-6  # small value to avoid floating point issues\n    idx = next((i for i in range(len(self.trajectory)) if self.trajectory[i].time &gt;= t - epsilon), -1)\n    if idx &lt; 0:\n        raise ArithmeticError(f\"Calculated trajectory doesn't reach requested time {t}\")\n    return self.trajectory[idx]\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.danger_space","title":"danger_space","text":"<pre><code>danger_space(\n    at_range: Union[float, Distance],\n    target_height: Union[float, Distance],\n) -&gt; DangerSpace\n</code></pre> <p>Calculate the danger space for a target.</p> <pre><code>Assumes that the trajectory hits the center of a target at any distance.\nDetermines how much ranging error can be tolerated if the critical region\nof the target has target_height *h*. Finds how far forward and backward along the\nline of sight a target can move such that the trajectory is still within *h*/2\nof the original drop at_range.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>at_range</code> <code>Union[float, Distance]</code> <p>Danger space is calculated for a target centered at this sight distance.</p> required <code>target_height</code> <code>Union[float, Distance]</code> <p>Target height (h) determines danger space.</p> required <p>Returns:</p> Name Type Description <code>DangerSpace</code> <code>DangerSpace</code> <p>The calculated danger space.</p> <p>Raises:</p> Type Description <code>ArithmeticError</code> <p>If trajectory doesn't reach requested distance.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def danger_space(\n    self,\n    at_range: Union[float, Distance],\n    target_height: Union[float, Distance],\n) -&gt; DangerSpace:\n    \"\"\"Calculate the danger space for a target.\n\n        Assumes that the trajectory hits the center of a target at any distance.\n        Determines how much ranging error can be tolerated if the critical region\n        of the target has target_height *h*. Finds how far forward and backward along the\n        line of sight a target can move such that the trajectory is still within *h*/2\n        of the original drop at_range.\n\n    Args:\n        at_range: Danger space is calculated for a target centered at this sight distance.\n        target_height: Target height (*h*) determines danger space.\n\n    Returns:\n        DangerSpace: The calculated danger space.\n\n    Raises:\n        ArithmeticError: If trajectory doesn't reach requested distance.\n    \"\"\"\n    target_at_range = PreferredUnits.distance(at_range)\n    target_height = PreferredUnits.target_height(target_height)\n    target_height_half = target_height.raw_value / 2.0\n\n    target_row = self.get_at(\"slant_distance\", target_at_range)\n    is_climbing = ((target_row.angle &gt;&gt; Angular.Radian) - self.props.look_angle_rad) &gt; 0\n    slant_height_begin = target_row.slant_height.raw_value + (-1 if is_climbing else 1) * target_height_half\n    slant_height_end = target_row.slant_height.raw_value - (-1 if is_climbing else 1) * target_height_half\n    try:\n        begin_row = self.get_at(\"slant_height\", slant_height_begin, start_from_time=target_row.time)\n    except ArithmeticError:\n        begin_row = self.trajectory[0]\n    try:\n        end_row = self.get_at(\"slant_height\", slant_height_end, start_from_time=target_row.time)\n    except ArithmeticError:\n        end_row = self.trajectory[-1]\n\n    return DangerSpace(target_row, target_height, begin_row, end_row, Angular.Radian(self.props.look_angle_rad))\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.dataframe","title":"dataframe","text":"<pre><code>dataframe(formatted: bool = False) -&gt; DataFrame\n</code></pre> <p>Return the trajectory table as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>formatted</code> <code>bool</code> <p>False for values as floats; True for strings in PreferredUnits. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The trajectory table as a DataFrame.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If pandas or plotting dependencies are not installed.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def dataframe(self, formatted: bool = False) -&gt; DataFrame:\n    \"\"\"Return the trajectory table as a DataFrame.\n\n    Args:\n        formatted: False for values as floats; True for strings in PreferredUnits. Default is False.\n\n    Returns:\n        The trajectory table as a DataFrame.\n\n    Raises:\n        ImportError: If pandas or plotting dependencies are not installed.\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.dataframe import hit_result_as_dataframe\n\n        return hit_result_as_dataframe(self, formatted)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get trajectory as pandas.DataFrame\"\n        ) from err\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.HitResult.plot","title":"plot","text":"<pre><code>plot(look_angle: Optional[Angular] = None) -&gt; Axes\n</code></pre> <p>Return a graph of the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>look_angle</code> <code>Optional[Angular]</code> <p>Look angle for the plot. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The plot Axes object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If plotting dependencies are not installed.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def plot(self, look_angle: Optional[Angular] = None) -&gt; Axes:\n    \"\"\"Return a graph of the trajectory.\n\n    Args:\n        look_angle (Optional[Angular], optional): Look angle for the plot. Defaults to None.\n\n    Returns:\n        The plot Axes object.\n\n    Raises:\n        ImportError: If plotting dependencies are not installed.\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.plot import hit_result_as_plot  # type: ignore[attr-defined]\n\n        return hit_result_as_plot(self, look_angle)\n    except ImportError as err:\n        raise ImportError(\"Use `pip install py_ballisticcalc[charts]` to get results as a plot\") from err\n</code></pre>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.DangerSpace","title":"DangerSpace","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Stores the danger space data for distance specified.</p> <p>Methods:</p> Name Description <code>overlay</code> <p>Highlights danger-space region on plot.</p>"},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.DangerSpace-functions","title":"Functions","text":""},{"location":"api/hit_result/#py_ballisticcalc.trajectory_data.DangerSpace.overlay","title":"overlay","text":"<pre><code>overlay(ax: Axes, label: Optional[str] = None) -&gt; None\n</code></pre> <p>Highlights danger-space region on plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to overlay on.</p> required <code>label</code> <code>Optional[str]</code> <p>Label for the overlay. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If plotting dependencies are not installed.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def overlay(self, ax: Axes, label: Optional[str] = None) -&gt; None:\n    \"\"\"Highlights danger-space region on plot.\n\n    Args:\n        ax: The axes to overlay on.\n        label: Label for the overlay. Defaults to None.\n\n    Raises:\n        ImportError: If plotting dependencies are not installed.\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.plot import add_danger_space_overlay  # type: ignore[attr-defined]\n\n        add_danger_space_overlay(self, ax, label)\n    except ImportError as err:\n        raise ImportError(\"Use `pip install py_ballisticcalc[charts]` to get results as a plot\") from err\n</code></pre>"},{"location":"api/trajectory_data/","title":"TrajectoryData","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag","title":"TrajFlag","text":"<p>               Bases: <code>int</code></p> <p>Trajectory point classification flags for marking special trajectory events.</p> <p>Provides enumeration values for identifying and filtering special points in ballistic trajectories. The flags can be combined using bitwise operations.</p> Flag Values <ul> <li>NONE (0): Standard trajectory point with no special events</li> <li>ZERO_UP (1): Upward zero crossing (trajectory rising through sight line)</li> <li>ZERO_DOWN (2): Downward zero crossing (trajectory falling through sight line)</li> <li>ZERO (3): Any zero crossing (ZERO_UP | ZERO_DOWN)</li> <li>MACH (4): Mach 1 transition point (sound barrier crossing)</li> <li>RANGE (8): User requested point, typically by distance or time step</li> <li>APEX (16): Trajectory apex (maximum height point)</li> <li>ALL (31): All special points (combination of all above flags)</li> <li>MRT (32): Mid-Range Trajectory/Maximum Ordinate (largest slant height) [PROPOSED]</li> </ul> <p>Examples:</p> <p>Basic flag usage:</p> <pre><code>from py_ballisticcalc.trajectory_data import TrajFlag\n\n# Filter for zero crossings only\nflags = TrajFlag.ZERO\n\n# Filter for multiple event types\nflags = TrajFlag.ZERO | TrajFlag.APEX | TrajFlag.MACH\n\n# Filter for all special points\nflags = TrajFlag.ALL\n\n# Check if a trajectory point has specific flags\nif point.flag &amp; TrajFlag.APEX:\n    print(\"Trajectory apex\")\n</code></pre> <p>Trajectory calculation with flags:</p> <pre><code># Calculate trajectory with zero crossings and apex\nhit_result = calc.fire(shot, 1000, filter_flags=TrajFlag.ZERO | TrajFlag.APEX)\n\n# Find all zero crossing points\nzeros = [p for p in hit_result.trajectory if p.flag &amp; TrajFlag.ZERO]\n\n# Find apex point\napex = next((p for p in hit_result.trajectory if p.flag &amp; TrajFlag.APEX), None)\n</code></pre> <p>Methods:</p> Name Description <code>name</code> <p>Get the human-readable name for a trajectory flag value.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag-functions","title":"Functions","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag.name","title":"name  <code>staticmethod</code>","text":"<pre><code>name(value: Union[int, TrajFlag]) -&gt; str\n</code></pre> <p>Get the human-readable name for a trajectory flag value.</p> <p>Converts a numeric flag value to its corresponding string name for display, logging, or debugging purposes. Supports both individual flags and combined flag values with intelligent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, TrajFlag]</code> <p>The TrajFlag enum value or integer flag to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String name of the flag. For combined flags, returns names joined with \"|\". For unknown flags, returns \"UNKNOWN\". Special handling for ZERO flag combinations.</p> <p>Examples:</p> <pre><code># Individual flag names\nprint(TrajFlag.name(TrajFlag.ZERO))      # \"ZERO\"\nprint(TrajFlag.name(TrajFlag.APEX))      # \"APEX\"\n\n# Combined flags\ncombined = TrajFlag.ZERO | TrajFlag.APEX\nprint(TrajFlag.name(combined))           # \"ZERO|APEX\"\n\n# Unknown flags\nprint(TrajFlag.name(999))                # \"UNKNOWN\"\n</code></pre> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef name(value: Union[int, TrajFlag]) -&gt; str:\n    \"\"\"Get the human-readable name for a trajectory flag value.\n\n    Converts a numeric flag value to its corresponding string name for\n    display, logging, or debugging purposes. Supports both individual\n    flags and combined flag values with intelligent formatting.\n\n    Args:\n        value: The TrajFlag enum value or integer flag to convert.\n\n    Returns:\n        String name of the flag. For combined flags, returns names joined with \"|\".\n            For unknown flags, returns \"UNKNOWN\". Special handling for ZERO flag combinations.\n\n    Examples:\n        ```python\n        # Individual flag names\n        print(TrajFlag.name(TrajFlag.ZERO))      # \"ZERO\"\n        print(TrajFlag.name(TrajFlag.APEX))      # \"APEX\"\n\n        # Combined flags\n        combined = TrajFlag.ZERO | TrajFlag.APEX\n        print(TrajFlag.name(combined))           # \"ZERO|APEX\"\n\n        # Unknown flags\n        print(TrajFlag.name(999))                # \"UNKNOWN\"\n        ```\n    \"\"\"\n    v = int(value)\n    mapping = TrajFlag._value_to_name()\n    if v in mapping:\n        return mapping[v]\n    parts = [mapping[bit] for bit in sorted(mapping) if bit and (v &amp; bit) == bit]\n    if \"ZERO_UP\" in parts and \"ZERO_DOWN\" in parts:\n        parts.remove(\"ZERO_UP\")\n        parts.remove(\"ZERO_DOWN\")\n    return \"|\".join(parts) if parts else \"UNKNOWN\"\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.BaseTrajData","title":"BaseTrajData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Minimal ballistic trajectory point data.</p> <p>Represents the minimum state information for a single point in a ballistic trajectory. The data are kept in basic units (seconds, feet) to avoid unit tracking and conversion overhead.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>float</code> <p>Time since projectile launch in seconds.</p> <code>position</code> <code>Vector</code> <p>3D position vector in feet (x=downrange, y=height, z=windage).</p> <code>velocity</code> <code>Vector</code> <p>3D velocity vector in feet per second.</p> <code>mach</code> <code>float</code> <p>Local speed of sound in feet per second.</p> <p>Examples:</p> <pre><code>from py_ballisticcalc.vector import Vector\n\n# Create trajectory point at launch\nlaunch_pt = BaseTrajData(\n    time=0.0,\n    position=Vector(0.0, -0.1, 0.0),   # 0.1 ft scope height\n    velocity=Vector(2640.0, 0.0, 0.0), # 800 m/s \u2248 2640 fps\n    mach=1115.5                        # Standard conditions\n)\n\n# Interpolate between points\ninterpolated = BaseTrajData.interpolate('time', 1.25, launch_pt, mid_pt, end_pt)\n</code></pre> Note <p>This class is designed for efficiency in calculation engines that may compute thousands of points over a trajectory. For detailed data with units and derived quantities, use TrajectoryData which can be constructed from BaseTrajData using from_base_data().</p> <p>Methods:</p> Name Description <code>interpolate</code> <p>Interpolate a BaseTrajData point using monotone PCHIP (default) or linear.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.BaseTrajData-functions","title":"Functions","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.BaseTrajData.interpolate","title":"interpolate  <code>staticmethod</code>","text":"<pre><code>interpolate(\n    key_attribute: str,\n    key_value: float,\n    p0: BaseTrajData,\n    p1: BaseTrajData,\n    p2: BaseTrajData,\n    method: InterpolationMethod = \"pchip\",\n) -&gt; BaseTrajData\n</code></pre> <p>Interpolate a BaseTrajData point using monotone PCHIP (default) or linear.</p> <p>Parameters:</p> Name Type Description Default <code>key_attribute</code> <code>str</code> <p>Can be 'time', 'mach', or a vector component like 'position.x' or 'velocity.z'.</p> required <code>key_value</code> <code>float</code> <p>The value to interpolate for.</p> required <code>p0</code> <code>BaseTrajData</code> <p>First bracketing point.</p> required <code>p1</code> <code>BaseTrajData</code> <p>Second (middle) bracketing point.</p> required <code>p2</code> <code>BaseTrajData</code> <p>Third bracketing point.</p> required <code>method</code> <code>InterpolationMethod</code> <p>'pchip' (default, monotone cubic Hermite) or 'linear'.</p> <code>'pchip'</code> <p>Returns:</p> Type Description <code>BaseTrajData</code> <p>The interpolated data point.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the key_attribute is not a member of BaseTrajData.</p> <code>ZeroDivisionError</code> <p>If the interpolation fails due to zero division.                (This will result if two of the points are identical).</p> <code>ValueError</code> <p>If method is not one of 'pchip' or 'linear'.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef interpolate(\n    key_attribute: str,\n    key_value: float,\n    p0: BaseTrajData,\n    p1: BaseTrajData,\n    p2: BaseTrajData,\n    method: InterpolationMethod = \"pchip\",\n) -&gt; BaseTrajData:\n    \"\"\"\n    Interpolate a BaseTrajData point using monotone PCHIP (default) or linear.\n\n    Args:\n        key_attribute: Can be 'time', 'mach', or a vector component like 'position.x' or 'velocity.z'.\n        key_value: The value to interpolate for.\n        p0: First bracketing point.\n        p1: Second (middle) bracketing point.\n        p2: Third bracketing point.\n        method: 'pchip' (default, monotone cubic Hermite) or 'linear'.\n\n    Returns:\n        The interpolated data point.\n\n    Raises:\n        AttributeError: If the key_attribute is not a member of BaseTrajData.\n        ZeroDivisionError: If the interpolation fails due to zero division.\n                           (This will result if two of the points are identical).\n        ValueError: If method is not one of 'pchip' or 'linear'.\n    \"\"\"\n\n    def get_key_val(td: \"BaseTrajData\", path: str) -&gt; float:\n        \"\"\"Helper to get the key value from a BaseTrajData point.\"\"\"\n        if \".\" in path:\n            top, component = path.split(\".\", 1)\n            obj = getattr(td, top)\n            return getattr(obj, component)\n        return getattr(td, path)\n\n    # independent variable values\n    x0 = get_key_val(p0, key_attribute)\n    x1 = get_key_val(p1, key_attribute)\n    x2 = get_key_val(p2, key_attribute)\n\n    def _interp_scalar(y0, y1, y2):\n        if method == \"pchip\":\n            return interpolate_3_pt(key_value, x0, y0, x1, y1, x2, y2)\n        elif method == \"linear\":\n            pts = sorted(((x0, y0), (x1, y1), (x2, y2)), key=lambda p: p[0])\n            (sx0, sy0), (sx1, sy1), (sx2, sy2) = pts\n            if key_value &lt;= sx1:\n                return interpolate_2_pt(key_value, sx0, sy0, sx1, sy1)\n            else:\n                return interpolate_2_pt(key_value, sx1, sy1, sx2, sy2)\n        else:\n            raise ValueError(\"method must be 'pchip' or 'linear'\")\n\n    time = _interp_scalar(p0.time, p1.time, p2.time) if key_attribute != \"time\" else key_value\n    px = _interp_scalar(p0.position.x, p1.position.x, p2.position.x)\n    py = _interp_scalar(p0.position.y, p1.position.y, p2.position.y)\n    pz = _interp_scalar(p0.position.z, p1.position.z, p2.position.z)\n    position = Vector(px, py, pz)\n    vx = _interp_scalar(p0.velocity.x, p1.velocity.x, p2.velocity.x)\n    vy = _interp_scalar(p0.velocity.y, p1.velocity.y, p2.velocity.y)\n    vz = _interp_scalar(p0.velocity.z, p1.velocity.z, p2.velocity.z)\n    velocity = Vector(vx, vy, vz)\n    mach = _interp_scalar(p0.mach, p1.mach, p2.mach) if key_attribute != \"mach\" else key_value\n\n    return BaseTrajData(time=time, position=position, velocity=velocity, mach=mach)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData","title":"TrajectoryData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Data for one point in ballistic trajectory.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>float</code> <p>Flight time in seconds</p> <code>distance</code> <code>Distance</code> <p>Down-range (x-axis) coordinate of this point</p> <code>velocity</code> <code>Velocity</code> <p>Velocity vector at this point</p> <code>mach</code> <code>float</code> <p>Velocity in Mach terms</p> <code>height</code> <code>Distance</code> <p>Vertical (y-axis) coordinate of this point</p> <code>slant_height</code> <code>Distance</code> <p>Distance orthogonal to sight-line</p> <code>drop_angle</code> <code>Angular</code> <p>Slant_height in angular term</p> <code>windage</code> <code>Distance</code> <p>Windage (z-axis) coordinate of this point</p> <code>windage_angle</code> <code>Angular</code> <p>Windage in angular terms</p> <code>slant_distance</code> <code>Distance</code> <p>Distance along sight line that is closest to this point</p> <code>angle</code> <code>Angular</code> <p>Angle of velocity vector relative to x-axis</p> <code>density_ratio</code> <code>float</code> <p>Ratio of air density here to standard density</p> <code>drag</code> <code>float</code> <p>Standard Drag Factor at this point</p> <code>energy</code> <code>Energy</code> <p>Energy of bullet at this point</p> <code>ogw</code> <code>Weight</code> <p>Optimal game weight, given .energy</p> <code>flag</code> <code>Union[TrajFlag, int]</code> <p>Row type (TrajFlag)</p> <p>Methods:</p> Name Description <code>look_distance</code> <p>Synonym for slant_distance.</p> <code>formatted</code> <p>Return attributes as tuple of strings, formatted per PreferredUnits.</p> <code>in_def_units</code> <p>Return attributes as tuple of floats converting to PreferredUnits.</p> <code>get_correction</code> <p>Calculate the sight adjustment in radians.</p> <code>calculate_energy</code> <p>Calculate the kinetic energy of a projectile.</p> <code>calculate_ogw</code> <p>Calculate the optimal game weight for a projectile.</p> <code>from_base_data</code> <p>Create a TrajectoryData object from BaseTrajData.</p> <code>from_props</code> <p>Create a TrajectoryData object.</p> <code>interpolate</code> <p>Interpolate TrajectoryData where key_attribute==value using PCHIP (default) or linear.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData-attributes","title":"Attributes","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.x","title":"x  <code>property</code>","text":"<pre><code>x: Distance\n</code></pre> <p>Synonym for .distance.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.y","title":"y  <code>property</code>","text":"<pre><code>y: Distance\n</code></pre> <p>Synonym for .height.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.z","title":"z  <code>property</code>","text":"<pre><code>z: Distance\n</code></pre> <p>Synonym for .windage.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.target_drop","title":"target_drop  <code>property</code>","text":"<pre><code>target_drop: Distance\n</code></pre> <p>Synonym for slant_height.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.drop_adj","title":"drop_adj  <code>property</code>","text":"<pre><code>drop_adj: Angular\n</code></pre> <p>Synonym for drop_angle.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.windage_adj","title":"windage_adj  <code>property</code>","text":"<pre><code>windage_adj: Angular\n</code></pre> <p>Synonym for windage_angle.</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData-functions","title":"Functions","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.look_distance","title":"look_distance","text":"<pre><code>look_distance() -&gt; Distance\n</code></pre> <p>Synonym for slant_distance.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@deprecated(reason=\"Use .slant_distance instead of .look_distance\", version=\"2.2.0\")\ndef look_distance(self) -&gt; Distance:\n    \"\"\"Synonym for slant_distance.\"\"\"\n    return self.slant_distance\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.formatted","title":"formatted","text":"<pre><code>formatted() -&gt; Tuple[str, ...]\n</code></pre> <p>Return attributes as tuple of strings, formatted per PreferredUnits.</p> <p>Returns:</p> Type Description <code>Tuple[str, ...]</code> <p>Tuple of formatted strings for this point, in PreferredUnits.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def formatted(self) -&gt; Tuple[str, ...]:\n    \"\"\"Return attributes as tuple of strings, formatted per PreferredUnits.\n\n    Returns:\n        Tuple of formatted strings for this point, in PreferredUnits.\n    \"\"\"\n\n    def _fmt(v: GenericDimension, u: Unit) -&gt; str:\n        \"\"\"Format Dimension as a string.\"\"\"\n        return f\"{v &gt;&gt; u:.{u.accuracy}f} {u.symbol}\"\n\n    return (\n        f\"{self.time:.3f} s\",\n        _fmt(self.distance, PreferredUnits.distance),\n        _fmt(self.velocity, PreferredUnits.velocity),\n        f\"{self.mach:.2f} mach\",\n        _fmt(self.height, PreferredUnits.drop),\n        _fmt(self.slant_height, PreferredUnits.drop),\n        _fmt(self.drop_angle, PreferredUnits.adjustment),\n        _fmt(self.windage, PreferredUnits.drop),\n        _fmt(self.windage_angle, PreferredUnits.adjustment),\n        _fmt(self.slant_distance, PreferredUnits.distance),\n        _fmt(self.angle, PreferredUnits.angular),\n        f\"{self.density_ratio:.5e}\",\n        f\"{self.drag:.3e}\",\n        _fmt(self.energy, PreferredUnits.energy),\n        _fmt(self.ogw, PreferredUnits.ogw),\n        TrajFlag.name(self.flag),\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.in_def_units","title":"in_def_units","text":"<pre><code>in_def_units() -&gt; Tuple[float, ...]\n</code></pre> <p>Return attributes as tuple of floats converting to PreferredUnits.</p> <p>Returns:</p> Type Description <code>Tuple[float, ...]</code> <p>Tuple of floats describing this point, in PreferredUnits.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>def in_def_units(self) -&gt; Tuple[float, ...]:\n    \"\"\"Return attributes as tuple of floats converting to PreferredUnits.\n\n    Returns:\n        Tuple of floats describing this point, in PreferredUnits.\n    \"\"\"\n    return (\n        self.time,\n        self.distance &gt;&gt; PreferredUnits.distance,\n        self.velocity &gt;&gt; PreferredUnits.velocity,\n        self.mach,\n        self.height &gt;&gt; PreferredUnits.drop,\n        self.slant_height &gt;&gt; PreferredUnits.drop,\n        self.drop_angle &gt;&gt; PreferredUnits.adjustment,\n        self.windage &gt;&gt; PreferredUnits.drop,\n        self.windage_angle &gt;&gt; PreferredUnits.adjustment,\n        self.slant_distance &gt;&gt; PreferredUnits.distance,\n        self.angle &gt;&gt; PreferredUnits.angular,\n        self.density_ratio,\n        self.drag,\n        self.energy &gt;&gt; PreferredUnits.energy,\n        self.ogw &gt;&gt; PreferredUnits.ogw,\n        self.flag,\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.get_correction","title":"get_correction  <code>staticmethod</code>","text":"<pre><code>get_correction(distance: float, offset: float) -&gt; float\n</code></pre> <p>Calculate the sight adjustment in radians.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance to the target in feet.</p> required <code>offset</code> <code>float</code> <p>The offset from the target in feet.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sight adjustment in radians.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef get_correction(distance: float, offset: float) -&gt; float:\n    \"\"\"Calculate the sight adjustment in radians.\n\n    Args:\n        distance: The distance to the target in feet.\n        offset: The offset from the target in feet.\n\n    Returns:\n        The sight adjustment in radians.\n    \"\"\"\n    if distance != 0:\n        return math.atan(offset / distance)\n    return 0  # None\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.calculate_energy","title":"calculate_energy  <code>staticmethod</code>","text":"<pre><code>calculate_energy(\n    bullet_weight: float, velocity: float\n) -&gt; float\n</code></pre> <p>Calculate the kinetic energy of a projectile.</p> <p>Parameters:</p> Name Type Description Default <code>bullet_weight</code> <code>float</code> <p>Projectile weight in grains.</p> required <code>velocity</code> <code>float</code> <p>Projectile velocity in feet per second.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Kinetic energy in foot-pounds (ft\u00b7lbf).</p> Notes <p>Uses the standard small-arms approximation: E(ft\u00b7lbf) = weight(grains) * v(fps)^2 / 450400.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef calculate_energy(bullet_weight: float, velocity: float) -&gt; float:\n    \"\"\"Calculate the kinetic energy of a projectile.\n\n    Args:\n        bullet_weight: Projectile weight in grains.\n        velocity: Projectile velocity in feet per second.\n\n    Returns:\n        Kinetic energy in foot-pounds (ft\u00b7lbf).\n\n    Notes:\n        Uses the standard small-arms approximation:\n        E(ft\u00b7lbf) = weight(grains) * v(fps)^2 / 450400.\n    \"\"\"\n    return bullet_weight * math.pow(velocity, 2) / 450400\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.calculate_ogw","title":"calculate_ogw  <code>staticmethod</code>","text":"<pre><code>calculate_ogw(\n    bullet_weight: float, velocity: float\n) -&gt; float\n</code></pre> <p>Calculate the optimal game weight for a projectile.</p> <p>Parameters:</p> Name Type Description Default <code>bullet_weight</code> <code>float</code> <p>Bullet weight in grains (per common OGW formula).</p> required <code>velocity</code> <code>float</code> <p>Projectile velocity in feet per second.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The optimal game weight in pounds.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef calculate_ogw(bullet_weight: float, velocity: float) -&gt; float:\n    \"\"\"Calculate the optimal game weight for a projectile.\n\n    Args:\n        bullet_weight: Bullet weight in grains (per common OGW formula).\n        velocity: Projectile velocity in feet per second.\n\n    Returns:\n        The optimal game weight in pounds.\n    \"\"\"\n    return math.pow(bullet_weight, 2) * math.pow(velocity, 3) * 1.5e-12\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.from_base_data","title":"from_base_data  <code>staticmethod</code>","text":"<pre><code>from_base_data(\n    props: ShotProps,\n    data: BaseTrajData,\n    flag: Union[TrajFlag, int] = NONE,\n) -&gt; TrajectoryData\n</code></pre> <p>Create a TrajectoryData object from BaseTrajData.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef from_base_data(\n    props: ShotProps, data: BaseTrajData, flag: Union[TrajFlag, int] = TrajFlag.NONE\n) -&gt; TrajectoryData:\n    \"\"\"Create a TrajectoryData object from BaseTrajData.\"\"\"\n    return TrajectoryData.from_props(props, data.time, data.position, data.velocity, data.mach, flag)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.from_props","title":"from_props  <code>staticmethod</code>","text":"<pre><code>from_props(\n    props: ShotProps,\n    time: float,\n    range_vector: Vector,\n    velocity_vector: Vector,\n    mach: float,\n    flag: Union[TrajFlag, int] = NONE,\n) -&gt; TrajectoryData\n</code></pre> <p>Create a TrajectoryData object.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef from_props(\n    props: ShotProps,\n    time: float,\n    range_vector: Vector,\n    velocity_vector: Vector,\n    mach: float,\n    flag: Union[TrajFlag, int] = TrajFlag.NONE,\n) -&gt; TrajectoryData:\n    \"\"\"Create a TrajectoryData object.\"\"\"\n    adjusted_range = props.adjust_range_for_coriolis(time, range_vector)\n    spin_drift = props.spin_drift(time)\n    velocity = velocity_vector.magnitude()\n    windage = adjusted_range.z + spin_drift\n    drop_angle = TrajectoryData.get_correction(adjusted_range.x, adjusted_range.y)\n    windage_angle = TrajectoryData.get_correction(adjusted_range.x, windage)\n    trajectory_angle = math.atan2(velocity_vector.y, velocity_vector.x)\n    look_angle_cos = math.cos(props.look_angle_rad)\n    look_angle_sin = math.sin(props.look_angle_rad)\n    density_ratio, _ = props.get_density_and_mach_for_altitude(range_vector.y)\n    drag = props.drag_by_mach(velocity / mach)\n    return TrajectoryData(\n        time=time,\n        distance=TrajectoryData._new_feet(adjusted_range.x),\n        velocity=TrajectoryData._new_fps(velocity),\n        mach=velocity / mach,\n        height=TrajectoryData._new_feet(adjusted_range.y),\n        slant_height=TrajectoryData._new_feet(\n            adjusted_range.y * look_angle_cos - adjusted_range.x * look_angle_sin\n        ),\n        drop_angle=TrajectoryData._new_rad(drop_angle - (props.look_angle_rad if adjusted_range.x else 0)),\n        windage=TrajectoryData._new_feet(windage),\n        windage_angle=TrajectoryData._new_rad(windage_angle),\n        slant_distance=TrajectoryData._new_feet(\n            adjusted_range.x * look_angle_cos + adjusted_range.y * look_angle_sin\n        ),\n        angle=TrajectoryData._new_rad(trajectory_angle),\n        density_ratio=density_ratio,\n        drag=drag,\n        energy=TrajectoryData._new_ft_lb(TrajectoryData.calculate_energy(props.weight_grains, velocity)),\n        ogw=TrajectoryData._new_lb(TrajectoryData.calculate_ogw(props.weight_grains, velocity)),\n        flag=flag,\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.interpolate","title":"interpolate  <code>staticmethod</code>","text":"<pre><code>interpolate(\n    key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n    value: Union[float, GenericDimension],\n    p0: TrajectoryData,\n    p1: TrajectoryData,\n    p2: TrajectoryData,\n    flag: Union[TrajFlag, int] = NONE,\n    method: InterpolationMethod = \"pchip\",\n) -&gt; TrajectoryData\n</code></pre> <p>Interpolate TrajectoryData where key_attribute==value using PCHIP (default) or linear.</p> <p>Parameters:</p> Name Type Description Default <code>key_attribute</code> <code>TRAJECTORY_DATA_ATTRIBUTES</code> <p>Attribute to key on (e.g., 'time', 'distance').</p> required <code>value</code> <code>Union[float, GenericDimension]</code> <p>Target value for the key attribute. A bare float is treated as raw value for dimensioned fields.</p> required <code>p0</code> <code>TrajectoryData</code> <p>First bracketing point.</p> required <code>p1</code> <code>TrajectoryData</code> <p>Second (middle) bracketing point.</p> required <code>p2</code> <code>TrajectoryData</code> <p>Third bracketing point.</p> required <code>flag</code> <code>Union[TrajFlag, int]</code> <p>Flag to assign to the new point.</p> <code>NONE</code> <code>method</code> <code>InterpolationMethod</code> <p>'pchip' (monotone cubic Hermite) or 'linear'.</p> <code>'pchip'</code> <p>Returns:</p> Type Description <code>TrajectoryData</code> <p>Interpolated point with key_attribute==value.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If TrajectoryData doesn't have the specified attribute.</p> <code>KeyError</code> <p>If the key_attribute is 'flag'.</p> <code>ZeroDivisionError</code> <p>If interpolation fails due to zero division.</p> <code>ValueError</code> <p>If method is not one of 'pchip' or 'linear'.</p> Source code in <code>py_ballisticcalc/trajectory_data.py</code> <pre><code>@staticmethod\ndef interpolate(\n    key_attribute: TRAJECTORY_DATA_ATTRIBUTES,\n    value: Union[float, GenericDimension],\n    p0: TrajectoryData,\n    p1: TrajectoryData,\n    p2: TrajectoryData,\n    flag: Union[TrajFlag, int] = TrajFlag.NONE,\n    method: InterpolationMethod = \"pchip\",\n) -&gt; TrajectoryData:\n    \"\"\"\n    Interpolate TrajectoryData where key_attribute==value using PCHIP (default) or linear.\n\n    Args:\n        key_attribute: Attribute to key on (e.g., 'time', 'distance').\n        value: Target value for the key attribute. A bare float is treated as\n            raw value for dimensioned fields.\n        p0: First bracketing point.\n        p1: Second (middle) bracketing point.\n        p2: Third bracketing point.\n        flag: Flag to assign to the new point.\n        method: 'pchip' (monotone cubic Hermite) or 'linear'.\n\n    Returns:\n        Interpolated point with key_attribute==value.\n\n    Raises:\n        AttributeError: If TrajectoryData doesn't have the specified attribute.\n        KeyError: If the key_attribute is 'flag'.\n        ZeroDivisionError: If interpolation fails due to zero division.\n        ValueError: If method is not one of 'pchip' or 'linear'.\n    \"\"\"\n    key_attribute = TRAJECTORY_DATA_SYNONYMS.get(key_attribute, key_attribute)  # Resolve synonyms\n    if not hasattr(TrajectoryData, key_attribute):\n        raise AttributeError(f\"TrajectoryData has no attribute '{key_attribute}'\")\n    if key_attribute == \"flag\":\n        raise KeyError(\"Cannot interpolate based on 'flag' attribute\")\n    key_value = value.raw_value if isinstance(value, GenericDimension) else value\n\n    def get_key_val(td):\n        \"\"\"Helper to get the raw value of the key attribute from a TrajectoryData point.\"\"\"\n        val = getattr(td, key_attribute)\n        return val.raw_value if hasattr(val, \"raw_value\") else float(val)\n\n    # The independent variable for interpolation (x-axis)\n    x_val = key_value\n    x0, x1, x2 = get_key_val(p0), get_key_val(p1), get_key_val(p2)\n\n    # Use reflection to build the new TrajectoryData object\n    interpolated_fields: Dict[str, Any] = {}\n    for field_name in TrajectoryData._fields:\n        if field_name == \"flag\":\n            continue\n\n        p0_field = getattr(p0, field_name)\n\n        if field_name == key_attribute:\n            if isinstance(value, GenericDimension):\n                interpolated_fields[field_name] = value\n            else:  # value is a float, assume it's in the same unit as the original data\n                if isinstance(p0_field, GenericDimension):\n                    interpolated_fields[field_name] = type(p0_field).new_from_raw(float(value), p0_field.units)\n                else:\n                    interpolated_fields[field_name] = float(value)\n            continue\n\n        # Interpolate all other fields\n        y0_val = p0_field\n        y1_val = getattr(p1, field_name)\n        y2_val = getattr(p2, field_name)\n\n        if isinstance(y0_val, GenericDimension):\n            y0, y1, y2 = y0_val.raw_value, y1_val.raw_value, y2_val.raw_value\n            if method == \"pchip\":\n                interpolated_raw = interpolate_3_pt(x_val, x0, y0, x1, y1, x2, y2)\n            elif method == \"linear\":\n                interpolated_raw = (\n                    interpolate_2_pt(x_val, x0, y0, x1, y1)\n                    if x_val &lt;= x1\n                    else interpolate_2_pt(x_val, x1, y1, x2, y2)\n                )\n            else:\n                raise ValueError(\"method must be 'pchip' or 'linear'\")\n            interpolated_fields[field_name] = type(y0_val).new_from_raw(interpolated_raw, y0_val.units)\n        elif isinstance(y0_val, (float, int)):\n            fy0, fy1, fy2 = float(y0_val), float(y1_val), float(y2_val)\n            if method == \"pchip\":\n                interpolated_fields[field_name] = interpolate_3_pt(x_val, x0, fy0, x1, fy1, x2, fy2)\n            elif method == \"linear\":\n                interpolated_fields[field_name] = (\n                    interpolate_2_pt(x_val, x0, fy0, x1, fy1)\n                    if x_val &lt;= x1\n                    else interpolate_2_pt(x_val, x1, fy1, x2, fy2)\n                )\n            else:\n                raise ValueError(\"method must be 'pchip' or 'linear'\")\n        else:\n            raise TypeError(f\"Cannot interpolate field '{field_name}' of type {type(y0_val)}\")\n\n    interpolated_fields[\"flag\"] = flag\n    return TrajectoryData(**interpolated_fields)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.engines.base_engine.TrajectoryDataFilter","title":"TrajectoryDataFilter","text":"<pre><code>TrajectoryDataFilter(\n    props: ShotProps,\n    filter_flags: Union[TrajFlag, int],\n    initial_position: Vector,\n    initial_velocity: Vector,\n    barrel_angle_rad: float,\n    look_angle_rad: float = 0.0,\n    range_limit: float = 0.0,\n    range_step: float = 0.0,\n    time_step: float = 0.0,\n)\n</code></pre> <p>Record TrajectoryData rows based on TrajFlags and attribute steps.</p> <ul> <li>Interpolates for requested points.</li> <li>Assumes that .record() will be called sequentially in time across the trajectory.</li> </ul> <p>Methods:</p> Name Description <code>record</code> <p>For each integration step, creates TrajectoryData records based on filter/step criteria.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def __init__(\n    self,\n    props: ShotProps,\n    filter_flags: Union[TrajFlag, int],\n    initial_position: Vector,\n    initial_velocity: Vector,\n    barrel_angle_rad: float,\n    look_angle_rad: float = 0.0,\n    range_limit: float = 0.0,\n    range_step: float = 0.0,\n    time_step: float = 0.0,\n):\n    \"\"\"If a time_step &gt; 0, then we will record a row at least that often in the trajectory.\"\"\"\n    self.records = []\n    self.props = props\n    self.filter = filter_flags\n    self.seen_zero = TrajFlag.NONE\n    self.time_step = time_step\n    self.range_step = range_step\n    self.range_limit = range_limit\n    self.time_of_last_record = 0.0\n    self.next_record_distance = 0.0\n    self.prev_data = None\n    self.prev_prev_data = None\n    self.look_angle_rad = look_angle_rad\n    self.look_angle_tangent = math.tan(look_angle_rad)\n    if self.filter &amp; TrajFlag.MACH:\n        mach = props.get_density_and_mach_for_altitude(initial_position.y)[1]\n        if initial_velocity.magnitude() &lt; mach:\n            # If we start below Mach 1, we won't look for Mach crossings\n            self.filter &amp;= ~TrajFlag.MACH\n    if self.filter &amp; TrajFlag.ZERO:\n        if initial_position.y &gt;= 0:\n            # If shot starts above zero then we will only look for a ZERO_DOWN crossing through the line of sight.\n            self.filter &amp;= ~TrajFlag.ZERO_UP\n        elif initial_position.y &lt; 0 and barrel_angle_rad &lt;= self.look_angle_rad:\n            # If shot starts below zero and barrel points below line of sight we won't look for any crossings.\n            self.filter &amp;= ~(TrajFlag.ZERO | TrajFlag.MRT)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.engines.base_engine.TrajectoryDataFilter-functions","title":"Functions","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.engines.base_engine.TrajectoryDataFilter.record","title":"record","text":"<pre><code>record(new_data: BaseTrajData)\n</code></pre> <p>For each integration step, creates TrajectoryData records based on filter/step criteria.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def record(self, new_data: BaseTrajData):\n    \"\"\"For each integration step, creates TrajectoryData records based on filter/step criteria.\"\"\"\n    rows: List[Tuple[BaseTrajData, Union[TrajFlag, int]]] = []\n\n    def add_row(data: BaseTrajData, flag: Union[TrajFlag, int]):\n        \"\"\"Add data, keeping `rows` sorted by time.\"\"\"\n        idx = bisect_left_key(rows, data.time, key=lambda r: r[0].time)\n        if idx &lt; len(rows):\n            # If we match existing row's time then just add this flag to the row\n            if abs(rows[idx][0].time - data.time) &lt; BaseIntegrationEngine.SEPARATE_ROW_TIME_DELTA:\n                rows[idx] = (rows[idx][0], rows[idx][1] | flag)\n                return\n            if idx &gt; 0 and abs(rows[idx - 1][0].time - data.time) &lt; BaseIntegrationEngine.SEPARATE_ROW_TIME_DELTA:\n                rows[idx - 1] = (rows[idx - 1][0], rows[idx - 1][1] | flag)\n                return\n        rows.insert(idx, (data, flag))  # Insert at sorted position\n\n    if new_data.time == 0.0:\n        # Always record starting point\n        add_row(new_data, TrajFlag.RANGE if (self.range_step &gt; 0 or self.time_step &gt; 0) else TrajFlag.NONE)\n    else:\n        # region RANGE steps\n        if self.range_step &gt; 0:\n            while self.next_record_distance + self.range_step &lt;= new_data.position.x:\n                new_row = None\n                record_distance = self.next_record_distance + self.range_step\n                if record_distance &gt; self.range_limit + self.EPSILON:\n                    self.range_step = -1  # Don't calculate range steps past range_limit\n                    break\n                if abs(record_distance - new_data.position.x) &lt; self.EPSILON:\n                    new_row = new_data\n                elif self.prev_data is not None and self.prev_prev_data is not None:\n                    new_row = BaseTrajData.interpolate(\n                        \"position.x\", record_distance, self.prev_prev_data, self.prev_data, new_data\n                    )\n                if new_row is not None:\n                    self.next_record_distance += self.range_step\n                    add_row(new_row, TrajFlag.RANGE)\n                    self.time_of_last_record = new_row.time\n                else:\n                    break  # Can't interpolate without previous data\n        # endregion RANGE steps\n        # region Time steps\n        if self.time_step &gt; 0 and self.prev_data is not None and self.prev_prev_data is not None:\n            while self.time_of_last_record + self.time_step &lt;= new_data.time:\n                self.time_of_last_record += self.time_step\n                new_row = BaseTrajData.interpolate(\n                    \"time\", self.time_of_last_record, self.prev_prev_data, self.prev_data, new_data\n                )\n                add_row(new_row, TrajFlag.RANGE)\n        # endregion Time steps\n        if (\n            self.filter &amp; TrajFlag.APEX\n            and self.prev_data is not None\n            and self.prev_prev_data is not None\n            and self.prev_data.velocity.y &gt; 0\n            and new_data.velocity.y &lt;= 0\n        ):\n            # \"Apex\" is the point where the vertical component of velocity goes from positive to negative.\n            new_row = BaseTrajData.interpolate(\"velocity.y\", 0.0, self.prev_prev_data, self.prev_data, new_data)\n            add_row(new_row, TrajFlag.APEX)\n            self.filter &amp;= ~TrajFlag.APEX  # Don't look for more apices\n\n    self.records.extend([TrajectoryData.from_base_data(self.props, data, flag) for data, flag in rows])\n\n    # region Points that must be interpolated on TrajectoryData instances\n    if self.prev_data is not None and self.prev_prev_data is not None:\n        compute_flags = TrajFlag.NONE\n        if (\n            self.filter &amp; TrajFlag.MACH\n            and self.prev_data is not None\n            and new_data.velocity.magnitude() &lt; new_data.mach\n        ):\n            compute_flags |= TrajFlag.MACH\n            self.filter &amp;= ~TrajFlag.MACH  # Don't look for more Mach crossings\n        # region ZERO checks (done on TrajectoryData objects so we can interpolate for .slant_height)\n        if self.filter &amp; TrajFlag.ZERO:\n            # Zero reference line is the sight line defined by look_angle\n            reference_height = new_data.position.x * self.look_angle_tangent\n            # If we haven't seen ZERO_UP, we look for that first\n            if self.filter &amp; TrajFlag.ZERO_UP:\n                if new_data.position.y &gt;= reference_height:\n                    compute_flags |= TrajFlag.ZERO_UP\n                    self.filter &amp;= ~TrajFlag.ZERO_UP\n            # We've crossed above sight line; now look for crossing back through it\n            elif self.filter &amp; TrajFlag.ZERO_DOWN:\n                if new_data.position.y &lt; reference_height:\n                    compute_flags |= TrajFlag.ZERO_DOWN\n                    self.filter &amp;= ~TrajFlag.ZERO_DOWN\n        # endregion ZERO checks\n        if compute_flags:\n            # Instantiate TrajectoryData and interpolate\n            t0 = TrajectoryData.from_base_data(self.props, new_data)\n            t1 = TrajectoryData.from_base_data(self.props, self.prev_data)\n            t2 = TrajectoryData.from_base_data(self.props, self.prev_prev_data)\n            add_td = []\n            if compute_flags &amp; TrajFlag.MACH:\n                add_td.append(TrajectoryData.interpolate(\"mach\", 1.0, t0, t1, t2, TrajFlag.MACH))\n                compute_flags &amp;= ~TrajFlag.MACH\n            if compute_flags &amp; TrajFlag.ZERO:\n                add_td.append(TrajectoryData.interpolate(\"slant_height\", 0.0, t0, t1, t2, compute_flags))\n            for td in add_td:  # Add TrajectoryData, keeping `results` sorted by time.\n                idx = bisect_left_key(self.records, td.time, key=lambda r: r.time)\n                if idx &lt; len(self.records):  # If we match existing row's time then just add this flag to the row\n                    if abs(self.records[idx].time - td.time) &lt; BaseIntegrationEngine.SEPARATE_ROW_TIME_DELTA:\n                        self.records[idx] = td._replace(flag=self.records[idx].flag | td.flag)\n                        continue\n                    elif (\n                        idx &gt; 0\n                        and abs(self.records[idx - 1].time - td.time)\n                        &lt; BaseIntegrationEngine.SEPARATE_ROW_TIME_DELTA\n                    ):\n                        self.records[idx - 1] = td._replace(flag=self.records[idx - 1].flag | td.flag)\n                        continue\n                self.records.insert(idx, td)  # Insert at sorted position\n    # endregion\n    self.prev_prev_data = self.prev_data\n    self.prev_data = new_data\n</code></pre>"},{"location":"api/vector/","title":"Vector","text":""},{"location":"api/vector/#py_ballisticcalc.vector.Vector","title":"Vector","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Immutable 3D vector for ballistic trajectory calculations.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Distance/horizontal component (positive = downrange direction).</p> <code>y</code> <code>float</code> <p>Vertical component (positive = upward direction).</p> <code>z</code> <code>float</code> <p>Horizontal component (positive = right lateral direction).</p> <p>Examples:</p> <p>Basic vector creation and operations:</p> <pre><code># Create position vector (100m downrange, 10m high)\nposition = Vector(100.0, 10.0, 0.0)\n\n# Create velocity vector (800 m/s muzzle velocity)\nvelocity = Vector(800.0, 0.0, 0.0)\n\n# Vector arithmetic\nnew_pos = position + velocity * 0.1  # Position after 0.1 seconds\n\n# Calculate magnitude\nspeed = velocity.magnitude()  # 800.0 m/s\n\n# Create unit vector for direction\ndirection = velocity.normalize()  # Vector(1.0, 0.0, 0.0)\n\n# Wind vector (5 m/s crosswind from left)\nwind = Vector(0.0, 0.0, 5.0)\n\n# Calculate wind effect angle\ncos_angle = velocity.mul_by_vector(wind) / (velocity.magnitude() * wind.magnitude())\n\n# Gravity vector\ngravity = Vector(0.0, -9.81, 0.0)  # m/s\u00b2\n</code></pre> <p>Methods:</p> Name Description <code>magnitude</code> <p>Calculate the Euclidean norm (length) of the vector.</p> <code>mul_by_const</code> <p>Multiply vector by a scalar constant.</p> <code>mul_by_vector</code> <p>Calculate the dot product (scalar product) of two vectors.</p> <code>add</code> <p>Add two vectors component-wise.</p> <code>subtract</code> <p>Subtract one vector from another component-wise.</p> <code>negate</code> <p>Create a vector with opposite direction (negative vector).</p> <code>normalize</code> <p>Create a unit vector pointing in the same direction.</p>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector-functions","title":"Functions","text":""},{"location":"api/vector/#py_ballisticcalc.vector.Vector.magnitude","title":"magnitude","text":"<pre><code>magnitude() -&gt; float\n</code></pre> <p>Calculate the Euclidean norm (length) of the vector.</p> <p>Returns:</p> Type Description <code>float</code> <p>The magnitude (length) of the vector as a non-negative float.</p> <p>Examples:</p> <pre><code># Unit vector magnitude\nunit = Vector(1.0, 0.0, 0.0)\nassert unit.magnitude() == 1.0\n\n# Velocity magnitude (speed)\nvelocity = Vector(800.0, 100.0, 50.0)\nspeed = velocity.magnitude()  # ~806.5\n\n# Distance calculation\nposition = Vector(100.0, 50.0, 25.0)\ndistance = position.magnitude()  # Distance from origin\n</code></pre> Note <p>Uses math.hypot() for numerical stability with extreme values. Equivalent to sqrt(x\u00b2 + y\u00b2 + z\u00b2) but more robust.</p> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def magnitude(self) -&gt; float:\n    \"\"\"Calculate the Euclidean norm (length) of the vector.\n\n    Returns:\n        The magnitude (length) of the vector as a non-negative float.\n\n    Examples:\n        ```python\n        # Unit vector magnitude\n        unit = Vector(1.0, 0.0, 0.0)\n        assert unit.magnitude() == 1.0\n\n        # Velocity magnitude (speed)\n        velocity = Vector(800.0, 100.0, 50.0)\n        speed = velocity.magnitude()  # ~806.5\n\n        # Distance calculation\n        position = Vector(100.0, 50.0, 25.0)\n        distance = position.magnitude()  # Distance from origin\n        ```\n\n    Note:\n        Uses math.hypot() for numerical stability with extreme values.\n        Equivalent to sqrt(x\u00b2 + y\u00b2 + z\u00b2) but more robust.\n    \"\"\"\n    # return math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)\n    return math.hypot(self.x, self.y, self.z)\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.mul_by_const","title":"mul_by_const","text":"<pre><code>mul_by_const(a: float) -&gt; Vector\n</code></pre> <p>Multiply vector by a scalar constant.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Scalar multiplier. Can be positive (same direction), negative (opposite direction), or zero (zero vector).</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New Vector instance with each component multiplied by the scalar.</p> <p>Examples:</p> <pre><code># Scale velocity vector\nvelocity = Vector(800.0, 0.0, 0.0)\nhalf_velocity = velocity.mul_by_const(0.5)  # Vector(400.0, 0.0, 0.0)\n\n# Reverse direction\nreversed_vel = velocity.mul_by_const(-1.0)  # Vector(-800.0, 0.0, 0.0)\n\n# Time-based scaling for position updates\ndelta_pos = velocity.mul_by_const(0.001)  # Position change in 1ms\n</code></pre> Note <p>This operation preserves vector direction for non-zero scalars. Multiplying by zero produces a zero vector.</p> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def mul_by_const(self, a: float) -&gt; Vector:\n    \"\"\"Multiply vector by a scalar constant.\n\n    Args:\n        a: Scalar multiplier. Can be positive (same direction), negative\n            (opposite direction), or zero (zero vector).\n\n    Returns:\n        New Vector instance with each component multiplied by the scalar.\n\n    Examples:\n        ```python\n        # Scale velocity vector\n        velocity = Vector(800.0, 0.0, 0.0)\n        half_velocity = velocity.mul_by_const(0.5)  # Vector(400.0, 0.0, 0.0)\n\n        # Reverse direction\n        reversed_vel = velocity.mul_by_const(-1.0)  # Vector(-800.0, 0.0, 0.0)\n\n        # Time-based scaling for position updates\n        delta_pos = velocity.mul_by_const(0.001)  # Position change in 1ms\n        ```\n\n    Note:\n        This operation preserves vector direction for non-zero scalars.\n        Multiplying by zero produces a zero vector.\n    \"\"\"\n    return Vector(self.x * a, self.y * a, self.z * a)\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.mul_by_vector","title":"mul_by_vector","text":"<pre><code>mul_by_vector(b: Vector) -&gt; float\n</code></pre> <p>Calculate the dot product (scalar product) of two vectors.</p> <p>Computes the dot product, which represents the projection of one vector onto another. The result is a scalar value used in angle calculations, projections, and determining vector relationships.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Vector</code> <p>The other Vector instance to compute dot product with.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Scalar result of the dot product (x\u2081\u00b7x\u2082 + y\u2081\u00b7y\u2082 + z\u2081\u00b7z\u2082). Positive values indicate vectors pointing in similar directions, negative values indicate opposite directions, zero indicates perpendicular vectors.</p> <p>Examples:</p> <pre><code># Parallel vectors (same direction)\nv1 = Vector(1.0, 0.0, 0.0)\nv2 = Vector(2.0, 0.0, 0.0)\ndot = v1.mul_by_vector(v2)  # 2.0 (positive)\n\n# Perpendicular vectors\nv1 = Vector(1.0, 0.0, 0.0)\nv2 = Vector(0.0, 1.0, 0.0)\ndot = v1.mul_by_vector(v2)  # 0.0 (perpendicular)\n\n# Angle calculation\nvelocity = Vector(800.0, 100.0, 0.0)\nwind = Vector(0.0, 0.0, 10.0)\ncos_angle = velocity.mul_by_vector(wind) / (velocity.magnitude() * wind.magnitude())\n\n# Work calculation (force \u00b7 displacement)\nforce = Vector(100.0, 0.0, 0.0)  # Newtons\ndisplacement = Vector(10.0, 5.0, 0.0)  # meters\nwork = force.mul_by_vector(displacement)  # 1000.0 Joules\n</code></pre> Note <ul> <li>The dot product is commutative: a\u00b7b = b\u00b7a</li> <li>For unit vectors, the dot product equals the cosine of the angle between them.</li> </ul> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def mul_by_vector(self, b: Vector) -&gt; float:\n    \"\"\"Calculate the dot product (scalar product) of two vectors.\n\n    Computes the dot product, which represents the projection of one vector\n    onto another. The result is a scalar value used in angle calculations,\n    projections, and determining vector relationships.\n\n    Args:\n        b: The other Vector instance to compute dot product with.\n\n    Returns:\n        Scalar result of the dot product (x\u2081\u00b7x\u2082 + y\u2081\u00b7y\u2082 + z\u2081\u00b7z\u2082).\n            Positive values indicate vectors pointing in similar directions,\n            negative values indicate opposite directions, zero indicates perpendicular vectors.\n\n    Examples:\n        ```python\n        # Parallel vectors (same direction)\n        v1 = Vector(1.0, 0.0, 0.0)\n        v2 = Vector(2.0, 0.0, 0.0)\n        dot = v1.mul_by_vector(v2)  # 2.0 (positive)\n\n        # Perpendicular vectors\n        v1 = Vector(1.0, 0.0, 0.0)\n        v2 = Vector(0.0, 1.0, 0.0)\n        dot = v1.mul_by_vector(v2)  # 0.0 (perpendicular)\n\n        # Angle calculation\n        velocity = Vector(800.0, 100.0, 0.0)\n        wind = Vector(0.0, 0.0, 10.0)\n        cos_angle = velocity.mul_by_vector(wind) / (velocity.magnitude() * wind.magnitude())\n\n        # Work calculation (force \u00b7 displacement)\n        force = Vector(100.0, 0.0, 0.0)  # Newtons\n        displacement = Vector(10.0, 5.0, 0.0)  # meters\n        work = force.mul_by_vector(displacement)  # 1000.0 Joules\n        ```\n\n    Note:\n        - The dot product is commutative: a\u00b7b = b\u00b7a\n        - For unit vectors, the dot product equals the cosine of the angle between them.\n    \"\"\"\n    return self.x * b.x + self.y * b.y + self.z * b.z\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.add","title":"add","text":"<pre><code>add(b: Vector) -&gt; Vector\n</code></pre> <p>Add two vectors component-wise.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Vector</code> <p>The other Vector instance to add to this vector.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New Vector instance representing the sum of both vectors.</p> <p>Examples:</p> <pre><code># Position update\nposition = Vector(100.0, 10.0, 0.0)\ndisplacement = Vector(5.0, 1.0, 0.5)\nnew_position = position.add(displacement)  # Vector(105.0, 11.0, 0.5)\n\n# Velocity combination\nmuzzle_velocity = Vector(800.0, 0.0, 0.0)\nwind_velocity = Vector(0.0, 0.0, 5.0)\ntotal_velocity = muzzle_velocity.add(wind_velocity)  # Vector(800.0, 0.0, 5.0)\n\n# Trajectory step integration\nold_pos = Vector(50.0, 20.0, 0.0)\nvelocity_delta = Vector(8.0, 0.1, 0.0)  # velocity * time_step\nnew_pos = old_pos.add(velocity_delta)\n</code></pre> Note <ul> <li>Vector addition is commutative: a + b = b + a</li> <li>Vector addition is associative: (a + b) + c = a + (b + c)</li> </ul> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def add(self, b: Vector) -&gt; Vector:\n    \"\"\"Add two vectors component-wise.\n\n    Args:\n        b: The other Vector instance to add to this vector.\n\n    Returns:\n        New Vector instance representing the sum of both vectors.\n\n    Examples:\n        ```python\n        # Position update\n        position = Vector(100.0, 10.0, 0.0)\n        displacement = Vector(5.0, 1.0, 0.5)\n        new_position = position.add(displacement)  # Vector(105.0, 11.0, 0.5)\n\n        # Velocity combination\n        muzzle_velocity = Vector(800.0, 0.0, 0.0)\n        wind_velocity = Vector(0.0, 0.0, 5.0)\n        total_velocity = muzzle_velocity.add(wind_velocity)  # Vector(800.0, 0.0, 5.0)\n\n        # Trajectory step integration\n        old_pos = Vector(50.0, 20.0, 0.0)\n        velocity_delta = Vector(8.0, 0.1, 0.0)  # velocity * time_step\n        new_pos = old_pos.add(velocity_delta)\n        ```\n\n    Note:\n        - Vector addition is commutative: a + b = b + a\n        - Vector addition is associative: (a + b) + c = a + (b + c)\n    \"\"\"\n    return Vector(self.x + b.x, self.y + b.y, self.z + b.z)\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.subtract","title":"subtract","text":"<pre><code>subtract(b: Vector) -&gt; Vector\n</code></pre> <p>Subtract one vector from another component-wise.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Vector</code> <p>The Vector instance to subtract from this vector.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>New Vector instance representing the difference (self - b).</p> <p>Examples:</p> <pre><code># Relative position calculation\ntarget_pos = Vector(1000.0, 0.0, 50.0)\nbullet_pos = Vector(500.0, 10.0, 45.0)\nrelative_pos = target_pos.subtract(bullet_pos)  # Vector(500.0, -10.0, 5.0)\n\n# Velocity change calculation\ninitial_velocity = Vector(800.0, 0.0, 0.0)\nfinal_velocity = Vector(750.0, -5.0, 2.0)\nvelocity_change = final_velocity.subtract(initial_velocity)  # Vector(-50.0, -5.0, 2.0)\n\n# Range vector calculation\nmuzzle_pos = Vector(0.0, 1.5, 0.0)  # Scope height\nimpact_pos = Vector(1000.0, -2.0, 10.0)\nrange_vector = impact_pos.subtract(muzzle_pos)  # Vector(1000.0, -3.5, 10.0)\n</code></pre> Note <ul> <li>Vector subtraction is NOT commutative: a - b \u2260 b - a</li> <li>The result represents the vector from b to self.</li> </ul> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def subtract(self, b: Vector) -&gt; Vector:\n    \"\"\"Subtract one vector from another component-wise.\n\n    Args:\n        b: The Vector instance to subtract from this vector.\n\n    Returns:\n        New Vector instance representing the difference (self - b).\n\n    Examples:\n        ```python\n        # Relative position calculation\n        target_pos = Vector(1000.0, 0.0, 50.0)\n        bullet_pos = Vector(500.0, 10.0, 45.0)\n        relative_pos = target_pos.subtract(bullet_pos)  # Vector(500.0, -10.0, 5.0)\n\n        # Velocity change calculation\n        initial_velocity = Vector(800.0, 0.0, 0.0)\n        final_velocity = Vector(750.0, -5.0, 2.0)\n        velocity_change = final_velocity.subtract(initial_velocity)  # Vector(-50.0, -5.0, 2.0)\n\n        # Range vector calculation\n        muzzle_pos = Vector(0.0, 1.5, 0.0)  # Scope height\n        impact_pos = Vector(1000.0, -2.0, 10.0)\n        range_vector = impact_pos.subtract(muzzle_pos)  # Vector(1000.0, -3.5, 10.0)\n        ```\n\n    Note:\n        - Vector subtraction is NOT commutative: a - b \u2260 b - a\n        - The result represents the vector from b to self.\n    \"\"\"\n    return Vector(self.x - b.x, self.y - b.y, self.z - b.z)\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.negate","title":"negate","text":"<pre><code>negate() -&gt; Vector\n</code></pre> <p>Create a vector with opposite direction (negative vector).</p> <p>Returns a new vector with all components negated, effectively creating a vector pointing in the opposite direction with the same magnitude.</p> <p>Returns:</p> Type Description <code>Vector</code> <p>New Vector instance with all components negated (-x, -y, -z).</p> <p>Examples:</p> <pre><code># Reverse velocity direction\nforward_velocity = Vector(800.0, 0.0, 0.0)\nbackward_velocity = forward_velocity.negate()  # Vector(-800.0, 0.0, 0.0)\n\n# Opposite force direction\ndrag_force = Vector(-25.0, -2.0, 0.0)\nthrust_force = drag_force.negate()  # Vector(25.0, 2.0, 0.0)\n\n# Reflection calculation\nincident_vector = Vector(100.0, -50.0, 25.0)\nreflected_vector = incident_vector.negate()  # Vector(-100.0, 50.0, -25.0)\n</code></pre> Note <ul> <li>The magnitude remains unchanged: |v| = |-v|</li> <li>Negating twice returns the original vector: -(-v) = v</li> </ul> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def negate(self) -&gt; Vector:\n    \"\"\"Create a vector with opposite direction (negative vector).\n\n    Returns a new vector with all components negated, effectively creating\n    a vector pointing in the opposite direction with the same magnitude.\n\n    Returns:\n        New Vector instance with all components negated (-x, -y, -z).\n\n    Examples:\n        ```python\n        # Reverse velocity direction\n        forward_velocity = Vector(800.0, 0.0, 0.0)\n        backward_velocity = forward_velocity.negate()  # Vector(-800.0, 0.0, 0.0)\n\n        # Opposite force direction\n        drag_force = Vector(-25.0, -2.0, 0.0)\n        thrust_force = drag_force.negate()  # Vector(25.0, 2.0, 0.0)\n\n        # Reflection calculation\n        incident_vector = Vector(100.0, -50.0, 25.0)\n        reflected_vector = incident_vector.negate()  # Vector(-100.0, 50.0, -25.0)\n        ```\n\n    Note:\n        - The magnitude remains unchanged: |v| = |-v|\n        - Negating twice returns the original vector: -(-v) = v\n    \"\"\"\n    return Vector(-self.x, -self.y, -self.z)\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector.Vector.normalize","title":"normalize","text":"<pre><code>normalize() -&gt; Vector\n</code></pre> <p>Create a unit vector pointing in the same direction.</p> <p>Returns:</p> Type Description <code>Vector</code> <p>New Vector instance with magnitude 1.0 and same direction. For near-zero vectors (magnitude &lt; 1e-10), returns a copy of the original vector to avoid division by zero.</p> <p>Examples:</p> <pre><code># Create direction vector\nvelocity = Vector(800.0, 100.0, 50.0)\ndirection = velocity.normalize()  # Unit vector in velocity direction\n\n# Wind direction calculation\nwind_vector = Vector(5.0, 0.0, 3.0)\nwind_direction = wind_vector.normalize()  # Unit vector for wind direction\n\n# Line of sight vector\nlos_vector = Vector(1000.0, -10.0, 25.0)\nlos_unit = los_vector.normalize()  # Unit vector toward target\n</code></pre> Note <p>For numerical stability, vectors with magnitude &lt; 1e-10 are considered zero vectors and returned unchanged rather than normalized. The normalized vector preserves direction but has magnitude = 1.0.</p> Source code in <code>py_ballisticcalc/vector.py</code> <pre><code>def normalize(self) -&gt; Vector:\n    \"\"\"Create a unit vector pointing in the same direction.\n\n    Returns:\n        New Vector instance with magnitude 1.0 and same direction.\n            For near-zero vectors (magnitude &lt; 1e-10), returns a copy of\n            the original vector to avoid division by zero.\n\n    Examples:\n        ```python\n        # Create direction vector\n        velocity = Vector(800.0, 100.0, 50.0)\n        direction = velocity.normalize()  # Unit vector in velocity direction\n\n        # Wind direction calculation\n        wind_vector = Vector(5.0, 0.0, 3.0)\n        wind_direction = wind_vector.normalize()  # Unit vector for wind direction\n\n        # Line of sight vector\n        los_vector = Vector(1000.0, -10.0, 25.0)\n        los_unit = los_vector.normalize()  # Unit vector toward target\n        ```\n\n    Note:\n        For numerical stability, vectors with magnitude &lt; 1e-10 are considered\n        zero vectors and returned unchanged rather than normalized.\n        The normalized vector preserves direction but has magnitude = 1.0.\n    \"\"\"\n    m = self.magnitude()\n    if math.fabs(m) &lt; 1e-10:\n        return Vector(self.x, self.y, self.z)\n    return self.mul_by_const(1.0 / m)\n</code></pre>"},{"location":"api/calculator/engines/","title":"Engines","text":""},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine","title":"BaseIntegrationEngine","text":"<pre><code>BaseIntegrationEngine(_config: _BaseEngineConfigDictT)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>EngineProtocol[_BaseEngineConfigDictT]</code></p> <p>All calculations are done in imperial units (feet and fps).</p> <p>Parameters:</p> Name Type Description Default <code>_config</code> <code>_BaseEngineConfigDictT</code> <p>The configuration object.</p> required <p>Methods:</p> Name Description <code>get_calc_step</code> <p>Get step size for integration.</p> <code>find_max_range</code> <p>Find the maximum range along shot_info.look_angle, and the launch angle to reach it.</p> <code>find_apex</code> <p>Find the apex of the trajectory.</p> <code>find_zero_angle</code> <p>Find the barrel elevation needed to hit sight line at a specific distance.</p> <code>zero_angle</code> <p>Find the barrel elevation needed to hit sight line at a specific distance.</p> <code>integrate</code> <p>Compute the trajectory for the given shot.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def __init__(self, _config: _BaseEngineConfigDictT):\n    \"\"\"Initialize the class.\n\n    Args:\n        _config: The configuration object.\n    \"\"\"\n    self._config: BaseEngineConfig = create_base_engine_config(_config)\n    self.gravity_vector: Vector = Vector(0.0, self._config.cGravityConstant, 0.0)\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine-functions","title":"Functions","text":""},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine.get_calc_step","title":"get_calc_step","text":"<pre><code>get_calc_step() -&gt; float\n</code></pre> <p>Get step size for integration.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def get_calc_step(self) -&gt; float:\n    \"\"\"Get step size for integration.\"\"\"\n    return self._config.cStepMultiplier\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine.find_max_range","title":"find_max_range","text":"<pre><code>find_max_range(\n    shot_info: Shot,\n    angle_bracket_deg: Tuple[float, float] = (0, 90),\n) -&gt; Tuple[Distance, Angular]\n</code></pre> <p>Find the maximum range along shot_info.look_angle, and the launch angle to reach it.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>The shot information: gun, ammo, environment, look_angle.</p> required <code>angle_bracket_deg</code> <code>Tuple[float, float]</code> <p>The angle bracket in degrees to search for max range. Defaults to (0, 90).</p> <code>(0, 90)</code> <p>Returns:</p> Type Description <code>Tuple[Distance, Angular]</code> <p>The maximum slant-range and the launch angle to reach it.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the angle bracket excludes the look_angle.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def find_max_range(\n    self, shot_info: Shot, angle_bracket_deg: Tuple[float, float] = (0, 90)\n) -&gt; Tuple[Distance, Angular]:\n    \"\"\"Find the maximum range along shot_info.look_angle, and the launch angle to reach it.\n\n    Args:\n        shot_info: The shot information: gun, ammo, environment, look_angle.\n        angle_bracket_deg: The angle bracket in degrees to search for max range. Defaults to (0, 90).\n\n    Returns:\n        The maximum slant-range and the launch angle to reach it.\n\n    Raises:\n        ValueError: If the angle bracket excludes the look_angle.\n    \"\"\"\n    \"\"\"\n    TODO: Make sure user hasn't restricted angle bracket to exclude the look_angle.\n        ... and check for weird situations, like backward-bending trajectories,\n        where the max range occurs with launch angle less than the look angle.\n    \"\"\"\n    props = self._init_trajectory(shot_info)\n    return self._find_max_range(props, angle_bracket_deg)\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine.find_apex","title":"find_apex","text":"<pre><code>find_apex(shot_info: Shot) -&gt; TrajectoryData\n</code></pre> <p>Find the apex of the trajectory.</p> <p>Apex is defined as the point where the vertical component of velocity goes from positive to negative.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>The shot information.</p> required <p>Returns:</p> Name Type Description <code>TrajectoryData</code> <code>TrajectoryData</code> <p>The trajectory data at the apex of the trajectory.</p> <p>Raises:</p> Type Description <code>SolverRuntimeError</code> <p>If no apex is found in the trajectory data.</p> <code>ValueError</code> <p>If barrel elevation is not &gt; 0.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def find_apex(self, shot_info: Shot) -&gt; TrajectoryData:\n    \"\"\"Find the apex of the trajectory.\n\n    Apex is defined as the point where the vertical component of velocity goes from positive to negative.\n\n    Args:\n        shot_info: The shot information.\n\n    Returns:\n        TrajectoryData: The trajectory data at the apex of the trajectory.\n\n    Raises:\n        SolverRuntimeError: If no apex is found in the trajectory data.\n        ValueError: If barrel elevation is not &gt; 0.\n    \"\"\"\n    props = self._init_trajectory(shot_info)\n    return self._find_apex(props)\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine.find_zero_angle","title":"find_zero_angle","text":"<pre><code>find_zero_angle(\n    shot_info: Shot,\n    distance: Distance,\n    lofted: bool = False,\n) -&gt; Angular\n</code></pre> <p>Find the barrel elevation needed to hit sight line at a specific distance.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>The shot information.</p> required <code>distance</code> <code>Distance</code> <p>Slant distance to the target.</p> required <code>lofted</code> <code>bool</code> <p>If True, find the higher angle that hits the zero point.</p> <code>False</code> <p>Returns:</p> Type Description <code>Angular</code> <p>Barrel elevation needed to hit the zero point.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def find_zero_angle(self, shot_info: Shot, distance: Distance, lofted: bool = False) -&gt; Angular:\n    \"\"\"Find the barrel elevation needed to hit sight line at a specific distance.\n\n    Args:\n        shot_info: The shot information.\n        distance: Slant distance to the target.\n        lofted: If True, find the higher angle that hits the zero point.\n\n    Returns:\n        Barrel elevation needed to hit the zero point.\n    \"\"\"\n    props = self._init_trajectory(shot_info)\n    return self._find_zero_angle(props, distance, lofted)\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine.zero_angle","title":"zero_angle","text":"<pre><code>zero_angle(shot_info: Shot, distance: Distance) -&gt; Angular\n</code></pre> <p>Find the barrel elevation needed to hit sight line at a specific distance.</p> <p>First tries iterative approach; if that fails then falls back on <code>_find_zero_angle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>The shot information.</p> required <code>distance</code> <code>Distance</code> <p>The distance to the target.</p> required <p>Returns:</p> Type Description <code>Angular</code> <p>Barrel elevation to hit height zero at zero distance along sight line</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def zero_angle(self, shot_info: Shot, distance: Distance) -&gt; Angular:\n    \"\"\"Find the barrel elevation needed to hit sight line at a specific distance.\n\n    First tries iterative approach; if that fails then falls back on `_find_zero_angle`.\n\n    Args:\n        shot_info: The shot information.\n        distance: The distance to the target.\n\n    Returns:\n        Barrel elevation to hit height zero at zero distance along sight line\n    \"\"\"\n    props = self._init_trajectory(shot_info)\n    try:\n        return self._zero_angle(props, distance)\n    except ZeroFindingError as e:\n        logger.warning(f\"Failed to find zero angle using base iterative method: {e}\")\n        # Fallback to guaranteed method\n        return self._find_zero_angle(props, distance)\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseIntegrationEngine.integrate","title":"integrate","text":"<pre><code>integrate(\n    shot_info: Shot,\n    max_range: Distance,\n    dist_step: Optional[Distance] = None,\n    time_step: float = 0.0,\n    filter_flags: Union[TrajFlag, int] = NONE,\n    dense_output: bool = False,\n    **kwargs,\n) -&gt; HitResult\n</code></pre> <p>Compute the trajectory for the given shot.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>The shot information.</p> required <code>max_range</code> <code>Distance</code> <p>Maximum range of the trajectory (if float then treated as feet).</p> required <code>dist_step</code> <code>Optional[Distance]</code> <p>Distance step for recording RANGE TrajectoryData rows.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for recording trajectory data. Defaults to 0.0.</p> <code>0.0</code> <code>filter_flags</code> <code>Union[TrajFlag, int]</code> <p>Flags to filter trajectory data. Defaults to TrajFlag.RANGE.</p> <code>NONE</code> <code>dense_output</code> <code>bool</code> <p>If True, HitResult will save BaseTrajData for interpolating TrajectoryData.</p> <code>False</code> <p>Returns:</p> Type Description <code>HitResult</code> <p>HitResult object for describing the trajectory.</p> Source code in <code>py_ballisticcalc/engines/base_engine.py</code> <pre><code>def integrate(\n    self,\n    shot_info: Shot,\n    max_range: Distance,\n    dist_step: Optional[Distance] = None,\n    time_step: float = 0.0,\n    filter_flags: Union[TrajFlag, int] = TrajFlag.NONE,\n    dense_output: bool = False,\n    **kwargs,\n) -&gt; HitResult:\n    \"\"\"Compute the trajectory for the given shot.\n\n    Args:\n        shot_info: The shot information.\n        max_range: Maximum range of the trajectory (if float then treated as feet).\n        dist_step: Distance step for recording RANGE TrajectoryData rows.\n        time_step: Time step for recording trajectory data. Defaults to 0.0.\n        filter_flags: Flags to filter trajectory data. Defaults to TrajFlag.RANGE.\n        dense_output: If True, HitResult will save BaseTrajData for interpolating TrajectoryData.\n\n    Returns:\n        HitResult object for describing the trajectory.\n    \"\"\"\n    props = self._init_trajectory(shot_info)\n    props.filter_flags = filter_flags\n    range_limit_ft = max_range &gt;&gt; Distance.Foot\n    if dist_step is None:\n        range_step_ft = range_limit_ft\n    else:\n        range_step_ft = dist_step &gt;&gt; Distance.Foot\n    return self._integrate(props, range_limit_ft, range_step_ft, time_step, filter_flags, dense_output, **kwargs)\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.base_engine.BaseEngineConfigDict","title":"BaseEngineConfigDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for flexible engine configuration from dictionaries.</p> <p>This TypedDict provides a flexible way to configure ballistic calculation engines using dictionary syntax. All fields are optional, allowing partial configuration where only specific parameters need to be overridden.</p> <p>When used with create_base_engine_config(), any unspecified fields will use their default values from DEFAULT_BASE_ENGINE_CONFIG.</p> <p>Note: All fields are Optional to support partial configuration.</p> Fields <ul> <li>cZeroFindingAccuracy: Maximum slant-error in feet for zero-finding precision.</li> <li>cMaxIterations: Maximum iterations for convergence algorithms.</li> <li>cMinimumAltitude: Minimum altitude in feet to continue calculation.</li> <li>cMaximumDrop: Maximum drop in feet from muzzle to continue.</li> <li>cMinimumVelocity: Minimum velocity in fps to continue calculation.</li> <li>cGravityConstant: Gravitational acceleration in ft/s\u00b2.</li> <li>cStepMultiplier: Integration step size multiplier.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; config_dict: BaseEngineConfigDict = {\n...     'cMinimumVelocity': 100.0,\n...     'cStepMultiplier': 0.8\n... }\n&gt;&gt;&gt; config = create_base_engine_config(config_dict)\n&gt;&gt;&gt; # Using with Calculator\n&gt;&gt;&gt; from py_ballisticcalc import Calculator\n&gt;&gt;&gt; calc = Calculator(config=config_dict)\n</code></pre> See Also <ul> <li>BaseEngineConfig: Type-safe dataclass version</li> <li>create_base_engine_config: Factory function for BaseEngineConfig creation</li> </ul>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.RK4IntegrationEngine","title":"RK4IntegrationEngine","text":"<pre><code>RK4IntegrationEngine(config: BaseEngineConfigDict)\n</code></pre> <p>               Bases: <code>BaseIntegrationEngine[BaseEngineConfigDict]</code></p> <p>Runge-Kutta 4th order integration engine for ballistic trajectory calculations.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEngineConfigDict</code>)           \u2013            <p>Configuration dictionary containing engine parameters.    See BaseEngineConfigDict for available options.    Common settings include cStepMultiplier for accuracy control    and cMinimumVelocity for termination conditions.</p> </li> </ul> Source code in <code>py_ballisticcalc/engines/rk4.py</code> <pre><code>def __init__(self, config: BaseEngineConfigDict) -&gt; None:\n    \"\"\"Initialize the RK4 integration engine.\n\n    Args:\n        config: Configuration dictionary containing engine parameters.\n               See BaseEngineConfigDict for available options.\n               Common settings include cStepMultiplier for accuracy control\n               and cMinimumVelocity for termination conditions.\n\n    Examples:\n        &gt;&gt;&gt; precise_config = BaseEngineConfigDict(\n        ...     cStepMultiplier=0.5,  # Smaller steps\n        ...     cMinimumVelocity=20.0  # Continue to lower velocities\n        ... )\n        &gt;&gt;&gt; precise_engine = RK4IntegrationEngine(precise_config)\n    \"\"\"\n    super().__init__(config)\n    self.integration_step_count: int = 0\n    self.trajectory_count = 0  # Number of trajectories calculated\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.EulerIntegrationEngine","title":"EulerIntegrationEngine","text":"<pre><code>EulerIntegrationEngine(config: BaseEngineConfigDict)\n</code></pre> <p>               Bases: <code>BaseIntegrationEngine[BaseEngineConfigDict]</code></p> <p>Euler integration engine for ballistic trajectory calculations.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEngineConfigDict</code>)           \u2013            <p>Configuration dictionary containing engine parameters.    See BaseEngineConfigDict for available options.</p> </li> </ul> Source code in <code>py_ballisticcalc/engines/euler.py</code> <pre><code>def __init__(self, config: BaseEngineConfigDict) -&gt; None:\n    \"\"\"Initialize the Euler integration engine.\n\n    Args:\n        config: Configuration dictionary containing engine parameters.\n               See BaseEngineConfigDict for available options.\n    \"\"\"\n    super().__init__(config)\n    self.integration_step_count: int = 0\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.VelocityVerletIntegrationEngine","title":"VelocityVerletIntegrationEngine","text":"<pre><code>VelocityVerletIntegrationEngine(\n    config: BaseEngineConfigDict,\n)\n</code></pre> <p>               Bases: <code>BaseIntegrationEngine[BaseEngineConfigDict]</code></p> <p>Velocity Verlet integration engine for ballistic trajectory calculations.</p> Algorithm Details <p>The method uses a two-stage approach:     1. Update position using current velocity and acceleration.     2. Update velocity using average of current and new acceleration. This ensures velocity and position remain properly synchronized and conserves the total energy of the system.</p> See Also <ul> <li>RK4IntegrationEngine: Higher accuracy alternative</li> <li>EulerIntegrationEngine: Simpler alternative</li> <li>SciPyIntegrationEngine: Adaptive methods</li> </ul> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BaseEngineConfigDict</code>)           \u2013            <p>Configuration dictionary containing engine parameters.    See BaseEngineConfigDict for available options.</p> </li> </ul> Source code in <code>py_ballisticcalc/engines/velocity_verlet.py</code> <pre><code>def __init__(self, config: BaseEngineConfigDict) -&gt; None:\n    \"\"\"Initialize the Velocity Verlet integration engine.\n\n    Args:\n        config: Configuration dictionary containing engine parameters.\n               See BaseEngineConfigDict for available options.\n\n    Examples:\n        &gt;&gt;&gt; config = BaseEngineConfigDict(\n        ...     cStepMultiplier=0.5,\n        ...     cMinimumVelocity=10.0\n        ... )\n        &gt;&gt;&gt; engine = VelocityVerletIntegrationEngine(config)\n    \"\"\"\n    super().__init__(config)\n    self.integration_step_count: int = 0\n</code></pre>"},{"location":"api/calculator/engines/#py_ballisticcalc.engines.SciPyIntegrationEngine","title":"SciPyIntegrationEngine","text":"<pre><code>SciPyIntegrationEngine(_config: SciPyEngineConfigDict)\n</code></pre> <p>               Bases: <code>BaseIntegrationEngine[SciPyEngineConfigDict]</code></p> <p>High-performance ballistic trajectory integration engine using SciPy's solve_ivp.</p> Note <p>Requires scipy and numpy packages. Install with: <code>pip install py_ballisticcalc[scipy]</code> or <code>pip install scipy numpy</code></p> <p>Sets up the engine with the provided configuration dictionary, initializing all necessary parameters for high-precision ballistic trajectory calculations. The configuration is converted to a structured format with appropriate defaults for any unspecified parameters.</p> <p>Parameters:</p> <ul> <li> <code>_config</code>               (<code>SciPyEngineConfigDict</code>)           \u2013            <p>Configuration dictionary containing engine parameters.     Can include SciPy-specific options (integration_method,     tolerances, max_time) as well as all standard BaseEngineConfigDict     parameters (cMinimumVelocity, cStepMultiplier, etc.).</p> <pre><code>SciPy-specific parameters:\n- integration_method: SciPy method ('RK45', 'DOP853', etc.)\n- relative_tolerance: Relative error tolerance (rtol)\n- absolute_tolerance: Absolute error tolerance (atol)\n- max_time: Maximum simulation time in seconds\n\nStandard ballistic parameters:\n- cMinimumVelocity: Minimum velocity to continue calculation\n- cStepMultiplier: Integration step size multiplier\n- cGravityConstant: Gravitational acceleration\n- And other BaseEngineConfigDict parameters\n</code></pre> </li> </ul> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If scipy or numpy packages are not available.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If configuration contains invalid parameters.</p> </li> </ul> Attributes Initialized <ul> <li>_config: Complete configuration with defaults applied</li> <li>gravity_vector: Gravitational acceleration vector</li> <li>integration_step_count: Counter for integration steps (debugging)</li> <li>trajectory_count: Counter for calculated trajectories (debugging)</li> <li>eval_points: List of evaluation points (debugging/analysis)</li> </ul> Note <p>The configuration is processed through create_scipy_engine_config() which applies defaults for any unspecified parameters. This ensures the engine always has a complete, valid configuration.</p> Source code in <code>py_ballisticcalc/engines/scipy_engine.py</code> <pre><code>@override\ndef __init__(self, _config: SciPyEngineConfigDict) -&gt; None:\n    \"\"\"Initialize the SciPy integration engine with configuration.\n\n    Sets up the engine with the provided configuration dictionary, initializing\n    all necessary parameters for high-precision ballistic trajectory calculations.\n    The configuration is converted to a structured format with appropriate\n    defaults for any unspecified parameters.\n\n    Args:\n        _config: Configuration dictionary containing engine parameters.\n                Can include SciPy-specific options (integration_method,\n                tolerances, max_time) as well as all standard BaseEngineConfigDict\n                parameters (cMinimumVelocity, cStepMultiplier, etc.).\n\n                SciPy-specific parameters:\n                - integration_method: SciPy method ('RK45', 'DOP853', etc.)\n                - relative_tolerance: Relative error tolerance (rtol)\n                - absolute_tolerance: Absolute error tolerance (atol)\n                - max_time: Maximum simulation time in seconds\n\n                Standard ballistic parameters:\n                - cMinimumVelocity: Minimum velocity to continue calculation\n                - cStepMultiplier: Integration step size multiplier\n                - cGravityConstant: Gravitational acceleration\n                - And other BaseEngineConfigDict parameters\n\n    Raises:\n        ImportError: If scipy or numpy packages are not available.\n        ValueError: If configuration contains invalid parameters.\n\n    Examples:\n        &gt;&gt;&gt; config = SciPyEngineConfigDict(\n        ...     integration_method='DOP853',\n        ...     relative_tolerance=1e-10,\n        ...     cMinimumVelocity=50.0\n        ... )\n        &gt;&gt;&gt; engine = SciPyIntegrationEngine(config)\n\n    Attributes Initialized:\n        - _config: Complete configuration with defaults applied\n        - gravity_vector: Gravitational acceleration vector\n        - integration_step_count: Counter for integration steps (debugging)\n        - trajectory_count: Counter for calculated trajectories (debugging)\n        - eval_points: List of evaluation points (debugging/analysis)\n\n    Note:\n        The configuration is processed through create_scipy_engine_config()\n        which applies defaults for any unspecified parameters. This ensures\n        the engine always has a complete, valid configuration.\n    \"\"\"\n\n    # dependencies guard\n    if not _HAS_NUMPY:\n        raise ImportError(\"Numpy is required for SciPyIntegrationEngine.\")\n    if not _HAS_SCIPY:\n        raise ImportError(\"SciPy is required for SciPyIntegrationEngine.\")\n\n    self._config: SciPyEngineConfig = create_scipy_engine_config(_config)  # type: ignore\n    self.gravity_vector: Vector = Vector(0.0, self._config.cGravityConstant, 0.0)\n    self.integration_step_count = 0  # Number of evaluations of diff_eq during ._integrate()\n    self.trajectory_count = 0  # Number of trajectories calculated\n    self.eval_points: List[float] = []  # Points at which diff_eq is called\n</code></pre>"},{"location":"api/calculator/interface/","title":"Interface","text":""},{"location":"api/calculator/interface/#py_ballisticcalc.interface.Calculator","title":"Calculator  <code>dataclass</code>","text":"<pre><code>Calculator(\n    config: Optional[ConfigT] = None,\n    engine: EngineProtocolEntry = DEFAULT_ENTRY,\n)\n</code></pre> <p>               Bases: <code>Generic[ConfigT]</code></p> <p>Basic interface for the ballistics calculator.</p> <p>Methods:</p> Name Description <code>barrel_elevation_for_target</code> <p>Calculate barrel elevation to hit target at zero_distance.</p> <code>set_weapon_zero</code> <p>Set shot.weapon.zero_elevation so that it hits a target at zero_distance.</p> <code>fire</code> <p>Calculate the trajectory for the given shot parameters.</p> <code>iter_engines</code> <p>Iterate all available engines in the entry points.</p>"},{"location":"api/calculator/interface/#py_ballisticcalc.interface.Calculator-functions","title":"Functions","text":""},{"location":"api/calculator/interface/#py_ballisticcalc.interface.Calculator.barrel_elevation_for_target","title":"barrel_elevation_for_target","text":"<pre><code>barrel_elevation_for_target(\n    shot: Shot, target_distance: Union[float, Distance]\n) -&gt; Angular\n</code></pre> <p>Calculate barrel elevation to hit target at zero_distance.</p> <p>Parameters:</p> Name Type Description Default <code>shot</code> <code>Shot</code> <p>Shot instance we want to zero.</p> required <code>target_distance</code> <code>Union[float, Distance]</code> <p>Look-distance to \"zero,\" which is point we want to hit. This is the distance that a rangefinder would return with no ballistic adjustment.</p> required Note <p>Some rangefinders offer an adjusted distance based on inclinometer measurement. However, without a complete ballistic model these can only approximate the effects on ballistic trajectory of shooting uphill or downhill. Therefore: For maximum accuracy, use the raw sight distance and look_angle as inputs here.</p> Source code in <code>py_ballisticcalc/interface.py</code> <pre><code>def barrel_elevation_for_target(self, shot: Shot, target_distance: Union[float, Distance]) -&gt; Angular:\n    \"\"\"Calculate barrel elevation to hit target at zero_distance.\n\n    Args:\n        shot: Shot instance we want to zero.\n        target_distance: Look-distance to \"zero,\" which is point we want to hit.\n            This is the distance that a rangefinder would return with no ballistic adjustment.\n\n    Note:\n        Some rangefinders offer an adjusted distance based on inclinometer measurement.\n        However, without a complete ballistic model these can only approximate the effects\n        on ballistic trajectory of shooting uphill or downhill. Therefore:\n        For maximum accuracy, use the raw sight distance and look_angle as inputs here.\n    \"\"\"\n    target_distance = PreferredUnits.distance(target_distance)\n    total_elevation = self._engine_instance.zero_angle(shot, target_distance)\n    return Angular.Radian((total_elevation &gt;&gt; Angular.Radian) - (shot.look_angle &gt;&gt; Angular.Radian))\n</code></pre>"},{"location":"api/calculator/interface/#py_ballisticcalc.interface.Calculator.set_weapon_zero","title":"set_weapon_zero","text":"<pre><code>set_weapon_zero(\n    shot: Shot, zero_distance: Union[float, Distance]\n) -&gt; Angular\n</code></pre> <p>Set shot.weapon.zero_elevation so that it hits a target at zero_distance.</p> <p>Parameters:</p> Name Type Description Default <code>shot</code> <code>Shot</code> <p>Shot instance to zero.</p> required <code>zero_distance</code> <code>Union[float, Distance]</code> <p>Look-distance to \"zero,\" which is point we want to hit.</p> required Source code in <code>py_ballisticcalc/interface.py</code> <pre><code>def set_weapon_zero(self, shot: Shot, zero_distance: Union[float, Distance]) -&gt; Angular:\n    \"\"\"Set shot.weapon.zero_elevation so that it hits a target at zero_distance.\n\n    Args:\n        shot: Shot instance to zero.\n        zero_distance: Look-distance to \"zero,\" which is point we want to hit.\n    \"\"\"\n    shot.weapon.zero_elevation = self.barrel_elevation_for_target(shot, zero_distance)\n    return shot.weapon.zero_elevation\n</code></pre>"},{"location":"api/calculator/interface/#py_ballisticcalc.interface.Calculator.fire","title":"fire","text":"<pre><code>fire(\n    shot: Shot,\n    trajectory_range: Union[float, Distance],\n    trajectory_step: Optional[\n        Union[float, Distance]\n    ] = None,\n    *,\n    extra_data: bool = False,\n    dense_output: bool = False,\n    time_step: float = 0.0,\n    flags: Union[TrajFlag, int] = NONE,\n    raise_range_error: bool = True,\n) -&gt; HitResult\n</code></pre> <p>Calculate the trajectory for the given shot parameters.</p> <p>Parameters:</p> Name Type Description Default <code>shot</code> <code>Shot</code> <p>Shot parameters, including position and barrel angle.</p> required <code>trajectory_range</code> <code>Union[float, Distance]</code> <p>Distance at which to stop computing the trajectory.</p> required <code>trajectory_step</code> <code>Optional[Union[float, Distance]]</code> <p>Distance between recorded trajectory points. Defaults to <code>trajectory_range</code>.</p> <code>None</code> <code>extra_data</code> <code>bool</code> <p>[DEPRECATED] Requests flags=TrajFlags.ALL and trajectory_step=PreferredUnits.distance(1).</p> <code>False</code> <code>dense_output</code> <code>bool</code> <p>HitResult stores all calculation steps so it can interpolate any point.</p> <code>False</code> <code>time_step</code> <code>float</code> <p>Maximum time between recorded points. If &gt; 0, points are recorded at least this frequently.        Defaults to 0.0.</p> <code>0.0</code> <code>flags</code> <code>Union[TrajFlag, int]</code> <p>Flags for specific points of interest. Defaults to TrajFlag.NONE.</p> <code>NONE</code> <code>raise_range_error</code> <code>bool</code> <p>If True, raises RangeError if returned by integration.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>HitResult</code> <code>HitResult</code> <p>Object containing computed trajectory.</p> Source code in <code>py_ballisticcalc/interface.py</code> <pre><code>def fire(\n    self,\n    shot: Shot,\n    trajectory_range: Union[float, Distance],\n    trajectory_step: Optional[Union[float, Distance]] = None,\n    *,\n    extra_data: bool = False,\n    dense_output: bool = False,\n    time_step: float = 0.0,\n    flags: Union[TrajFlag, int] = TrajFlag.NONE,\n    raise_range_error: bool = True,\n) -&gt; HitResult:\n    \"\"\"Calculate the trajectory for the given shot parameters.\n\n    Args:\n        shot: Shot parameters, including position and barrel angle.\n        trajectory_range: Distance at which to stop computing the trajectory.\n        trajectory_step: Distance between recorded trajectory points. Defaults to `trajectory_range`.\n        extra_data: [DEPRECATED] Requests flags=TrajFlags.ALL and trajectory_step=PreferredUnits.distance(1).\n        dense_output: HitResult stores all calculation steps so it can interpolate any point.\n        time_step: Maximum time between recorded points. If &gt; 0, points are recorded at least this frequently.\n                   Defaults to 0.0.\n        flags: Flags for specific points of interest. Defaults to TrajFlag.NONE.\n        raise_range_error: If True, raises RangeError if returned by integration.\n\n    Returns:\n        HitResult: Object containing computed trajectory.\n    \"\"\"\n    trajectory_range = PreferredUnits.distance(trajectory_range)\n    dist_step = trajectory_range\n    filter_flags = flags\n    if trajectory_step:\n        dist_step = PreferredUnits.distance(trajectory_step)\n        filter_flags |= TrajFlag.RANGE\n        if dist_step.raw_value &gt; trajectory_range.raw_value:\n            dist_step = trajectory_range\n\n    if extra_data:\n        warnings.warn(\n            \"extra_data is deprecated and will be removed in future versions. \"\n            \"Explicitly specify desired TrajectoryData frequency and flags.\",\n            DeprecationWarning,\n        )\n        dist_step = PreferredUnits.distance(1.0)  # &lt;&lt; For compatibility with v2.1\n        filter_flags = TrajFlag.ALL\n\n    result = self._engine_instance.integrate(\n        shot, trajectory_range, dist_step, time_step, filter_flags, dense_output=dense_output\n    )\n    if result.error and raise_range_error:\n        raise result.error\n    return result\n</code></pre>"},{"location":"api/calculator/interface/#py_ballisticcalc.interface.Calculator.iter_engines","title":"iter_engines  <code>staticmethod</code>","text":"<pre><code>iter_engines() -&gt; Generator[EntryPoint, None, None]\n</code></pre> <p>Iterate all available engines in the entry points.</p> Source code in <code>py_ballisticcalc/interface.py</code> <pre><code>@staticmethod\ndef iter_engines() -&gt; Generator[EntryPoint, None, None]:\n    \"\"\"Iterate all available engines in the entry points.\"\"\"\n    yield from _EngineLoader.iter_engines()\n</code></pre>"},{"location":"api/calculator/protocol/","title":"Protocol","text":""},{"location":"api/calculator/protocol/#py_ballisticcalc.generics.engine.EngineProtocol","title":"EngineProtocol","text":"<pre><code>EngineProtocol(config: Optional[ConfigT] = None)\n</code></pre> <p>               Bases: <code>Protocol[ConfigT]</code></p> <p>Protocol defining the interface for ballistic trajectory calculation engines.</p> <p>This protocol outlines the methods that any concrete ballistic engine implementation should provide to perform trajectory calculations, retrieve drag model information, and determine zeroing angles for firearms.</p> <p>All engines implementing this protocol can be used interchangeably with the Calculator interface, enabling a modular architecture for different numerical integration methods and calculation approaches.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>ConfigT</code> <p>The configuration type used by this engine implementation.      Must be covariant to support configuration inheritance.</p> required Required Methods <ul> <li>integrate: Perform ballistic trajectory calculation.</li> <li>zero_angle: Calculate zero angle for given distance.</li> </ul> <p>Examples:</p> <pre><code>from py_ballisticcalc.engines.base_engine import BaseEngineConfigDict\n\nclass MyEngine(EngineProtocol[BaseEngineConfigDict]):\n    def __init__(self, config: BaseEngineConfigDict):\n        self.config = config\n\n    def integrate(self, shot_info, max_range, **kwargs):\n        # Implementation here\n        pass\n\n    def zero_angle(self, shot_info, distance):\n        # Implementation here\n        pass\n\nconfig = BaseEngineConfigDict(cStepMultiplier=1.0)\nengine = MyEngine(config)\nisinstance(engine, EngineProtocol)  # True\n</code></pre> See Also <ul> <li>py_ballisticcalc.engines.base_engine.BaseIntegrationEngine: Base implementation</li> <li>py_ballisticcalc.interface.Calculator: Uses EngineProtocol implementations</li> </ul> Note <p>This protocol uses structural subtyping (duck typing) which means any class that implements the required methods will be considered compatible, even if it doesn't explicitly inherit from EngineProtocol. The @runtime_checkable decorator enables isinstance() checks at runtime.</p> <p>Methods:</p> Name Description <code>integrate</code> <p>Perform ballistic trajectory calculation from shot parameters to maximum range.</p> <code>zero_angle</code> <p>Calculate launch angle required to hit target at specified distance.</p> Source code in <code>py_ballisticcalc/generics/engine.py</code> <pre><code>def __init__(self, config: Optional[ConfigT] = None) -&gt; None: ...\n</code></pre>"},{"location":"api/calculator/protocol/#py_ballisticcalc.generics.engine.EngineProtocol-functions","title":"Functions","text":""},{"location":"api/calculator/protocol/#py_ballisticcalc.generics.engine.EngineProtocol.integrate","title":"integrate  <code>abstractmethod</code>","text":"<pre><code>integrate(\n    shot_info: Shot,\n    max_range: Distance,\n    dist_step: Optional[Distance] = None,\n    time_step: float = 0.0,\n    filter_flags: Union[TrajFlag, int] = NONE,\n    dense_output: bool = False,\n    **kwargs: Any,\n) -&gt; HitResult\n</code></pre> <p>Perform ballistic trajectory calculation from shot parameters to maximum range.</p> <p>This method integrates the projectile's equations of motion to generate a complete trajectory from muzzle to the specified maximum range, accounting for gravitational acceleration, atmospheric drag, and environmental conditions.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>Complete shot configuration containing projectile data,       environmental conditions, sight configuration, and firing       parameters. Must include muzzle velocity, ballistic coefficient,       atmospheric conditions, and sight height information.</p> required <code>max_range</code> <code>Distance</code> <p>Maximum distance for trajectory calculation. The integration       continues until the projectile reaches this range or impacts the ground.</p> required <code>dist_step</code> <code>Optional[Distance]</code> <p>Distance interval between trajectory data points. If None,       engine uses default step size for optimal accuracy/performance balance.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time interval for integration steps. Zero means engine       determines optimal step size automatically.</p> <code>0.0</code> <code>filter_flags</code> <code>Union[TrajFlag, int]</code> <p>Trajectory flags to control which data points are included          in the output. Use TrajFlag values to filter specific conditions.</p> <code>NONE</code> <code>dense_output</code> <code>bool</code> <p>If True, return trajectory data at every integration step.          If False, return data only at specified distance intervals.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional engine-specific parameters for specialized calculations.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HitResult</code> <code>HitResult</code> <p>Complete trajectory calculation parameters and results.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shot_info contains invalid or inconsistent parameters.</p> <code>RuntimeError</code> <p>If the numerical integration fails to converge.</p> <code>OutOfRangeError</code> <p>If the requested max_range exceeds computational limits.</p> Mathematical Background <p>The integration solves the vector differential equation for projectile motion under the influence of gravity and atmospheric drag: <pre><code>dV/dt = D * |V| * (V - W) - g\n\nWhere:\n- V = (v_x, v_y, v_z) is velocity relative to the ground\n- W = (w_x, w_y, w_z) is wind velocity vector relative to the ground\n- D = drag factor, which is a function of velocity, atmosphere, and\n        projectile characteristics that include shape and mass\n- g is gravitational acceleration\n</code></pre></p> Typical implementation steps <ol> <li>Initialize state vectors from shot_info parameters</li> <li>Set up integration bounds and step size parameters</li> <li>Begin numerical integration loop using chosen method</li> <li>At each step, calculate drag forces from atmospheric conditions</li> <li>Update position and velocity using integration formulae</li> <li>Check termination conditions (range limit, ground impact)</li> <li>Store trajectory points at specified intervals</li> <li>Return complete trajectory data structure</li> </ol> Source code in <code>py_ballisticcalc/generics/engine.py</code> <pre><code>@abstractmethod\ndef integrate(\n    self,\n    shot_info: Shot,\n    max_range: Distance,\n    dist_step: Optional[Distance] = None,\n    time_step: float = 0.0,\n    filter_flags: Union[TrajFlag, int] = TrajFlag.NONE,\n    dense_output: bool = False,\n    **kwargs: Any,\n) -&gt; HitResult:\n    \"\"\"Perform ballistic trajectory calculation from shot parameters to maximum range.\n\n    This method integrates the projectile's equations of motion to generate\n    a complete trajectory from muzzle to the specified maximum range, accounting\n    for gravitational acceleration, atmospheric drag, and environmental conditions.\n\n    Args:\n        shot_info: Complete shot configuration containing projectile data,\n                  environmental conditions, sight configuration, and firing\n                  parameters. Must include muzzle velocity, ballistic coefficient,\n                  atmospheric conditions, and sight height information.\n        max_range: Maximum distance for trajectory calculation. The integration\n                  continues until the projectile reaches this range or impacts the ground.\n        dist_step: Distance interval between trajectory data points. If None,\n                  engine uses default step size for optimal accuracy/performance balance.\n        time_step: Time interval for integration steps. Zero means engine\n                  determines optimal step size automatically.\n        filter_flags: Trajectory flags to control which data points are included\n                     in the output. Use TrajFlag values to filter specific conditions.\n        dense_output: If True, return trajectory data at every integration step.\n                     If False, return data only at specified distance intervals.\n        **kwargs: Additional engine-specific parameters for specialized calculations.\n\n    Returns:\n        HitResult: Complete trajectory calculation parameters and results.\n\n    Raises:\n        ValueError: If shot_info contains invalid or inconsistent parameters.\n        RuntimeError: If the numerical integration fails to converge.\n        OutOfRangeError: If the requested max_range exceeds computational limits.\n\n    Mathematical Background:\n        The integration solves the vector differential equation for projectile\n        motion under the influence of gravity and atmospheric drag:\n        ```\n        dV/dt = D * |V| * (V - W) - g\n\n        Where:\n        - V = (v_x, v_y, v_z) is velocity relative to the ground\n        - W = (w_x, w_y, w_z) is wind velocity vector relative to the ground\n        - D = drag factor, which is a function of velocity, atmosphere, and\n                projectile characteristics that include shape and mass\n        - g is gravitational acceleration\n        ```\n\n    Typical implementation steps:\n        1. Initialize state vectors from shot_info parameters\n        2. Set up integration bounds and step size parameters\n        3. Begin numerical integration loop using chosen method\n        4. At each step, calculate drag forces from atmospheric conditions\n        5. Update position and velocity using integration formulae\n        6. Check termination conditions (range limit, ground impact)\n        7. Store trajectory points at specified intervals\n        8. Return complete trajectory data structure\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/calculator/protocol/#py_ballisticcalc.generics.engine.EngineProtocol.zero_angle","title":"zero_angle  <code>abstractmethod</code>","text":"<pre><code>zero_angle(shot_info: Shot, distance: Distance) -&gt; Angular\n</code></pre> <p>Calculate launch angle required to hit target at specified distance.</p> <p>Parameters:</p> Name Type Description Default <code>shot_info</code> <code>Shot</code> <p>Complete shot configuration containing projectile data,       environmental conditions, sight configuration, and target       information. Must include muzzle velocity, ballistic coefficient,       atmospheric conditions, sight height, and target height.</p> required <code>distance</code> <code>Distance</code> <p>Horizontal distance to target. Must be within the effective      range of the projectile under the given conditions.</p> required <p>Returns:</p> Name Type Description <code>Angular</code> <code>Angular</code> <p>Launch angle required to hit the target.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shot_info contains invalid parameters or distance        is negative or unreasonably large.</p> <code>ZeroFindingError</code> <p>If the iterative algorithm fails to converge.</p> <code>OutOfRangeError</code> <p>If the target distance exceeds maximum effective range.</p> Note <p>This method returns the lower of the two ballistic solutions hit a target point. To get the higher (\"lofted\") solution we have been adding a .find_zero_angle() method that offers a <code>lofted: bool</code> parameter to select between the two.</p> Mathematical Background <p>The method solves the equation <code>f(\u03b8) = 0</code> where: <pre><code>f(\u03b8) = y(target_distance, \u03b8) - target_height\n\nWhere y(x, \u03b8) is the trajectory height function at distance x for\nlaunch angle \u03b8. This requires iterative solution since the trajectory\nequation cannot be solved analytically for arbitrary drag functions.\n</code></pre></p> Typical implementation approach <ol> <li>Establish reasonable bounds for elevation angle search</li> <li>Define target function: trajectory_height(distance) - target_height</li> <li>Use root-finding algorithm (bisection, Newton, etc.)</li> <li>For each iteration, calculate trajectory to target distance</li> <li>Evaluate height difference at target distance</li> <li>Adjust angle estimate based on convergence strategy</li> <li>Continue until convergence tolerance is met</li> <li>Return final angle estimate</li> </ol> Source code in <code>py_ballisticcalc/generics/engine.py</code> <pre><code>@abstractmethod\ndef zero_angle(self, shot_info: Shot, distance: Distance) -&gt; Angular:\n    \"\"\"Calculate launch angle required to hit target at specified distance.\n\n    Args:\n        shot_info: Complete shot configuration containing projectile data,\n                  environmental conditions, sight configuration, and target\n                  information. Must include muzzle velocity, ballistic coefficient,\n                  atmospheric conditions, sight height, and target height.\n        distance: Horizontal distance to target. Must be within the effective\n                 range of the projectile under the given conditions.\n\n    Returns:\n        Angular: Launch angle required to hit the target.\n\n    Raises:\n        ValueError: If shot_info contains invalid parameters or distance\n                   is negative or unreasonably large.\n        ZeroFindingError: If the iterative algorithm fails to converge.\n        OutOfRangeError: If the target distance exceeds maximum effective range.\n\n    Note:\n        This method returns the lower of the two ballistic solutions hit a target point.\n        To get the higher (\"lofted\") solution we have been adding a .find_zero_angle()\n        method that offers a `lofted: bool` parameter to select between the two.\n\n    Mathematical Background:\n        The method solves the equation `f(\u03b8) = 0` where:\n        ```\n        f(\u03b8) = y(target_distance, \u03b8) - target_height\n\n        Where y(x, \u03b8) is the trajectory height function at distance x for\n        launch angle \u03b8. This requires iterative solution since the trajectory\n        equation cannot be solved analytically for arbitrary drag functions.\n        ```\n\n    Typical implementation approach:\n        1. Establish reasonable bounds for elevation angle search\n        2. Define target function: trajectory_height(distance) - target_height\n        3. Use root-finding algorithm (bisection, Newton, etc.)\n        4. For each iteration, calculate trajectory to target distance\n        5. Evaluate height difference at target distance\n        6. Adjust angle estimate based on convergence strategy\n        7. Continue until convergence tolerance is met\n        8. Return final angle estimate\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/conditions/atmo/","title":"Atmo","text":""},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo","title":"Atmo","text":"<pre><code>Atmo(\n    altitude: Optional[Union[float, Distance]] = None,\n    pressure: Optional[Union[float, Pressure]] = None,\n    temperature: Optional[Union[float, Temperature]] = None,\n    humidity: float = 0.0,\n    powder_t: Optional[Union[float, Temperature]] = None,\n)\n</code></pre> <p>Atmospheric conditions and density calculations.</p> <p>This class encapsulates atmospheric conditions (altitude, pressure, temperature, relative humidity) and provides helpers to derive air density ratio, actual densities, and local speed of sound (Mach 1). The instance stores an internal \"base\" altitude/pressure/temperature snapshot (<code>_a0</code>, <code>_p0</code>, <code>_t0</code>) used to interpolate conditions at other altitudes using lapse-rate models.</p> <p>Attributes:</p> Name Type Description <code>altitude</code> <code>Distance</code> <p>Altitude relative to sea level.</p> <code>pressure</code> <code>Pressure</code> <p>Unadjusted barometric (station) pressure.</p> <code>temperature</code> <code>Temperature</code> <p>Ambient air temperature.</p> <code>humidity</code> <code>float</code> <p>Relative humidity expressed either as fraction [0..1] or percent [0..100].</p> <code>powder_temp</code> <code>Temperature</code> <p>Powder temperature (may differ from ambient when powder sensitivity enabled).</p> <code>density_ratio</code> <code>float</code> <p>Ratio of local air density to standard density.</p> <code>mach</code> <code>Velocity</code> <p>Local speed of sound (Mach 1).</p> <code>density_metric</code> <code>float</code> <p>Air density in kg/m^3.</p> <code>density_imperial</code> <code>float</code> <p>Air density in lb/ft^3.</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Optional[Union[float, Distance]]</code> <p>Altitude relative to sea level. Defaults to 0.</p> <code>None</code> <code>pressure</code> <code>Optional[Union[float, Pressure]]</code> <p>Station pressure (unadjusted). Defaults to standard pressure for altitude.</p> <code>None</code> <code>temperature</code> <code>Optional[Union[float, Temperature]]</code> <p>Ambient temperature. Defaults to standard temperature for altitude.</p> <code>None</code> <code>humidity</code> <code>float</code> <p>Relative humidity (fraction or percent). Defaults to 0.</p> <code>0.0</code> <code>powder_t</code> <code>Optional[Union[float, Temperature]]</code> <p>Powder (propellant) temperature. Defaults to ambient temperature.</p> <code>None</code> Example <pre><code>from py_ballisticcalc import Atmo, Unit\natmo = Atmo(\n    altitude=Unit.Meter(100),\n    pressure=Unit.hPa(1000),\n    temperature=Unit.Celsius(20),\n    humidity=50,\n    powder_t=Unit.Celsius(15)\n)\n</code></pre> Notes <p>The constructor caches base conditions (<code>_t0</code> in \u00b0C, <code>_p0</code> in hPa, <code>_a0</code> in feet) and computes associated <code>_mach</code> and <code>_density_ratio</code>. Subsequent changes to humidity trigger an automatic density recomputation.</p> <p>Methods:</p> Name Description <code>update_density_ratio</code> <p>Recompute density ratio for changed humidity.</p> <code>temperature_at_altitude</code> <p>Interpolate temperature (\u00b0C) at altitude using lapse rate.</p> <code>pressure_at_altitude</code> <p>Interpolate pressure (hPa) at altitude using barometric formula.</p> <code>get_density_and_mach_for_altitude</code> <p>Compute density ratio and Mach (fps) for the specified altitude.</p> <code>standard_temperature</code> <p>ICAO standard temperature for altitude (valid to ~36,000 ft).</p> <code>standard_pressure</code> <p>ICAO standard pressure for altitude (valid to ~36,000 ft).</p> <code>icao</code> <p>Create a standard ICAO atmosphere at altitude.</p> <code>machF</code> <p>Mach 1 (fps) for given Fahrenheit temperature.</p> <code>machC</code> <p>Mach 1 (m/s) for given Celsius temperature.</p> <code>machK</code> <p>Mach 1 (m/s) for given Kelvin temperature.</p> <code>calculate_air_density</code> <p>Air density from temperature (\u00b0C), pressure (hPa), and humidity.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(\n    self,\n    altitude: Optional[Union[float, Distance]] = None,\n    pressure: Optional[Union[float, Pressure]] = None,\n    temperature: Optional[Union[float, Temperature]] = None,\n    humidity: float = 0.0,\n    powder_t: Optional[Union[float, Temperature]] = None,\n):\n    \"\"\"Initialize an `Atmo` instance.\n\n    Args:\n        altitude: Altitude relative to sea level. Defaults to 0.\n        pressure: Station pressure (unadjusted). Defaults to standard pressure for altitude.\n        temperature: Ambient temperature. Defaults to standard temperature for altitude.\n        humidity: Relative humidity (fraction or percent). Defaults to 0.\n        powder_t: Powder (propellant) temperature. Defaults to ambient temperature.\n\n    Example:\n        ```python\n        from py_ballisticcalc import Atmo, Unit\n        atmo = Atmo(\n            altitude=Unit.Meter(100),\n            pressure=Unit.hPa(1000),\n            temperature=Unit.Celsius(20),\n            humidity=50,\n            powder_t=Unit.Celsius(15)\n        )\n        ```\n\n    Notes:\n        The constructor caches base conditions (`_t0` in \u00b0C, `_p0` in hPa, `_a0` in feet) and computes associated\n        `_mach` and `_density_ratio`. Subsequent changes to humidity trigger an automatic density recomputation.\n    \"\"\"\n    self._initializing = True\n    self._altitude = PreferredUnits.distance(altitude or 0)\n    self._pressure = PreferredUnits.pressure(pressure or Atmo.standard_pressure(self._altitude))\n    self._temperature = PreferredUnits.temperature(temperature or Atmo.standard_temperature(self._altitude))\n    # If powder_temperature not provided we use atmospheric temperature:\n    self._powder_temp = PreferredUnits.temperature(powder_t or self._temperature)\n    self._t0 = self._temperature &gt;&gt; Temperature.Celsius\n    self._p0 = self._pressure &gt;&gt; Pressure.hPa\n    self._a0 = self._altitude &gt;&gt; Distance.Foot\n    self._mach = Atmo.machF(self._temperature &gt;&gt; Temperature.Fahrenheit)\n    self.humidity = humidity\n    self._initializing = False\n    self.update_density_ratio()\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo-attributes","title":"Attributes","text":""},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.altitude","title":"altitude  <code>property</code>","text":"<pre><code>altitude: Distance\n</code></pre> <p>Altitude relative to sea level.</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.pressure","title":"pressure  <code>property</code>","text":"<pre><code>pressure: Pressure\n</code></pre> <p>Station barometric pressure (not altitude adjusted).</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: Temperature\n</code></pre> <p>Air temperature.</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.powder_temp","title":"powder_temp  <code>property</code>","text":"<pre><code>powder_temp: Temperature\n</code></pre> <p>Powder temperature (falls back to ambient when unspecified).</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.mach","title":"mach  <code>property</code>","text":"<pre><code>mach: Velocity\n</code></pre> <p>Local speed of sound (Mach 1).</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_ratio","title":"density_ratio  <code>property</code>","text":"<pre><code>density_ratio: float\n</code></pre> <p>Ratio of local density to standard density (dimensionless).</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.humidity","title":"humidity  <code>property</code> <code>writable</code>","text":"<pre><code>humidity: float\n</code></pre> <p>Relative humidity as fraction [0..1].</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_metric","title":"density_metric  <code>property</code>","text":"<pre><code>density_metric: float\n</code></pre> <p>Air density in metric units (kg/m^3).</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_imperial","title":"density_imperial  <code>property</code>","text":"<pre><code>density_imperial: float\n</code></pre> <p>Air density in imperial units (lb/ft^3).</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo-functions","title":"Functions","text":""},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.update_density_ratio","title":"update_density_ratio","text":"<pre><code>update_density_ratio() -&gt; None\n</code></pre> <p>Recompute density ratio for changed humidity.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def update_density_ratio(self) -&gt; None:\n    \"\"\"Recompute density ratio for changed humidity.\"\"\"\n    self._density_ratio = Atmo.calculate_air_density(self._t0, self._p0, self.humidity) / cStandardDensityMetric\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.temperature_at_altitude","title":"temperature_at_altitude","text":"<pre><code>temperature_at_altitude(altitude: float) -&gt; float\n</code></pre> <p>Interpolate temperature (\u00b0C) at altitude using lapse rate.</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>Altitude above mean sea level (ft).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature in degrees Celsius (bounded by model lower limit).</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def temperature_at_altitude(self, altitude: float) -&gt; float:\n    \"\"\"Interpolate temperature (\u00b0C) at altitude using lapse rate.\n\n    Args:\n        altitude: Altitude above mean sea level (ft).\n\n    Returns:\n        Temperature in degrees Celsius (bounded by model lower limit).\n    \"\"\"\n    t = (altitude - self._a0) * cLapseRateKperFoot + self._t0\n    if t &lt; Atmo.cLowestTempC:\n        t = Atmo.cLowestTempC\n        warnings.warn(\n            f\"Temperature interpolated from altitude fell below minimum model limit. Bounded at {cLowestTempF}\u00b0F.\",\n            RuntimeWarning,\n        )\n    return t\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.pressure_at_altitude","title":"pressure_at_altitude","text":"<pre><code>pressure_at_altitude(altitude: float) -&gt; float\n</code></pre> <p>Interpolate pressure (hPa) at altitude using barometric formula.</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>Altitude above mean sea level (ft).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Pressure in hPa.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def pressure_at_altitude(self, altitude: float) -&gt; float:\n    \"\"\"Interpolate pressure (hPa) at altitude using barometric formula.\n\n    Args:\n        altitude: Altitude above mean sea level (ft).\n\n    Returns:\n        Pressure in hPa.\n    \"\"\"\n    return self._p0 * math.pow(\n        1 + cLapseRateKperFoot * (altitude - self._a0) / (self._t0 + cDegreesCtoK), cPressureExponent\n    )\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.get_density_and_mach_for_altitude","title":"get_density_and_mach_for_altitude","text":"<pre><code>get_density_and_mach_for_altitude(\n    altitude: float,\n) -&gt; Tuple[float, float]\n</code></pre> <p>Compute density ratio and Mach (fps) for the specified altitude.</p> <p>Uses lapse-rate interpolation unless altitude is within 30 ft of the base altitude,     in which case the initial cached values are used for performance.</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>float</code> <p>Altitude above mean sea level (ft).</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple (density_ratio, mach_fps).</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def get_density_and_mach_for_altitude(self, altitude: float) -&gt; Tuple[float, float]:\n    \"\"\"Compute density ratio and Mach (fps) for the specified altitude.\n\n    Uses lapse-rate interpolation unless altitude is within 30 ft of the base altitude,\n        in which case the initial cached values are used for performance.\n\n    Args:\n        altitude: Altitude above mean sea level (ft).\n\n    Returns:\n        Tuple (density_ratio, mach_fps).\n    \"\"\"\n    if math.fabs(self._a0 - altitude) &lt; 30:  # fast path near base altitude\n        return self._density_ratio, self._mach\n\n    if altitude &gt; 36089:  # troposphere limit ~36k ft\n        warnings.warn(\n            \"Density request for altitude above modeled troposphere. Atmospheric model not valid here.\",\n            RuntimeWarning,\n        )\n\n    t_k = self.temperature_at_altitude(altitude) + cDegreesCtoK\n    mach = Velocity.MPS(Atmo.machK(t_k)) &gt;&gt; Velocity.FPS\n    p = self.pressure_at_altitude(altitude)\n    density_delta = ((self._t0 + cDegreesCtoK) * p) / (self._p0 * t_k)\n    density_ratio = self._density_ratio * density_delta\n    # Alternative simplified exponential model (retained for reference):\n    # density_ratio = self._density_ratio * math.exp(-(altitude - self._a0) / 34122)\n    return density_ratio, mach\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard_temperature","title":"standard_temperature  <code>staticmethod</code>","text":"<pre><code>standard_temperature(altitude: Distance) -&gt; Temperature\n</code></pre> <p>ICAO standard temperature for altitude (valid to ~36,000 ft).</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef standard_temperature(altitude: Distance) -&gt; Temperature:\n    \"\"\"ICAO standard temperature for altitude (valid to ~36,000 ft).\"\"\"\n    return Temperature.Fahrenheit(cStandardTemperatureF + (altitude &gt;&gt; Distance.Foot) * cLapseRateImperial)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard_pressure","title":"standard_pressure  <code>staticmethod</code>","text":"<pre><code>standard_pressure(altitude: Distance) -&gt; Pressure\n</code></pre> <p>ICAO standard pressure for altitude (valid to ~36,000 ft).</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef standard_pressure(altitude: Distance) -&gt; Pressure:\n    \"\"\"ICAO standard pressure for altitude (valid to ~36,000 ft).\"\"\"\n    return Pressure.hPa(\n        cStandardPressureMetric\n        * math.pow(\n            1 + cLapseRateMetric * (altitude &gt;&gt; Distance.Meter) / (cStandardTemperatureC + cDegreesCtoK),\n            cPressureExponent,\n        )\n    )\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.icao","title":"icao  <code>staticmethod</code>","text":"<pre><code>icao(\n    altitude: Union[float, Distance] = 0,\n    temperature: Optional[Temperature] = None,\n    humidity: float = cStandardHumidity,\n) -&gt; Atmo\n</code></pre> <p>Create a standard ICAO atmosphere at altitude.</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Union[float, Distance]</code> <p>Altitude (defaults to sea level).</p> <code>0</code> <code>temperature</code> <code>Optional[Temperature]</code> <p>Optional override temperature (defaults to standard at altitude).</p> <code>None</code> <code>humidity</code> <code>float</code> <p>Relative humidity (fraction or percent). Defaults to standard humidity.</p> <code>cStandardHumidity</code> <p>Returns:</p> Type Description <code>Atmo</code> <p>Atmo instance representing standard atmosphere at altitude.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef icao(\n    altitude: Union[float, Distance] = 0,\n    temperature: Optional[Temperature] = None,\n    humidity: float = cStandardHumidity,\n) -&gt; Atmo:\n    \"\"\"Create a standard ICAO atmosphere at altitude.\n\n    Args:\n        altitude: Altitude (defaults to sea level).\n        temperature: Optional override temperature (defaults to standard at altitude).\n        humidity: Relative humidity (fraction or percent). Defaults to standard humidity.\n\n    Returns:\n        Atmo instance representing standard atmosphere at altitude.\n    \"\"\"\n    altitude = PreferredUnits.distance(altitude)\n    temperature = temperature or Atmo.standard_temperature(altitude)\n    pressure = Atmo.standard_pressure(altitude)\n    return Atmo(altitude, pressure, temperature, humidity)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machF","title":"machF  <code>staticmethod</code>","text":"<pre><code>machF(fahrenheit: float) -&gt; float\n</code></pre> <p>Mach 1 (fps) for given Fahrenheit temperature.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef machF(fahrenheit: float) -&gt; float:\n    \"\"\"Mach 1 (fps) for given Fahrenheit temperature.\"\"\"\n    if fahrenheit &lt; -cDegreesFtoR:\n        bad_temp = fahrenheit\n        fahrenheit = cLowestTempF\n        warnings.warn(f\"Invalid temperature: {bad_temp}\u00b0F. Adjusted to ({cLowestTempF}\u00b0F).\", RuntimeWarning)\n    return math.sqrt(fahrenheit + cDegreesFtoR) * cSpeedOfSoundImperial\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machC","title":"machC  <code>staticmethod</code>","text":"<pre><code>machC(celsius: float) -&gt; float\n</code></pre> <p>Mach 1 (m/s) for given Celsius temperature.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef machC(celsius: float) -&gt; float:\n    \"\"\"Mach 1 (m/s) for given Celsius temperature.\"\"\"\n    if celsius &lt; -cDegreesCtoK:\n        bad_temp = celsius\n        celsius = Atmo.cLowestTempC\n        warnings.warn(f\"Invalid temperature: {bad_temp}\u00b0C. Adjusted to ({celsius}\u00b0C).\", RuntimeWarning)\n    return Atmo.machK(celsius + cDegreesCtoK)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machK","title":"machK  <code>staticmethod</code>","text":"<pre><code>machK(kelvin: float) -&gt; float\n</code></pre> <p>Mach 1 (m/s) for given Kelvin temperature.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef machK(kelvin: float) -&gt; float:\n    \"\"\"Mach 1 (m/s) for given Kelvin temperature.\"\"\"\n    if kelvin &lt; 0:\n        bad_temp = kelvin\n        kelvin = Atmo.cLowestTempC + cDegreesCtoK\n        warnings.warn(f\"Invalid temperature: {bad_temp}K. Adjusted to ({kelvin}K).\", RuntimeWarning)\n    return math.sqrt(kelvin) * cSpeedOfSoundMetric\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.calculate_air_density","title":"calculate_air_density  <code>staticmethod</code>","text":"<pre><code>calculate_air_density(\n    t: float, p_hpa: float, humidity: float\n) -&gt; float\n</code></pre> <p>Air density from temperature (\u00b0C), pressure (hPa), and humidity.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Temperature in degrees Celsius.</p> required <code>p_hpa</code> <code>float</code> <p>Pressure in hPa (hectopascals). Internally converted to Pa.</p> required <code>humidity</code> <code>float</code> <p>Relative humidity (fraction or percent).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Air density in kg/m\u00b3.</p> Notes <ul> <li>Divide result by <code>cDensityImperialToMetric</code> to get density in lb/ft\u00b3.</li> <li>Source: CIPM-2007 (https://www.nist.gov/system/files/documents/calibrations/CIPM-2007.pdf)</li> </ul> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@staticmethod\ndef calculate_air_density(t: float, p_hpa: float, humidity: float) -&gt; float:\n    \"\"\"Air density from temperature (\u00b0C), pressure (hPa), and humidity.\n\n    Args:\n        t: Temperature in degrees Celsius.\n        p_hpa: Pressure in hPa (hectopascals). Internally converted to Pa.\n        humidity: Relative humidity (fraction or percent).\n\n    Returns:\n        Air density in kg/m\u00b3.\n\n    Notes:\n        - Divide result by `cDensityImperialToMetric` to get density in lb/ft\u00b3.\n        - Source: CIPM-2007 (https://www.nist.gov/system/files/documents/calibrations/CIPM-2007.pdf)\n    \"\"\"\n    R = 8.314472  # J/(mol\u00b7K), universal gas constant\n    M_a = 28.96546e-3  # kg/mol, molar mass of dry air\n    M_v = 18.01528e-3  # kg/mol, molar mass of water vapor\n\n    def saturation_vapor_pressure(T):  # noqa: N802 (retain formula variable naming)\n        A = [1.2378847e-5, -1.9121316e-2, 33.93711047, -6.3431645e3]\n        return math.exp(A[0] * T**2 + A[1] * T + A[2] + A[3] / T)\n\n    def enhancement_factor(p, T):  # noqa: N802\n        alpha = 1.00062\n        beta = 3.14e-8\n        gamma = 5.6e-7\n        return alpha + beta * p + gamma * T**2\n\n    def compressibility_factor(p, T, x_v):  # noqa: N802\n        a0 = 1.58123e-6\n        a1 = -2.9331e-8\n        a2 = 1.1043e-10\n        b0 = 5.707e-6\n        b1 = -2.051e-8\n        c0 = 1.9898e-4\n        c1 = -2.376e-6\n        d = 1.83e-11\n        e = -0.765e-8\n        t_l = T - cDegreesCtoK\n        Z = (\n            1\n            - (p / T) * (a0 + a1 * t_l + a2 * t_l**2 + (b0 + b1 * t_l) * x_v + (c0 + c1 * t_l) * x_v**2)\n            + (p / T) ** 2 * (d + e * x_v**2)\n        )\n        return Z\n\n    # Normalize humidity to fraction [0..1]\n    rh = float(humidity)\n    rh_frac = rh / 100.0 if rh &gt; 1.0 else rh\n    rh_frac = max(0.0, min(1.0, rh_frac))\n\n    # Convert inputs for CIPM equations\n    T_K = t + cDegreesCtoK  # Kelvin\n    p = float(p_hpa) * 100.0  # hPa -&gt; Pa\n\n    # Calculation of saturated vapor pressure and enhancement factor\n    p_sv = saturation_vapor_pressure(T_K)  # Pa (saturated vapor pressure)\n    f = enhancement_factor(p, t)  # Enhancement factor (p in Pa, t in \u00b0C)\n\n    # Partial pressure of water vapor and mole fraction\n    p_v = rh_frac * f * p_sv  # Pa\n    x_v = p_v / p  # Mole fraction of water vapor\n\n    # Calculation of compressibility factor\n    Z = compressibility_factor(p, T_K, x_v)\n    return (p * M_a) / (Z * R * T_K) * (1.0 - x_v * (1.0 - M_v / M_a))\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Vacuum","title":"Vacuum","text":"<pre><code>Vacuum(\n    altitude: Optional[Union[float, Distance]] = None,\n    temperature: Optional[Union[float, Temperature]] = None,\n)\n</code></pre> <p>               Bases: <code>Atmo</code></p> <p>Vacuum atmosphere (zero density =&gt; zero drag).</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(\n    self, altitude: Optional[Union[float, Distance]] = None, temperature: Optional[Union[float, Temperature]] = None\n):\n    super().__init__(altitude, 0, temperature, 0)\n    self._pressure = PreferredUnits.pressure(0)\n    self._density_ratio = 0\n</code></pre>"},{"location":"api/conditions/shot/","title":"Shot","text":""},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot","title":"Shot  <code>dataclass</code>","text":"<pre><code>Shot(\n    *,\n    ammo: Ammo,\n    atmo: Optional[Atmo] = None,\n    weapon: Optional[Weapon] = None,\n    winds: Optional[Sequence[Wind]] = None,\n    look_angle: Optional[Union[float, Angular]] = None,\n    relative_angle: Optional[Union[float, Angular]] = None,\n    cant_angle: Optional[Union[float, Angular]] = None,\n    azimuth: Optional[float] = None,\n    latitude: Optional[float] = None,\n)\n</code></pre> <p>All information needed to compute a ballistic trajectory.</p> <p>Attributes:</p> Name Type Description <code>ammo</code> <code>Ammo</code> <p>Ammo used for shot.</p> <code>atmo</code> <code>Atmo</code> <p>Atmosphere in effect during shot.</p> <code>weapon</code> <code>Weapon</code> <p>Weapon used for shot.</p> <code>winds</code> <code>Sequence[Wind]</code> <p>List of Wind in effect during shot, sorted by <code>.until_distance</code>.</p> <code>look_angle</code> <code>slant_angle</code> <p>Angle of sight line relative to horizontal. If <code>look_angle != 0</code> then any target in sight crosshairs will be at a different altitude:     With target_distance = sight distance to a target (i.e., as through a rangefinder):         * Horizontal distance X to target = cos(look_angle) * target_distance         * Vertical distance Y to target = sin(look_angle) * target_distance</p> <code>cant_angle</code> <code>Angular</code> <p>Tilt of gun from vertical. If <code>weapon.sight_height != 0</code> then this shifts any barrel elevation from the vertical plane into the horizontal plane (as <code>barrel_azimuth</code>) by <code>sine(cant_angle)</code>.</p> <code>relative_angle</code> <code>Angular</code> <p>Elevation adjustment (a.k.a. \"hold\") added to <code>weapon.zero_elevation</code>.</p> <code>azimuth</code> <code>Optional[float]</code> <p>Azimuth of the shooting direction in degrees [0, 360). Optional, for Coriolis effects. Should be geographic bearing where 0 = North, 90 = East, 180 = South, 270 = West. Difference from magnetic bearing is usually negligible.</p> <code>latitude</code> <code>Optional[float]</code> <p>Latitude of the shooting location in degrees [-90, 90]. Optional, for Coriolis effects.</p> <code>barrel_elevation</code> <code>Angular</code> <p>Total barrel elevation (in vertical plane) from horizontal. <code>= look_angle + cos(cant_angle) * zero_elevation + relative_angle</code></p> <code>barrel_azimuth</code> <code>Angular</code> <p>Horizontal angle of barrel relative to sight line.</p> <p>Parameters:</p> Name Type Description Default <code>ammo</code> <code>Ammo</code> <p>Ammo instance used for shot.</p> required <code>atmo</code> <code>Optional[Atmo]</code> <p>Atmosphere in effect during shot.</p> <code>None</code> <code>weapon</code> <code>Optional[Weapon]</code> <p>Weapon instance used for shot.</p> <code>None</code> <code>winds</code> <code>Optional[Sequence[Wind]]</code> <p>List of Wind in effect during shot.</p> <code>None</code> <code>look_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Angle of sight line relative to horizontal. If <code>look_angle != 0</code> then any target in sight crosshairs will be at a different altitude:     With target_distance = sight distance to a target (i.e., as through a rangefinder):         * Horizontal distance X to target = cos(look_angle) * target_distance         * Vertical distance Y to target = sin(look_angle) * target_distance</p> <code>None</code> <code>cant_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Tilt of gun from vertical. If <code>weapon.sight_height != 0</code> then this shifts any barrel elevation from the vertical plane into the horizontal plane (as <code>barrel_azimuth</code>) by <code>sine(cant_angle)</code>.</p> <code>None</code> <code>relative_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Elevation adjustment (a.k.a. \"hold\") added to <code>weapon.zero_elevation</code>.</p> <code>None</code> <code>azimuth</code> <code>Optional[float]</code> <p>Azimuth of the shooting direction in degrees [0, 360). Optional, for Coriolis effects. Should be geographic bearing where 0 = North, 90 = East, 180 = South, 270 = West. Difference from magnetic bearing is usually negligible.</p> <code>None</code> <code>latitude</code> <code>Optional[float]</code> <p>Latitude of the shooting location in degrees [-90, 90]. Optional, for Coriolis effects.</p> <code>None</code> Example <pre><code>from py_ballisticcalc import Weapon, Ammo, Atmo, Wind, Unit, Shot\nshot = Shot(\n    ammo=Ammo(...),\n    atmo=Atmo(...),\n    weapon=Weapon(...),\n    winds=[Wind(...), ... ]\n    look_angle=Unit.Degree(5),\n    cant_angle=Unit.Degree(0),\n    relative_angle=Unit.Degree(1),\n    azimuth=90.0,  # East\n    latitude=45.0  # 45\u00b0 North\n)\n</code></pre> Source code in <code>py_ballisticcalc/shot.py</code> <pre><code>def __init__(\n    self,\n    *,\n    ammo: Ammo,\n    atmo: Optional[Atmo] = None,\n    weapon: Optional[Weapon] = None,\n    winds: Optional[Sequence[Wind]] = None,\n    look_angle: Optional[Union[float, Angular]] = None,\n    relative_angle: Optional[Union[float, Angular]] = None,\n    cant_angle: Optional[Union[float, Angular]] = None,\n    azimuth: Optional[float] = None,\n    latitude: Optional[float] = None,\n):\n    \"\"\"Initialize `Shot` for trajectory calculations.\n\n    Args:\n        ammo: Ammo instance used for shot.\n        atmo: Atmosphere in effect during shot.\n        weapon: Weapon instance used for shot.\n        winds: List of Wind in effect during shot.\n        look_angle: Angle of sight line relative to horizontal.\n            If `look_angle != 0` then any target in sight crosshairs will be at a different altitude:\n                With target_distance = sight distance to a target (i.e., as through a rangefinder):\n                    * Horizontal distance X to target = cos(look_angle) * target_distance\n                    * Vertical distance Y to target = sin(look_angle) * target_distance\n        cant_angle: Tilt of gun from vertical. If `weapon.sight_height != 0` then this shifts any barrel elevation\n            from the vertical plane into the horizontal plane (as `barrel_azimuth`) by `sine(cant_angle)`.\n        relative_angle: Elevation adjustment (a.k.a. \"hold\") added to `weapon.zero_elevation`.\n        azimuth: Azimuth of the shooting direction in degrees [0, 360). Optional, for Coriolis effects.\n            Should be geographic bearing where 0 = North, 90 = East, 180 = South, 270 = West.\n            Difference from magnetic bearing is usually negligible.\n        latitude: Latitude of the shooting location in degrees [-90, 90]. Optional, for Coriolis effects.\n\n    Example:\n        ```python\n        from py_ballisticcalc import Weapon, Ammo, Atmo, Wind, Unit, Shot\n        shot = Shot(\n            ammo=Ammo(...),\n            atmo=Atmo(...),\n            weapon=Weapon(...),\n            winds=[Wind(...), ... ]\n            look_angle=Unit.Degree(5),\n            cant_angle=Unit.Degree(0),\n            relative_angle=Unit.Degree(1),\n            azimuth=90.0,  # East\n            latitude=45.0  # 45\u00b0 North\n        )\n        ```\n    \"\"\"\n    self.ammo = ammo\n    self.atmo = atmo or Atmo.icao()\n    self.weapon = weapon or Weapon()\n    self.winds = winds or [Wind()]\n    self.look_angle = PreferredUnits.angular(look_angle or 0)\n    self.cant_angle = PreferredUnits.angular(cant_angle or 0)\n    self.relative_angle = PreferredUnits.angular(relative_angle or 0)\n    self._azimuth = azimuth\n    self._latitude = latitude\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot-attributes","title":"Attributes","text":""},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot.azimuth","title":"azimuth  <code>property</code> <code>writable</code>","text":"<pre><code>azimuth: Optional[float]\n</code></pre> <p>Azimuth of the shooting direction in degrees [0, 360).</p> <p>Should be geographic bearing where 0 = North, 90 = East, 180 = South, 270 = West.     However, difference from magnetic bearing is usually negligible.</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: Optional[float]\n</code></pre> <p>Latitude of the shooting location in degrees [-90, 90].</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot.winds","title":"winds  <code>property</code> <code>writable</code>","text":"<pre><code>winds: Sequence[Wind]\n</code></pre> <p>Sequence[Wind] sorted by until_distance.</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot.barrel_azimuth","title":"barrel_azimuth  <code>property</code>","text":"<pre><code>barrel_azimuth: Angular\n</code></pre> <p>Horizontal angle of barrel relative to sight line.</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot.barrel_elevation","title":"barrel_elevation  <code>property</code> <code>writable</code>","text":"<pre><code>barrel_elevation: Angular\n</code></pre> <p>Total barrel elevation (in vertical plane) from horizontal.</p> <p>Returns:</p> Type Description <code>Angular</code> <p>Angle of barrel elevation in vertical plane from horizontal <code>= look_angle + cos(cant_angle) * zero_elevation + relative_angle</code></p>"},{"location":"api/conditions/shot/#py_ballisticcalc.shot.Shot.slant_angle","title":"slant_angle  <code>property</code> <code>writable</code>","text":"<pre><code>slant_angle: Angular\n</code></pre> <p>Synonym for look_angle.</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis","title":"Coriolis  <code>dataclass</code>","text":"<pre><code>Coriolis(\n    sin_lat: float,\n    cos_lat: float,\n    sin_az: Optional[float],\n    cos_az: Optional[float],\n    range_east: Optional[float],\n    range_north: Optional[float],\n    cross_east: Optional[float],\n    cross_north: Optional[float],\n    flat_fire_only: bool,\n    muzzle_velocity_fps: float,\n)\n</code></pre> <p>Precomputed Coriolis helpers for applying Earth's rotation.</p> <p>The calculator keeps ballistic state in a local range/up/cross (x, y, z) frame where the x axis points down-range, y points up, and z points to the shooter's right.  Coriolis forces originate in the Earth-fixed East-North-Up (ENU) frame.  This class precumputes the scalars to transform between the two frames.</p> <p>If we are given latitude but not azimuth of the shot, this class falls back on a flat-fire approximation of Coriolis effects: north of the equator the deflection is to the right; south of the equator it is to the left. Given both azimuth \\(A\\) and latitude \\(L\\) we compute the full 3D Coriolis acceleration as:</p> \\[ 2 \\Omega \\begin{bmatrix}     -V_y \\cos(L) \\sin(A) - V_z \\sin(L) \\\\     V_x \\cos(L) \\sin(A) + V_z \\cos(L) \\cos(A) \\\\     V_x \\sin(L) - V_y \\cos(L) \\cos(A) \\end{bmatrix} \\] <p>Attributes:</p> Name Type Description <code>sin_lat</code> <code>float</code> <p>Sine of the firing latitude, used to project the Earth's rotation vector.</p> <code>cos_lat</code> <code>float</code> <p>Cosine of the firing latitude.</p> <code>sin_az</code> <code>Optional[float]</code> <p>Sine of the firing azimuth, or <code>None</code> when azimuth is unknown (flat-fire fallback).</p> <code>cos_az</code> <code>Optional[float]</code> <p>Cosine of the firing azimuth, or <code>None</code> when azimuth is unknown.</p> <code>range_east</code> <code>Optional[float]</code> <p>Projection of the local range axis onto geographic east (None in flat-fire mode).</p> <code>range_north</code> <code>Optional[float]</code> <p>Projection of the local range axis onto geographic north (None in flat-fire mode).</p> <code>cross_east</code> <code>Optional[float]</code> <p>Projection of the local cross axis onto geographic east (None in flat-fire mode).</p> <code>cross_north</code> <code>Optional[float]</code> <p>Projection of the local cross axis onto geographic north (None in flat-fire mode).</p> <code>flat_fire_only</code> <code>bool</code> <p><code>True</code> when no azimuth is provided and only the 2D flat-fire approximation should run.</p> <code>muzzle_velocity_fps</code> <code>float</code> <p>Muzzle velocity in feet per second (only needed by the flat-fire approximation).</p> <p>Methods:</p> Name Description <code>create</code> <p>Build a <code>Coriolis</code> helper for a shot when latitude is available.</p> <code>coriolis_acceleration_local</code> <p>Compute the Coriolis acceleration for a velocity expressed in the local frame.</p> <code>flat_fire_offsets</code> <p>Estimate flat-fire vertical and horizontal corrections.</p> <code>adjust_range</code> <p>Apply the flat-fire offsets to a range vector when necessary.</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis-attributes","title":"Attributes","text":""},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis.full_3d","title":"full_3d  <code>property</code>","text":"<pre><code>full_3d: bool\n</code></pre> <p>Whether full 3D Coriolis model is available (i.e., both azimuth and latitude).</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis-functions","title":"Functions","text":""},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    latitude: Optional[float],\n    azimuth: Optional[float],\n    muzzle_velocity_fps: float,\n) -&gt; Optional[Coriolis]\n</code></pre> <p>Build a <code>Coriolis</code> helper for a shot when latitude is available.</p> <p>Parameters:</p> Name Type Description Default <code>latitude</code> <code>Optional[float]</code> <p>Latitude of the shooting location in degrees [-90, 90].</p> required <code>azimuth</code> <code>Optional[float]</code> <p>Azimuth of the shooting direction in degrees [0, 360).</p> required <code>muzzle_velocity_fps</code> <code>float</code> <p>Muzzle velocity in feet per second for the projectile.</p> required <p>Returns:</p> Type Description <code>Optional[Coriolis]</code> <p>A populated <code>Coriolis</code> instance when the shot specifies a latitude, otherwise <code>None</code>.</p> Notes <p>When azimuth is omitted we fall back to the flat fire approximation, which only corrects for the horizontal drift term that dominates short-range, low-arc engagements.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>@classmethod\ndef create(\n    cls, latitude: Optional[float], azimuth: Optional[float], muzzle_velocity_fps: float\n) -&gt; Optional[Coriolis]:\n    \"\"\"Build a `Coriolis` helper for a shot when latitude is available.\n\n    Args:\n        latitude: Latitude of the shooting location in degrees [-90, 90].\n        azimuth: Azimuth of the shooting direction in degrees [0, 360).\n        muzzle_velocity_fps: Muzzle velocity in feet per second for the projectile.\n\n    Returns:\n        A populated `Coriolis` instance when the shot specifies a latitude, otherwise `None`.\n\n    Notes:\n        When azimuth is omitted we fall back to the *flat fire* approximation, which only corrects\n        for the horizontal drift term that dominates short-range, low-arc engagements.\n    \"\"\"\n    if latitude is None:\n        return None\n\n    lat_rad = math.radians(latitude)\n    sin_lat = math.sin(lat_rad)\n    cos_lat = math.cos(lat_rad)\n\n    if azimuth is None:\n        return cls(\n            sin_lat=sin_lat,\n            cos_lat=cos_lat,\n            muzzle_velocity_fps=muzzle_velocity_fps,\n            sin_az=None,\n            cos_az=None,\n            range_east=None,\n            range_north=None,\n            cross_east=None,\n            cross_north=None,\n            flat_fire_only=True,\n        )\n\n    azimuth_rad = math.radians(azimuth)\n\n    return cls(\n        sin_lat=sin_lat,\n        cos_lat=cos_lat,\n        muzzle_velocity_fps=muzzle_velocity_fps,\n        sin_az=math.sin(azimuth_rad),\n        cos_az=math.cos(azimuth_rad),\n        range_east=math.sin(azimuth_rad),\n        range_north=math.cos(azimuth_rad),\n        cross_east=math.cos(azimuth_rad),\n        cross_north=-math.sin(azimuth_rad),\n        flat_fire_only=False,\n    )\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis.coriolis_acceleration_local","title":"coriolis_acceleration_local","text":"<pre><code>coriolis_acceleration_local(velocity: Vector) -&gt; Vector\n</code></pre> <p>Compute the Coriolis acceleration for a velocity expressed in the local frame.</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>Vector</code> <p>Projectile velocity vector in the local range/up/cross basis (feet per second).</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>A <code>Vector</code> containing the Coriolis acceleration components in the same local basis.</p> <code>Vector</code> <p>Returns the <code>ZERO_VECTOR</code> when only the flat-fire approximation is available.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def coriolis_acceleration_local(self, velocity: Vector) -&gt; Vector:\n    \"\"\"Compute the Coriolis acceleration for a velocity expressed in the local frame.\n\n    Args:\n        velocity: Projectile velocity vector in the local range/up/cross basis (feet per second).\n\n    Returns:\n        A `Vector` containing the Coriolis acceleration components in the same local basis.\n        Returns the `ZERO_VECTOR` when only the flat-fire approximation is available.\n    \"\"\"\n    if not self.full_3d:\n        return ZERO_VECTOR\n\n    assert self.range_east is not None and self.range_north is not None\n    assert self.cross_east is not None and self.cross_north is not None\n\n    vel_east = velocity.x * self.range_east + velocity.z * self.cross_east\n    vel_north = velocity.x * self.range_north + velocity.z * self.cross_north\n    vel_up = velocity.y\n\n    factor = -2.0 * cEarthAngularVelocityRadS\n    accel_east = factor * (self.cos_lat * vel_up - self.sin_lat * vel_north)\n    accel_north = factor * (self.sin_lat * vel_east)\n    accel_up = factor * (-self.cos_lat * vel_east)\n\n    accel_range = accel_east * self.range_east + accel_north * self.range_north\n    accel_cross = accel_east * self.cross_east + accel_north * self.cross_north\n    return Vector(accel_range, accel_up, accel_cross)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis.flat_fire_offsets","title":"flat_fire_offsets","text":"<pre><code>flat_fire_offsets(\n    time: float, distance_ft: float, drop_ft: float\n) -&gt; Tuple[float, float]\n</code></pre> <p>Estimate flat-fire vertical and horizontal corrections.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Time of flight in seconds for the sample point.</p> required <code>distance_ft</code> <code>float</code> <p>Down-range distance in feet at the sample point.</p> required <code>drop_ft</code> <code>float</code> <p>Local vertical displacement in feet (positive is up).</p> required <p>Returns:</p> Type Description <code>float</code> <p>A tuple <code>(vertical_ft, horizontal_ft)</code> of offsets that should be applied to the range/up/cross vector.</p> <code>float</code> <p>Both values are zero when <code>Shot</code> has both latitude and azimuth and so can compute a full 3D solution.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def flat_fire_offsets(self, time: float, distance_ft: float, drop_ft: float) -&gt; Tuple[float, float]:\n    \"\"\"Estimate flat-fire vertical and horizontal corrections.\n\n    Args:\n        time: Time of flight in seconds for the sample point.\n        distance_ft: Down-range distance in feet at the sample point.\n        drop_ft: Local vertical displacement in feet (positive is up).\n\n    Returns:\n        A tuple `(vertical_ft, horizontal_ft)` of offsets that should be applied to the range/up/cross vector.\n        Both values are zero when `Shot` has both latitude and azimuth and so can compute a full 3D solution.\n    \"\"\"\n    if not self.flat_fire_only:\n        return 0.0, 0.0\n\n    horizontal = cEarthAngularVelocityRadS * distance_ft * self.sin_lat * time\n    vertical = 0.0\n    if self.sin_az is not None:  # This should not happen if not full_3d, but approximation provided for reference\n        vertical_factor = -2.0 * cEarthAngularVelocityRadS * self.muzzle_velocity_fps * self.cos_lat * self.sin_az\n        vertical = drop_ft * (vertical_factor / cGravityImperial)\n    return vertical, horizontal\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Coriolis.adjust_range","title":"adjust_range","text":"<pre><code>adjust_range(time: float, range_vector: Vector) -&gt; Vector\n</code></pre> <p>Apply the flat-fire offsets to a range vector when necessary.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Time of flight in seconds for the sample point.</p> required <code>range_vector</code> <code>Vector</code> <p>Original range/up/cross vector (feet) produced by the integrator.</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>Either the original vector (for full 3D solutions) or a new vector with the flat-fire offsets applied.</p> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def adjust_range(self, time: float, range_vector: Vector) -&gt; Vector:\n    \"\"\"Apply the flat-fire offsets to a range vector when necessary.\n\n    Args:\n        time: Time of flight in seconds for the sample point.\n        range_vector: Original range/up/cross vector (feet) produced by the integrator.\n\n    Returns:\n        Either the original vector (for full 3D solutions) or a new vector with the flat-fire offsets applied.\n    \"\"\"\n    if not self.flat_fire_only:\n        return range_vector\n\n    delta_y, delta_z = self.flat_fire_offsets(time, range_vector.x, range_vector.y)\n    if delta_y == 0.0 and delta_z == 0.0:\n        return range_vector\n    return Vector(range_vector.x, range_vector.y + delta_y, range_vector.z + delta_z)\n</code></pre>"},{"location":"api/conditions/shotprops/","title":"ShotProps","text":""},{"location":"api/conditions/shotprops/#py_ballisticcalc.shot.ShotProps","title":"ShotProps  <code>dataclass</code>","text":"<pre><code>ShotProps(\n    shot: Shot,\n    bc: float,\n    drag_curve: PchipPrepared,\n    look_angle_rad: float,\n    twist_inch: float,\n    length_inch: float,\n    diameter_inch: float,\n    weight_grains: float,\n    barrel_elevation_rad: float,\n    barrel_azimuth_rad: float,\n    sight_height_ft: float,\n    cant_cosine: float,\n    cant_sine: float,\n    alt0_ft: float,\n    muzzle_velocity_fps: float,\n    coriolis: Optional[Coriolis] = None,\n)\n</code></pre> <p>Shot configuration and parameters for ballistic trajectory calculations.</p> <p>Contains all shot-specific parameters converted to standard internal units (feet, seconds, grains, radians) used by the calculation engines. The class pre-computes expensive calculations (drag curve interpolation, atmospheric data, projectile properties) for repeated use during trajectory integration.</p> <p>Examples:</p> <pre><code>from py_ballisticcalc import Shot, ShotProps\n\n# Create shot configuration\nshot = Shot(weapon=weapon, ammo=ammo, atmo=atmo)\n\n# Convert to ShotProps\nshot_props = ShotProps.from_shot(shot)\n\n# Access pre-computed values\nprint(f\"Stability coefficient: {shot_props.stability_coefficient}\")\n\n# Get drag coefficient at specific Mach number\ndrag = shot_props.drag_by_mach(1.5)\n\n# Calculate spin drift at flight time\ntime = 1.2  # seconds\ndrift = shot_props.spin_drift(time)  # inches\n\n# Get atmospheric conditions at altitude\naltitude = shot_props.alt0_ft + 100  # 100 feet above initial altitude\ndensity_ratio, mach_fps = shot_props.get_density_and_mach_for_altitude(altitude)\n</code></pre> Computational Optimizations <ul> <li>Drag coefficient curves pre-computed for fast interpolation</li> <li>Trigonometric values (cant_cosine, cant_sine) pre-calculated</li> <li>Atmospheric parameters cached for repeated altitude lookups</li> <li>Miller stability coefficient computed once during initialization</li> </ul> Notes <p>This class is designed for internal use by ballistic calculation engines. User code should typically work with Shot objects and let the Calculator handle the conversion to ShotProps automatically.</p> <p>The original Shot object is retained for reference, but modifications to it after ShotProps creation will not affect the stored calculations. Create a new ShotProps instance if Shot parameters change.</p> <p>Methods:</p> Name Description <code>from_shot</code> <p>Initialize a ShotProps instance from a Shot instance.</p> <code>get_density_and_mach_for_altitude</code> <p>Get the air density and Mach number for a given altitude.</p> <code>drag_by_mach</code> <p>Calculate a standard drag factor (SDF) for the given Mach number.</p> <code>spin_drift</code> <p>Litz spin-drift approximation.</p>"},{"location":"api/conditions/shotprops/#py_ballisticcalc.shot.ShotProps-functions","title":"Functions","text":""},{"location":"api/conditions/shotprops/#py_ballisticcalc.shot.ShotProps.from_shot","title":"from_shot  <code>classmethod</code>","text":"<pre><code>from_shot(shot: Shot) -&gt; ShotProps\n</code></pre> <p>Initialize a ShotProps instance from a Shot instance.</p> Source code in <code>py_ballisticcalc/shot.py</code> <pre><code>@classmethod\ndef from_shot(cls, shot: Shot) -&gt; ShotProps:\n    \"\"\"Initialize a ShotProps instance from a Shot instance.\"\"\"\n    muzzle_velocity_fps = shot.ammo.get_velocity_for_temp(shot.atmo.powder_temp) &gt;&gt; Velocity.FPS\n    return cls(\n        shot=shot,\n        bc=shot.ammo.dm.BC,\n        drag_curve=cls._precalc_drag_curve(shot.ammo.dm.drag_table),\n        look_angle_rad=shot.look_angle &gt;&gt; Angular.Radian,\n        twist_inch=shot.weapon.twist &gt;&gt; Distance.Inch,\n        length_inch=shot.ammo.dm.length &gt;&gt; Distance.Inch,\n        diameter_inch=shot.ammo.dm.diameter &gt;&gt; Distance.Inch,\n        weight_grains=shot.ammo.dm.weight &gt;&gt; Weight.Grain,\n        barrel_elevation_rad=shot.barrel_elevation &gt;&gt; Angular.Radian,\n        barrel_azimuth_rad=shot.barrel_azimuth &gt;&gt; Angular.Radian,\n        sight_height_ft=shot.weapon.sight_height &gt;&gt; Distance.Foot,\n        cant_cosine=math.cos(shot.cant_angle &gt;&gt; Angular.Radian),\n        cant_sine=math.sin(shot.cant_angle &gt;&gt; Angular.Radian),\n        alt0_ft=shot.atmo.altitude &gt;&gt; Distance.Foot,\n        muzzle_velocity_fps=muzzle_velocity_fps,\n        coriolis=Coriolis.create(shot.latitude, shot.azimuth, muzzle_velocity_fps),\n    )\n</code></pre>"},{"location":"api/conditions/shotprops/#py_ballisticcalc.shot.ShotProps.get_density_and_mach_for_altitude","title":"get_density_and_mach_for_altitude","text":"<pre><code>get_density_and_mach_for_altitude(\n    drop: float,\n) -&gt; Tuple[float, float]\n</code></pre> <p>Get the air density and Mach number for a given altitude.</p> <p>Parameters:</p> Name Type Description Default <code>drop</code> <code>float</code> <p>The change in feet from the initial altitude.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>A tuple containing the air density (in lb/ft\u00b3) and Mach number at the specified altitude.</p> Source code in <code>py_ballisticcalc/shot.py</code> <pre><code>def get_density_and_mach_for_altitude(self, drop: float) -&gt; Tuple[float, float]:\n    \"\"\"Get the air density and Mach number for a given altitude.\n\n    Args:\n        drop: The change in feet from the initial altitude.\n\n    Returns:\n        A tuple containing the air density (in lb/ft\u00b3) and Mach number at the specified altitude.\n    \"\"\"\n    return self.shot.atmo.get_density_and_mach_for_altitude(self.alt0_ft + drop)\n</code></pre>"},{"location":"api/conditions/shotprops/#py_ballisticcalc.shot.ShotProps.drag_by_mach","title":"drag_by_mach","text":"<pre><code>drag_by_mach(mach: float) -&gt; float\n</code></pre> <p>Calculate a standard drag factor (SDF) for the given Mach number. <pre><code>Formula:\n    Drag force = V^2 * AirDensity * C_d * S / 2m\n               = V^2 * density_ratio * SDF\nWhere:\n    - density_ratio = LocalAirDensity / StandardDensity = rho / rho_0\n    - StandardDensity of Air = rho_0 = 0.076474 lb/ft^3\n    - S is cross-section = d^2 pi/4, where d is bullet diameter in inches\n    - m is bullet mass in pounds\n    - bc contains m/d^2 in units lb/in^2, which is multiplied by 144 to convert to lb/ft^2\nThus:\n    - The magic constant found here = StandardDensity * pi / (4 * 2 * 144)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>mach</code> <code>float</code> <p>The Mach number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The standard drag factor at the given Mach number.</p> Source code in <code>py_ballisticcalc/shot.py</code> <pre><code>def drag_by_mach(self, mach: float) -&gt; float:\n    \"\"\"Calculate a standard drag factor (SDF) for the given Mach number.\n    ```\n    Formula:\n        Drag force = V^2 * AirDensity * C_d * S / 2m\n                   = V^2 * density_ratio * SDF\n    Where:\n        - density_ratio = LocalAirDensity / StandardDensity = rho / rho_0\n        - StandardDensity of Air = rho_0 = 0.076474 lb/ft^3\n        - S is cross-section = d^2 pi/4, where d is bullet diameter in inches\n        - m is bullet mass in pounds\n        - bc contains m/d^2 in units lb/in^2, which is multiplied by 144 to convert to lb/ft^2\n    Thus:\n        - The magic constant found here = StandardDensity * pi / (4 * 2 * 144)\n    ```\n\n    Args:\n        mach: The Mach number.\n\n    Returns:\n        The standard drag factor at the given Mach number.\n    \"\"\"\n    cd = pchip_eval(self.drag_curve, mach)\n    return cd * 2.08551e-04 / self.bc\n</code></pre>"},{"location":"api/conditions/shotprops/#py_ballisticcalc.shot.ShotProps.spin_drift","title":"spin_drift","text":"<pre><code>spin_drift(time: float) -&gt; float\n</code></pre> <p>Litz spin-drift approximation.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Time of flight</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Windage due to spin drift, in inches</p> Source code in <code>py_ballisticcalc/shot.py</code> <pre><code>def spin_drift(self, time: float) -&gt; float:\n    \"\"\"Litz spin-drift approximation.\n\n    Args:\n        time: Time of flight\n\n    Returns:\n        float: Windage due to spin drift, in inches\n    \"\"\"\n    if (self.stability_coefficient != 0) and (self.twist_inch != 0):\n        sign = 1 if self.twist_inch &gt; 0 else -1\n        return sign * (1.25 * (self.stability_coefficient + 1.2) * math.pow(time, 1.83)) / 12\n    return 0\n</code></pre>"},{"location":"api/conditions/wind/","title":"Wind","text":""},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind","title":"Wind  <code>dataclass</code>","text":"<pre><code>Wind(\n    velocity: Optional[Union[float, Velocity]] = None,\n    direction_from: Optional[Union[float, Angular]] = None,\n    until_distance: Optional[Union[float, Distance]] = None,\n    *,\n    max_distance_feet: Optional[\n        float\n    ] = cMaxWindDistanceFeet,\n)\n</code></pre> <p>Describe wind in effect over a particular down-range distance.</p> <p>Attributes:</p> Name Type Description <code>velocity</code> <code>Velocity</code> <p>speed of wind</p> <code>direction_from</code> <code>Angular</code> <p>0 is blowing from behind shooter. 90 degrees is blowing from shooter's left towards right.</p> <code>until_distance</code> <code>Distance</code> <p>until which distance the specified wind blows</p> <code>MAX_DISTANCE_FEET</code> <code>float</code> <p>Optional custom max wind distance</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>Optional[Union[float, Velocity]]</code> <p>speed of wind</p> <code>None</code> <code>direction_from</code> <code>Optional[Union[float, Angular]]</code> <p>0 is blowing from behind shooter. 90 degrees is blowing from shooter's left towards right.</p> <code>None</code> <code>until_distance</code> <code>Optional[Union[float, Distance]]</code> <p>until which distance the specified wind blows</p> <code>None</code> <code>max_distance_feet</code> <code>Optional[float]</code> <p>Optional custom max wind distance</p> <code>cMaxWindDistanceFeet</code> Example <pre><code>from py_ballisticcalc import Wind\nwind = Wind(\n    velocity=Unit.FPS(2700),\n    direction_from=Unit.Degree(20)\n)\n</code></pre> Source code in <code>py_ballisticcalc/conditions.py</code> <pre><code>def __init__(\n    self,\n    velocity: Optional[Union[float, Velocity]] = None,\n    direction_from: Optional[Union[float, Angular]] = None,\n    until_distance: Optional[Union[float, Distance]] = None,\n    *,\n    max_distance_feet: Optional[float] = cMaxWindDistanceFeet,\n):\n    \"\"\"\n    Create a new wind instance with given parameters.\n\n    Args:\n        velocity: speed of wind\n        direction_from: 0 is blowing from behind shooter.\n            90 degrees is blowing from shooter's left towards right.\n        until_distance: until which distance the specified wind blows\n        max_distance_feet: Optional custom max wind distance\n\n    Example:\n        ```python\n        from py_ballisticcalc import Wind\n        wind = Wind(\n            velocity=Unit.FPS(2700),\n            direction_from=Unit.Degree(20)\n        )\n        ```\n    \"\"\"\n\n    self.MAX_DISTANCE_FEET = float(max_distance_feet or cMaxWindDistanceFeet)\n    self.velocity = PreferredUnits.velocity(velocity or 0)\n    self.direction_from = PreferredUnits.angular(direction_from or 0)\n    self.until_distance = PreferredUnits.distance(until_distance or Distance.Foot(self.MAX_DISTANCE_FEET))\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind-attributes","title":"Attributes","text":""},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.vector","title":"vector  <code>property</code>","text":"<pre><code>vector: Vector\n</code></pre> <p>Vector representation of the Wind instance.</p>"},{"location":"api/munition/ammo/","title":"Ammo","text":""},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo","title":"Ammo  <code>dataclass</code>","text":"<pre><code>Ammo(\n    dm: DragModel,\n    mv: Union[float, Velocity],\n    powder_temp: Optional[Union[float, Temperature]] = None,\n    temp_modifier: float = 0,\n    use_powder_sensitivity: bool = False,\n)\n</code></pre> <p>Ammunition configuration for ballistic calculations.</p> <p>This class represents the physical and ballistic properties of ammunition, including the drag model, muzzle velocity, and powder temperature sensitivity. It provides methods for calculating temperature-dependent velocity adjustments.</p> <p>Attributes:</p> Name Type Description <code>dm</code> <code>DragModel</code> <p>DragModel instance defining the projectile's ballistic coefficient and drag characteristics.</p> <code>mv</code> <code>Velocity</code> <p>Muzzle velocity at the baseline powder temperature.</p> <code>powder_temp</code> <code>Temperature</code> <p>Baseline temperature that produces the given muzzle velocity.</p> <code>temp_modifier</code> <code>float</code> <p>Change in velocity with temperature as a percentage per 15\u00b0C.           Can be computed using calc_powder_sens() method.</p> <code>use_powder_sensitivity</code> <code>bool</code> <p>Flag to enable automatic muzzle velocity adjustment                    based on powder temperature.</p> Note <p>When use_powder_sensitivity is True, the actual muzzle velocity will be automatically adjusted based on the difference between the current powder temperature and the baseline powder_temp using the temp_modifier.</p> Example <pre><code>ammo = Ammo(\n    dm=DragModel(0.381, TableG7, Unit.Grain(300), Unit.Inch(0.338)),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>DragModel</code> <p>DragModel instance defining projectile ballistic characteristics.</p> required <code>mv</code> <code>Union[float, Velocity]</code> <p>Muzzle velocity at the baseline powder temperature.</p> required <code>powder_temp</code> <code>Optional[Union[float, Temperature]]</code> <p>Baseline temperature that produces the given muzzle velocity.         If None, defaults to 15\u00b0C.</p> <code>None</code> <code>temp_modifier</code> <code>float</code> <p>Change in velocity with temperature as percentage per 15\u00b0C.           Can be computed with calc_powder_sens() method.           Only applies if use_powder_sensitivity is True.</p> <code>0</code> <code>use_powder_sensitivity</code> <code>bool</code> <p>If True, automatically adjust muzzle velocity                    based on powder temperature differences.</p> <code>False</code> Example <pre><code>from py_ballisticcalc import Ammo, DragModel, TableG7, Unit\n\n# Basic ammunition without temperature sensitivity\nammo = Ammo(dm=DragModel(0.381, TableG7), mv=Unit.MPS(815))\n\n# Advanced ammunition with powder temperature sensitivity\nammo = Ammo(\n    dm=DragModel(0.381, TableG7, Unit.Grain(300), Unit.Inch(0.338)),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True\n)\n# Calculate sensitivity from known data points\nammo.calc_powder_sens(Unit.MPS(830), Unit.Celsius(30))\n</code></pre> <p>Methods:</p> Name Description <code>calc_powder_sens</code> <p>Calculate velocity temperature sensitivity and update temp_modifier.</p> <code>get_velocity_for_temp</code> <p>Calculate muzzle velocity adjusted for powder temperature.</p> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def __init__(\n    self,\n    dm: DragModel,\n    mv: Union[float, Velocity],\n    powder_temp: Optional[Union[float, Temperature]] = None,\n    temp_modifier: float = 0,\n    use_powder_sensitivity: bool = False,\n):\n    \"\"\"Initialize an Ammo instance with given parameters.\n\n    Args:\n        dm: DragModel instance defining projectile ballistic characteristics.\n        mv: Muzzle velocity at the baseline powder temperature.\n        powder_temp: Baseline temperature that produces the given muzzle velocity.\n                    If None, defaults to 15\u00b0C.\n        temp_modifier: Change in velocity with temperature as percentage per 15\u00b0C.\n                      Can be computed with calc_powder_sens() method.\n                      Only applies if use_powder_sensitivity is True.\n        use_powder_sensitivity: If True, automatically adjust muzzle velocity\n                               based on powder temperature differences.\n\n    Example:\n        ```python\n        from py_ballisticcalc import Ammo, DragModel, TableG7, Unit\n\n        # Basic ammunition without temperature sensitivity\n        ammo = Ammo(dm=DragModel(0.381, TableG7), mv=Unit.MPS(815))\n\n        # Advanced ammunition with powder temperature sensitivity\n        ammo = Ammo(\n            dm=DragModel(0.381, TableG7, Unit.Grain(300), Unit.Inch(0.338)),\n            mv=Unit.MPS(815),\n            powder_temp=Unit.Celsius(15),\n            temp_modifier=0.123,\n            use_powder_sensitivity=True\n        )\n        # Calculate sensitivity from known data points\n        ammo.calc_powder_sens(Unit.MPS(830), Unit.Celsius(30))\n        ```\n    \"\"\"\n    self.dm = dm\n    self.mv = PreferredUnits.velocity(mv or 0)\n    self.powder_temp = PreferredUnits.temperature(powder_temp or Temperature.Celsius(15))\n    self.temp_modifier = temp_modifier or 0\n    self.use_powder_sensitivity = use_powder_sensitivity\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo-functions","title":"Functions","text":""},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.calc_powder_sens","title":"calc_powder_sens","text":"<pre><code>calc_powder_sens(\n    other_velocity: Union[float, Velocity],\n    other_temperature: Union[float, Temperature],\n) -&gt; float\n</code></pre> <p>Calculate velocity temperature sensitivity and update temp_modifier.</p> <p>This method calculates the powder temperature sensitivity coefficient based on two known velocity/temperature data points and assigns the result to the temp_modifier attribute.</p> <p>Parameters:</p> Name Type Description Default <code>other_velocity</code> <code>Union[float, Velocity]</code> <p>Known velocity at other_temperature.</p> required <code>other_temperature</code> <code>Union[float, Temperature]</code> <p>Temperature corresponding to other_velocity.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Temperature modifier in terms of percentage velocity change per 15\u00b0C.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If other_velocity and temperature are the same as baseline,        making calculation impossible.</p> Note <p>The calculation uses the formula: temp_modifier = (velocity_delta / temperature_delta) * (15 / lower_velocity)</p> <p>This provides a normalized sensitivity value representing the percentage change in velocity per 15\u00b0C temperature change.</p> Example <pre><code># Calculate sensitivity from known velocity drop in cold weather\nsensitivity = ammo.calc_powder_sens(\n    other_velocity=Unit.MPS(800),  # Velocity at cold temp\n    other_temperature=Unit.Celsius(0)  # Cold temperature\n)\nprint(f\"Powder sensitivity: {sensitivity:.4f}% per 15\u00b0C\")\n\n# The temp_modifier is now automatically set\nprint(f\"Current temp_modifier: {ammo.temp_modifier}\")\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def calc_powder_sens(\n    self, other_velocity: Union[float, Velocity], other_temperature: Union[float, Temperature]\n) -&gt; float:\n    \"\"\"Calculate velocity temperature sensitivity and update temp_modifier.\n\n    This method calculates the powder temperature sensitivity coefficient\n    based on two known velocity/temperature data points and assigns the\n    result to the temp_modifier attribute.\n\n    Args:\n        other_velocity: Known velocity at other_temperature.\n        other_temperature: Temperature corresponding to other_velocity.\n\n    Returns:\n        Temperature modifier in terms of percentage velocity change per 15\u00b0C.\n\n    Raises:\n        ValueError: If other_velocity and temperature are the same as baseline,\n                   making calculation impossible.\n\n    Note:\n        The calculation uses the formula:\n        temp_modifier = (velocity_delta / temperature_delta) * (15 / lower_velocity)\n\n        This provides a normalized sensitivity value representing the percentage\n        change in velocity per 15\u00b0C temperature change.\n\n    Example:\n        ```python\n        # Calculate sensitivity from known velocity drop in cold weather\n        sensitivity = ammo.calc_powder_sens(\n            other_velocity=Unit.MPS(800),  # Velocity at cold temp\n            other_temperature=Unit.Celsius(0)  # Cold temperature\n        )\n        print(f\"Powder sensitivity: {sensitivity:.4f}% per 15\u00b0C\")\n\n        # The temp_modifier is now automatically set\n        print(f\"Current temp_modifier: {ammo.temp_modifier}\")\n        ```\n    \"\"\"\n    v0 = self.mv &gt;&gt; Velocity.MPS\n    t0 = self.powder_temp &gt;&gt; Temperature.Celsius\n    v1 = PreferredUnits.velocity(other_velocity) &gt;&gt; Velocity.MPS\n    t1 = PreferredUnits.temperature(other_temperature) &gt;&gt; Temperature.Celsius\n\n    if v0 &lt;= 0 or v1 &lt;= 0:\n        raise ValueError(\"calc_powder_sens requires positive muzzle velocities\")\n    v_delta = math.fabs(v0 - v1)\n    t_delta = math.fabs(t0 - t1)\n    v_lower = v1 if v1 &lt; v0 else v0\n\n    if v_delta == 0 or t_delta == 0:\n        raise ValueError(\"other_velocity and temperature can't be same as default\")\n    self.temp_modifier = v_delta / t_delta * (15 / v_lower)  # * 100\n    return self.temp_modifier\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.get_velocity_for_temp","title":"get_velocity_for_temp","text":"<pre><code>get_velocity_for_temp(\n    current_temp: Union[float, Temperature],\n) -&gt; Velocity\n</code></pre> <p>Calculate muzzle velocity adjusted for powder temperature.</p> <p>This method calculates the muzzle velocity at a given temperature based on the baseline velocity, powder temperature, and temperature sensitivity modifier. If powder sensitivity is disabled, returns the baseline velocity.</p> <p>Parameters:</p> Name Type Description Default <code>current_temp</code> <code>Union[float, Temperature]</code> <p>Temperature of the cartridge powder.</p> required <p>Returns:</p> Type Description <code>Velocity</code> <p>Muzzle velocity corrected for the specified temperature.</p> Note <p>The calculation uses the formula: <code>adjusted_velocity = baseline_velocity + (temp_modifier / (15 / baseline_velocity)) * temp_delta</code> ... where temp_delta is the difference between current_temp and powder_temp.</p> <p>If use_powder_sensitivity is False, returns the baseline muzzle velocity regardless of temperature.</p> <p>Examples:</p> <pre><code># Get velocity for current conditions\ncold_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\nhot_velocity = ammo.get_velocity_for_temp(Unit.Celsius(35))\n\nprint(f\"Baseline velocity: {ammo.mv}\")\nprint(f\"Cold weather velocity: {cold_velocity}\")\nprint(f\"Hot weather velocity: {hot_velocity}\")\n\n# With powder sensitivity disabled\nammo.use_powder_sensitivity = False\nconstant_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\n# constant_velocity equals ammo.mv regardless of temperature\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def get_velocity_for_temp(self, current_temp: Union[float, Temperature]) -&gt; Velocity:\n    \"\"\"Calculate muzzle velocity adjusted for powder temperature.\n\n    This method calculates the muzzle velocity at a given temperature based\n    on the baseline velocity, powder temperature, and temperature sensitivity\n    modifier. If powder sensitivity is disabled, returns the baseline velocity.\n\n    Args:\n        current_temp: Temperature of the cartridge powder.\n\n    Returns:\n        Muzzle velocity corrected for the specified temperature.\n\n    Note:\n        The calculation uses the formula:\n        `adjusted_velocity = baseline_velocity + (temp_modifier / (15 / baseline_velocity)) * temp_delta`\n        ... where temp_delta is the difference between current_temp and powder_temp.\n\n        If use_powder_sensitivity is False, returns the baseline muzzle velocity regardless of temperature.\n\n    Examples:\n        ```python\n        # Get velocity for current conditions\n        cold_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\n        hot_velocity = ammo.get_velocity_for_temp(Unit.Celsius(35))\n\n        print(f\"Baseline velocity: {ammo.mv}\")\n        print(f\"Cold weather velocity: {cold_velocity}\")\n        print(f\"Hot weather velocity: {hot_velocity}\")\n\n        # With powder sensitivity disabled\n        ammo.use_powder_sensitivity = False\n        constant_velocity = ammo.get_velocity_for_temp(Unit.Celsius(-10))\n        # constant_velocity equals ammo.mv regardless of temperature\n        ```\n    \"\"\"\n    if not self.use_powder_sensitivity:\n        return self.mv\n    try:\n        v0 = self.mv &gt;&gt; Velocity.MPS\n        t0 = self.powder_temp &gt;&gt; Temperature.Celsius\n        t1 = PreferredUnits.temperature(current_temp) &gt;&gt; Temperature.Celsius\n        t_delta = t1 - t0\n        muzzle_velocity = self.temp_modifier / (15 / v0) * t_delta + v0\n    except ZeroDivisionError:\n        muzzle_velocity = 0\n    return Velocity.MPS(muzzle_velocity)\n</code></pre>"},{"location":"api/munition/sight/","title":"Sight","text":""},{"location":"api/munition/sight/#py_ballisticcalc.munition.Sight","title":"Sight  <code>dataclass</code>","text":"<pre><code>Sight(\n    focal_plane: SightFocalPlane = \"FFP\",\n    scale_factor: Optional[Union[float, Distance]] = None,\n    h_click_size: Optional[Union[float, Angular]] = None,\n    v_click_size: Optional[Union[float, Angular]] = None,\n)\n</code></pre> <p>Sight configuration for ballistic calculations and adjustments.</p> <p>This class represents the optical sight system mounted on a weapon, including the focal plane type, magnification properties, and click adjustment sizes. It provides methods for calculating sight adjustments based on target distance and magnification settings.</p> <p>Attributes:</p> Name Type Description <code>focal_plane</code> <code>SightFocalPlane</code> <p>Type of focal plane ('FFP' for First Focal Plane,         'SFP' for Second Focal Plane, 'LWIR' for Long Wave Infrared).</p> <code>scale_factor</code> <code>Distance</code> <p>Distance representing the scale factor for sight calculations.</p> <code>h_click_size</code> <code>Angular</code> <p>Angular size of horizontal click adjustments.</p> <code>v_click_size</code> <code>Angular</code> <p>Angular size of vertical click adjustments.</p> Example <pre><code>sight = Sight(\n    focal_plane='FFP',\n    scale_factor=Unit.Meter(100),\n    h_click_size=Unit.Mil(0.2),\n    v_click_size=Unit.Mil(0.2)\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>focal_plane</code> <code>SightFocalPlane</code> <p>Type of focal plane ('FFP', 'SFP', or 'LWIR').         Defaults to 'FFP' (First Focal Plane).</p> <code>'FFP'</code> <code>scale_factor</code> <code>Optional[Union[float, Distance]]</code> <p>Distance used for sight scale calculations.          Required for SFP sights. If None, defaults to 1 unit.</p> <code>None</code> <code>h_click_size</code> <code>Optional[Union[float, Angular]]</code> <p>Angular size of horizontal click adjustments.          Must be positive value.</p> <code>None</code> <code>v_click_size</code> <code>Optional[Union[float, Angular]]</code> <p>Angular size of vertical click adjustments.          Must be positive value.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If focal_plane is not supported or scale_factor missing for SFP.</p> <code>TypeError</code> <p>If click sizes are not Angular type or not positive.</p> Example <pre><code># Default FFP sight\nsight = Sight()\n\n# SFP sight with required scale factor\nsight = Sight(\n    focal_plane='SFP',\n    scale_factor=Unit.Yard(100),\n    h_click_size=Unit.MOA(0.25),\n    v_click_size=Unit.MOA(0.25)\n)\n</code></pre> <p>Methods:</p> Name Description <code>get_adjustment</code> <p>Calculate sight adjustment for target distance and magnification.</p> <code>get_trajectory_adjustment</code> <p>Calculate sight adjustment from trajectory data point.</p> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def __init__(\n    self,\n    focal_plane: SightFocalPlane = \"FFP\",\n    scale_factor: Optional[Union[float, Distance]] = None,\n    h_click_size: Optional[Union[float, Angular]] = None,\n    v_click_size: Optional[Union[float, Angular]] = None,\n):\n    \"\"\"Initialize a Sight instance with given parameters.\n\n    Args:\n        focal_plane: Type of focal plane ('FFP', 'SFP', or 'LWIR').\n                    Defaults to 'FFP' (First Focal Plane).\n        scale_factor: Distance used for sight scale calculations.\n                     Required for SFP sights. If None, defaults to 1 unit.\n        h_click_size: Angular size of horizontal click adjustments.\n                     Must be positive value.\n        v_click_size: Angular size of vertical click adjustments.\n                     Must be positive value.\n\n    Raises:\n        ValueError: If focal_plane is not supported or scale_factor missing for SFP.\n        TypeError: If click sizes are not Angular type or not positive.\n\n    Example:\n        ```python\n        # Default FFP sight\n        sight = Sight()\n\n        # SFP sight with required scale factor\n        sight = Sight(\n            focal_plane='SFP',\n            scale_factor=Unit.Yard(100),\n            h_click_size=Unit.MOA(0.25),\n            v_click_size=Unit.MOA(0.25)\n        )\n        ```\n    \"\"\"\n    if focal_plane not in get_args(SightFocalPlane):\n        raise ValueError(\"Wrong focal plane\")\n\n    if not scale_factor and focal_plane == \"SFP\":\n        raise ValueError(\"Scale_factor required for SFP sights\")\n\n    if not isinstance(h_click_size, (Angular, float, int)) or not isinstance(v_click_size, (Angular, float, int)):\n        raise TypeError(\"Angle expected for 'h_click_size' and 'v_click_size'\")\n\n    self.focal_plane = focal_plane\n    self.scale_factor = PreferredUnits.distance(scale_factor or 1)\n    self.h_click_size = PreferredUnits.adjustment(h_click_size)\n    self.v_click_size = PreferredUnits.adjustment(v_click_size)\n    if self.h_click_size.raw_value &lt;= 0 or self.v_click_size.raw_value &lt;= 0:\n        raise TypeError(\"'h_click_size' and 'v_click_size' must be positive\")\n</code></pre>"},{"location":"api/munition/sight/#py_ballisticcalc.munition.Sight-functions","title":"Functions","text":""},{"location":"api/munition/sight/#py_ballisticcalc.munition.Sight.get_adjustment","title":"get_adjustment","text":"<pre><code>get_adjustment(\n    target_distance: Distance,\n    drop_angle: Angular,\n    windage_angle: Angular,\n    magnification: float,\n) -&gt; SightClicks\n</code></pre> <p>Calculate sight adjustment for target distance and magnification.</p> <p>This method computes the required sight adjustments (in clicks) based on the ballistic solution for a given target distance and current magnification. The calculation method varies depending on the focal plane type.</p> <p>Parameters:</p> Name Type Description Default <code>target_distance</code> <code>Distance</code> <p>Distance to the target.</p> required <code>drop_angle</code> <code>Angular</code> <p>Required vertical angular adjustment for drop compensation.</p> required <code>windage_angle</code> <code>Angular</code> <p>Required horizontal angular adjustment for windage.</p> required <code>magnification</code> <code>float</code> <p>Current magnification setting of the sight.</p> required <p>Returns:</p> Type Description <code>SightClicks</code> <p>SightClicks with vertical and horizontal click adjustments needed.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If focal_plane is not one of the supported types.</p> Note <ul> <li>SFP sights: Adjustments scaled by target distance and magnification</li> <li>FFP sights: Direct conversion using click sizes</li> <li>LWIR sights: Adjustments scaled by magnification only</li> </ul> Example <pre><code>clicks = sight.get_adjustment(\n    target_distance=Unit.Meter(500),\n    drop_angle=Unit.Mil(2.5),\n    windage_angle=Unit.Mil(0.8),\n    magnification=12.0\n)\nprint(f\"Adjust: {clicks.vertical} up, {clicks.horizontal} right\")\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def get_adjustment(\n    self, target_distance: Distance, drop_angle: Angular, windage_angle: Angular, magnification: float\n) -&gt; SightClicks:\n    \"\"\"Calculate sight adjustment for target distance and magnification.\n\n    This method computes the required sight adjustments (in clicks) based on\n    the ballistic solution for a given target distance and current magnification.\n    The calculation method varies depending on the focal plane type.\n\n    Args:\n        target_distance: Distance to the target.\n        drop_angle: Required vertical angular adjustment for drop compensation.\n        windage_angle: Required horizontal angular adjustment for windage.\n        magnification: Current magnification setting of the sight.\n\n    Returns:\n        SightClicks with vertical and horizontal click adjustments needed.\n\n    Raises:\n        AttributeError: If focal_plane is not one of the supported types.\n\n    Note:\n        - SFP sights: Adjustments scaled by target distance and magnification\n        - FFP sights: Direct conversion using click sizes\n        - LWIR sights: Adjustments scaled by magnification only\n\n    Example:\n        ```python\n        clicks = sight.get_adjustment(\n            target_distance=Unit.Meter(500),\n            drop_angle=Unit.Mil(2.5),\n            windage_angle=Unit.Mil(0.8),\n            magnification=12.0\n        )\n        print(f\"Adjust: {clicks.vertical} up, {clicks.horizontal} right\")\n        ```\n    \"\"\"\n    if magnification &lt;= 0:\n        raise ValueError(\"magnification must be positive\")\n    if self.focal_plane == \"SFP\":\n        steps = self._adjust_sfp_reticle_steps(target_distance, magnification)\n        return SightClicks(\n            drop_angle.raw_value / steps.vertical.raw_value, windage_angle.raw_value / steps.horizontal.raw_value\n        )\n    if self.focal_plane == \"FFP\":\n        return SightClicks(\n            drop_angle.raw_value / self.v_click_size.raw_value,\n            windage_angle.raw_value / self.h_click_size.raw_value,\n        )\n    if self.focal_plane == \"LWIR\":\n        return SightClicks(  # adjust clicks to magnification\n            drop_angle.raw_value / (self.v_click_size.raw_value / magnification),\n            windage_angle.raw_value / (self.h_click_size.raw_value / magnification),\n        )\n    raise AttributeError(\"Wrong focal_plane\")\n</code></pre>"},{"location":"api/munition/sight/#py_ballisticcalc.munition.Sight.get_trajectory_adjustment","title":"get_trajectory_adjustment","text":"<pre><code>get_trajectory_adjustment(\n    trajectory_point: TrajectoryData, magnification: float\n) -&gt; SightClicks\n</code></pre> <p>Calculate sight adjustment from trajectory data point.</p> <p>This convenience method extracts the necessary adjustment values from a TrajectoryData instance and calculates the required sight clicks.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory_point</code> <code>TrajectoryData</code> <p>TrajectoryData instance containing ballistic solution.</p> required <code>magnification</code> <code>float</code> <p>Current magnification setting of the sight.</p> required <p>Returns:</p> Type Description <code>SightClicks</code> <p>SightClicks with vertical and horizontal click adjustments needed.</p> Example <pre><code># Assuming trajectory_result is from Calculator.fire()\nfor point in trajectory_result:\n    clicks = sight.get_trajectory_adjustment(point, magnification=10.0)\n    print(f\"At {point.distance}: {clicks.vertical} clicks up\")\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def get_trajectory_adjustment(self, trajectory_point: \"TrajectoryData\", magnification: float) -&gt; SightClicks:\n    \"\"\"Calculate sight adjustment from trajectory data point.\n\n    This convenience method extracts the necessary adjustment values from a\n    TrajectoryData instance and calculates the required sight clicks.\n\n    Args:\n        trajectory_point: TrajectoryData instance containing ballistic solution.\n        magnification: Current magnification setting of the sight.\n\n    Returns:\n        SightClicks with vertical and horizontal click adjustments needed.\n\n    Example:\n        ```python\n        # Assuming trajectory_result is from Calculator.fire()\n        for point in trajectory_result:\n            clicks = sight.get_trajectory_adjustment(point, magnification=10.0)\n            print(f\"At {point.distance}: {clicks.vertical} clicks up\")\n        ```\n    \"\"\"\n    return self.get_adjustment(\n        trajectory_point.distance, trajectory_point.drop_angle, trajectory_point.windage_angle, magnification\n    )\n</code></pre>"},{"location":"api/munition/sight/#py_ballisticcalc.munition.SightClicks","title":"SightClicks","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Sight click adjustments as numeric values.</p> <p>This named tuple represents the number of clicks needed for vertical and horizontal sight adjustments, typically used for turret adjustments.</p> <p>Attributes:</p> Name Type Description <code>vertical</code> <code>float</code> <p>Number of vertical clicks for adjustment.</p> <code>horizontal</code> <code>float</code> <p>Number of horizontal clicks for adjustment.</p> Example <pre><code>clicks = SightClicks(vertical=5.0, horizontal=2.5)\n</code></pre>"},{"location":"api/munition/sight/#py_ballisticcalc.munition.SightReticleStep","title":"SightReticleStep","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Reticle step adjustments for sight calculations.</p> <p>This named tuple lists the angular step size of adjustments (clicks) available on a particular sight.</p> <p>Attributes:</p> Name Type Description <code>vertical</code> <code>Angular</code> <p>Vertical angular adjustment step.</p> <code>horizontal</code> <code>Angular</code> <p>Horizontal angular adjustment step.</p> Example <pre><code>step = SightReticleStep(\n    vertical=Angular.Mil(0.2),\n    horizontal=Angular.Mil(0.2)\n)\n</code></pre>"},{"location":"api/munition/weapon/","title":"Weapon","text":""},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon","title":"Weapon  <code>dataclass</code>","text":"<pre><code>Weapon(\n    sight_height: Optional[Union[float, Distance]] = None,\n    twist: Optional[Union[float, Distance]] = None,\n    zero_elevation: Optional[Union[float, Angular]] = None,\n    sight: Optional[Sight] = None,\n)\n</code></pre> <p>Weapon configuration for ballistic calculations.</p> <p>This class represents the physical characteristics of a gun that affect trajectory calculations, including sight height, barrel twist rate, zero elevation, and optional sight system configuration.</p> <p>Attributes:</p> Name Type Description <code>sight_height</code> <code>Distance</code> <p>Vertical distance from line of sight to center of bore,          measured at the muzzle perpendicular to the line of sight.</p> <code>twist</code> <code>Distance</code> <p>Distance for barrel rifling to complete one complete turn.    Positive values indicate right-hand twist, negative for left-hand.</p> <code>zero_elevation</code> <code>Angular</code> <p>Angle of barrel centerline relative to line of sight            when the sight is set to \"zero\" position.</p> <code>sight</code> <code>Optional[Sight]</code> <p>Optional Sight instance for advanced sight calculations.</p> Note <p>The sight height is critical for trajectory calculations as it determines the offset between the line of sight and the bullet's initial trajectory. Barrel twist affects spin drift calculations for long-range shots.</p> Example <pre><code>weapon = Weapon(\n    sight_height=Unit.Inch(2.5),\n    twist=Unit.Inch(10),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight('FFP', 100, Unit.Mil(0.2), Unit.Mil(0.2))\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sight_height</code> <code>Optional[Union[float, Distance]]</code> <p>Vertical distance from line of sight to center of bore,          measured at the muzzle. Defaults to 0 if not specified.</p> <code>None</code> <code>twist</code> <code>Optional[Union[float, Distance]]</code> <p>Distance for barrel rifling to complete one complete turn.   Positive value for right-hand twist, negative for left-hand.   Defaults to 0 if not specified.</p> <code>None</code> <code>zero_elevation</code> <code>Optional[Union[float, Angular]]</code> <p>Angle of barrel relative to sight line when sight            is set to \"zero.\" Typically computed by Calculator.set_weapon_zero().            Defaults to 0 if not specified.</p> <code>None</code> <code>sight</code> <code>Optional[Sight]</code> <p>Optional Sight properties for advanced sight calculations.</p> <code>None</code> Example <pre><code>from py_ballisticcalc import Weapon, Unit, Sight\n\n# Basic weapon configuration\nweapon = Weapon(\n    sight_height=Unit.Inch(2.5),\n    twist=Unit.Inch(10)\n)\n\n# Advanced weapon with sight system\nweapon = Weapon(\n    sight_height=Unit.Inch(2.5),\n    twist=Unit.Inch(10),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight(\n        'FFP',\n        scale_factor=Unit.Meter(100),\n        h_click_size=Unit.Mil(0.2),\n        v_click_size=Unit.Mil(0.2)\n    )\n)\n</code></pre> Source code in <code>py_ballisticcalc/munition.py</code> <pre><code>def __init__(\n    self,\n    sight_height: Optional[Union[float, Distance]] = None,\n    twist: Optional[Union[float, Distance]] = None,\n    zero_elevation: Optional[Union[float, Angular]] = None,\n    sight: Optional[Sight] = None,\n):\n    \"\"\"Initialize a Weapon instance with given parameters.\n\n    Args:\n        sight_height: Vertical distance from line of sight to center of bore,\n                     measured at the muzzle. Defaults to 0 if not specified.\n        twist: Distance for barrel rifling to complete one complete turn.\n              Positive value for right-hand twist, negative for left-hand.\n              Defaults to 0 if not specified.\n        zero_elevation: Angle of barrel relative to sight line when sight\n                       is set to \"zero.\" Typically computed by Calculator.set_weapon_zero().\n                       Defaults to 0 if not specified.\n        sight: Optional Sight properties for advanced sight calculations.\n\n    Example:\n        ```python\n        from py_ballisticcalc import Weapon, Unit, Sight\n\n        # Basic weapon configuration\n        weapon = Weapon(\n            sight_height=Unit.Inch(2.5),\n            twist=Unit.Inch(10)\n        )\n\n        # Advanced weapon with sight system\n        weapon = Weapon(\n            sight_height=Unit.Inch(2.5),\n            twist=Unit.Inch(10),\n            zero_elevation=Unit.Mil(0),\n            sight=Sight(\n                'FFP',\n                scale_factor=Unit.Meter(100),\n                h_click_size=Unit.Mil(0.2),\n                v_click_size=Unit.Mil(0.2)\n            )\n        )\n        ```\n    \"\"\"\n    self.sight_height = PreferredUnits.sight_height(sight_height or 0)\n    self.twist = PreferredUnits.twist(twist or 0)\n    self.zero_elevation = PreferredUnits.angular(zero_elevation or 0)\n    self.sight = sight\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.sight_height","title":"sight_height  <code>instance-attribute</code>","text":"<pre><code>sight_height: Distance = sight_height(sight_height or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.twist","title":"twist  <code>instance-attribute</code>","text":"<pre><code>twist: Distance = twist(twist or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.zero_elevation","title":"zero_elevation  <code>instance-attribute</code>","text":"<pre><code>zero_elevation: Angular = angular(zero_elevation or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.sight","title":"sight  <code>instance-attribute</code>","text":"<pre><code>sight: Optional[Sight] = sight\n</code></pre>"},{"location":"api/units/dimensions/","title":"Dimensions","text":"<pre><code>UnitAliases: UnitAliasesType = {\n    (\"radian\", \"rad\"): Unit.Radian,\n    (\"degree\", \"deg\"): Unit.Degree,\n    (\"moa\",): Unit.MOA,\n    (\"mil\",): Unit.Mil,\n    (\"mrad\",): Unit.MRad,\n    (\"thousandth\", \"ths\"): Unit.Thousandth,\n    (\"inch/100yd\", \"in/100yd\", \"in/100yard\", \"inper100yd\"): Unit.InchesPer100Yd,\n    (\"centimeter/100m\", \"cm/100m\", \"cm/100meter\", \"centimeter/100meter\", \"cmper100m\"): Unit.CmPer100m,\n    (\"hour\", \"h\"): Unit.OClock,\n    (\"inch\", \"in\"): Unit.Inch,\n    (\"foot\", \"feet\", \"ft\"): Unit.Foot,\n    (\"yard\", \"yd\"): Unit.Yard,\n    (\"mile\", \"mi\", \"mi.\"): Unit.Mile,\n    (\"nauticalmile\", \"nm\", \"nmi\"): Unit.NauticalMile,\n    (\"millimeter\", \"mm\"): Unit.Millimeter,\n    (\"centimeter\", \"cm\"): Unit.Centimeter,\n    (\"meter\", \"m\"): Unit.Meter,\n    (\"kilometer\", \"km\"): Unit.Kilometer,\n    (\"line\", \"ln\", \"lini\u0430\"): Unit.Line,\n    (\"footpound\", \"foot-pound\", \"ft\u22c5lbf\", \"ft\u22c5lb\", \"foot*pound\", \"ft*lbf\", \"ft*lb\"): Unit.FootPound,\n    (\"joule\", \"J\"): Unit.Joule,\n    (\"mmHg\",): Unit.MmHg,\n    (\"inHg\", '\"Hg'): Unit.InHg,\n    (\"bar\",): Unit.Bar,\n    (\"hectopascal\", \"hPa\"): Unit.hPa,\n    (\"psi\", \"lbf/in2\"): Unit.PSI,\n    (\"fahrenheit\", \"\u00b0F\", \"F\", \"degF\"): Unit.Fahrenheit,\n    (\"celsius\", \"\u00b0C\", \"C\", \"degC\"): Unit.Celsius,\n    (\"kelvin\", \"\u00b0K\", \"K\", \"degK\"): Unit.Kelvin,\n    (\"rankin\", \"\u00b0R\", \"R\", \"degR\"): Unit.Rankin,\n    (\"meter/second\", \"m/s\", \"meter/s\", \"m/second\", \"mps\"): Unit.MPS,\n    (\"kilometer/hour\", \"km/h\", \"kilometer/h\", \"km/hour\", \"kmh\"): Unit.KMH,\n    (\"foot/second\", \"feet/second\", \"ft/s\", \"foot/s\", \"feet/s\", \"ft/second\", \"fps\"): Unit.FPS,\n    (\"mile/hour\", \"mi/h\", \"mile/h\", \"mi/hour\", \"mph\"): Unit.MPH,\n    (\"knot\", \"kn\", \"kt\"): Unit.KT,\n    (\"grain\", \"gr\", \"grn\"): Unit.Grain,\n    (\"ounce\", \"oz\"): Unit.Ounce,\n    (\"gram\", \"g\"): Unit.Gram,\n    (\"pound\", \"lb\"): Unit.Pound,\n    (\"kilogram\", \"kilogramme\", \"kg\"): Unit.Kilogram,\n    (\"newton\", \"N\"): Unit.Newton,\n    (\"minute\", \"min\"): Unit.Minute,\n    (\"second\", \"s\", \"sec\"): Unit.Second,\n    (\"millisecond\", \"ms\"): Unit.Millisecond,\n    (\"microsecond\", \"us\", \"\u00b5s\"): Unit.Microsecond,\n    (\"nanosecond\", \"ns\"): Unit.Nanosecond,\n    (\"picosecond\", \"ps\"): Unit.Picosecond,\n}\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit","title":"Unit","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of all supported unit types.</p> <ul> <li>Angular: Radian, Degree, MOA, Mil, MRad, Thousandth, InchesPer100Yd, CmPer100m, OClock</li> <li>Distance: Inch, Foot, Yard, Mile, NauticalMile, Millimeter, Centimeter, Meter, Kilometer, Line</li> <li>Velocity: MPS (meters/second), KMH (km/hour), FPS (feet/second), MPH (miles/hour), KT (knots)</li> <li>Weight: Grain, Ounce, Gram, Pound, Kilogram, Newton</li> <li>Pressure: MmHg, InHg, Bar, hPa (hectopascal), PSI</li> <li>Temperature: Fahrenheit, Celsius, Kelvin, Rankin</li> <li>Energy: FootPound, Joule</li> <li>Time: Second, Minute, Millisecond, Microsecond, Nanosecond, Picosecond</li> </ul> <p>Each unit can be used as a callable constructor for creating unit instances:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create distance measurements\n&gt;&gt;&gt; distance = Unit.Meter(100)\n&gt;&gt;&gt; range_yards = Unit.Yard(109.4)\n</code></pre> <pre><code>&gt;&gt;&gt; # Create velocity measurements\n&gt;&gt;&gt; muzzle_velocity = Unit.FPS(2800)\n&gt;&gt;&gt; velocity_mps = Unit.MPS(853.4)\n</code></pre> <pre><code>&gt;&gt;&gt; # Angular measurements for ballistics\n&gt;&gt;&gt; elevation = Unit.MOA(2.5)\n&gt;&gt;&gt; windage = Unit.Mil(1.2)\n</code></pre> <p>Methods:</p> Name Description <code>counter</code> <p>Generate a finite or infinite sequence of <code>GenericDimension</code> objects.</p> <code>iterator</code> <p>Create a sorted sequence of <code>GenericDimension</code> objects from raw numeric values.</p> <code>parse</code> <p>Parse a value with optional unit specification into a unit measurement.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>Readable name of the unit of measure.</p> <code>accuracy</code> <code>int</code> <p>Default accuracy of the unit of measure.</p> <code>symbol</code> <code>str</code> <p>Short symbol of the unit of measure.</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit-attributes","title":"Attributes","text":""},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>Readable name of the unit of measure.</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit.accuracy","title":"accuracy  <code>property</code>","text":"<pre><code>accuracy: int\n</code></pre> <p>Default accuracy of the unit of measure.</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit.symbol","title":"symbol  <code>property</code>","text":"<pre><code>symbol: str\n</code></pre> <p>Short symbol of the unit of measure.</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit-functions","title":"Functions","text":""},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit.counter","title":"counter","text":"<pre><code>counter(\n    start: Number,\n    step: Number,\n    end: Optional[Number] = None,\n    include_end: bool = True,\n) -&gt; Generator[GenericDimension, None, None]\n</code></pre> <p>Generate a finite or infinite sequence of <code>GenericDimension</code> objects.</p> <p>This function acts as a counter for measurements, yielding <code>GenericDimension</code> instances at specified intervals, defined by <code>start</code>, <code>step</code>, and <code>end</code>. The underlying numeric values are handled as raw values of the given unit.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Number</code> <p>The starting raw value for the sequence. Defaults to 0.</p> required <code>step</code> <code>Number</code> <p>The increment/decrement step for the sequence.                 Must not be 0 for an infinite sequence. Defaults to 0.</p> required <code>end</code> <code>Optional[Number]</code> <p>The raw value at which the sequence should stop (exclusive by default).                          If <code>None</code>, the sequence is infinite. Defaults to <code>None</code>.</p> <code>None</code> <code>include_end</code> <code>bool</code> <p>If <code>True</code> and <code>end</code> is provided, the <code>end</code> value will be                 included in the sequence. Defaults to <code>True</code>.</p> <code>True</code> <p>Yields:</p> Type Description <code>GenericDimension</code> <p>GenericDimension[Any]: A <code>GenericDimension</code> object representing the current measurement in the sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>step</code> is 0 for an infinite sequence, or if <code>step</code> has the wrong     direction for the given <code>start</code> and <code>end</code> range.</p> <code>StopIteration</code> <p>If the iteration limit (<code>MAX_ITERATIONS</code>) is reached during an infinite sequence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(Unit.Millisecond.counter(start=0, step=10, end=30))\n[&lt;Time: 0.0ms (0.0)&gt;, &lt;Time: 10.0ms (0.01)&gt;, &lt;Time: 20.0ms (0.02)&gt;, &lt;Time: 30.0ms (0.03)&gt;]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def counter(\n    self, start: Number, step: Number, end: Optional[Number] = None, include_end: bool = True\n) -&gt; Generator[GenericDimension, None, None]:\n    \"\"\"Generate a finite or infinite sequence of `GenericDimension` objects.\n\n    This function acts as a counter for measurements, yielding `GenericDimension`\n    instances at specified intervals, defined by `start`, `step`, and `end`.\n    The underlying numeric values are handled as raw values of the given unit.\n\n    Args:\n        start: The starting raw value for the sequence. Defaults to 0.\n        step: The increment/decrement step for the sequence.\n                            Must not be 0 for an infinite sequence. Defaults to 0.\n        end: The raw value at which the sequence should stop (exclusive by default).\n                                     If `None`, the sequence is infinite. Defaults to `None`.\n        include_end: If `True` and `end` is provided, the `end` value will be\n                            included in the sequence. Defaults to `True`.\n\n    Yields:\n        GenericDimension[Any]: A `GenericDimension` object representing the current measurement in the sequence.\n\n    Raises:\n        ValueError:\n            If `step` is 0 for an infinite sequence, or if `step` has the wrong\n                direction for the given `start` and `end` range.\n        StopIteration:\n            If the iteration limit (`MAX_ITERATIONS`) is reached during an infinite sequence.\n\n    Examples:\n        &gt;&gt;&gt; list(Unit.Millisecond.counter(start=0, step=10, end=30))\n        [&lt;Time: 0.0ms (0.0)&gt;, &lt;Time: 10.0ms (0.01)&gt;, &lt;Time: 20.0ms (0.02)&gt;, &lt;Time: 30.0ms (0.03)&gt;]\n    \"\"\"\n    _start: GenericDimension = self(start)\n    _step: GenericDimension = self(step)\n    _end: Optional[GenericDimension] = self(end) if end is not None else None\n\n    _start_raw: Number = _start.raw_value\n    _step_raw: Number = _step.raw_value\n    _end_raw: Optional[Number] = _end.raw_value if _end is not None else None\n\n    if _end_raw is not None and include_end:\n        _end_raw += _step_raw\n    for i, raw_value in enumerate(counter(_start_raw, _step_raw, _end_raw)):\n        value: GenericDimension = self(0)\n        value._value = raw_value\n        yield value\n        if i == MAX_ITERATIONS:\n            raise ValueError(\"Reached generator limit %d\" % MAX_ITERATIONS)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit.iterator","title":"iterator","text":"<pre><code>iterator(\n    items: Sequence[Number],\n    /,\n    *,\n    sort: bool = False,\n    reverse: bool = False,\n) -&gt; Generator[\"GenericDimension[Any]\", None, None]\n</code></pre> <p>Create a sorted sequence of <code>GenericDimension</code> objects from raw numeric values.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[Number]</code> <p>A sequence of raw numeric values (integers or floats).</p> required <code>sort</code> <code>bool</code> <p>If set to <code>True</code>, the elements will be sorted before yield.</p> <code>False</code> <code>reverse</code> <code>bool</code> <p>If set to <code>True</code>, the elements are sorted in descending order. Defaults to <code>False</code>.</p> <code>False</code> <p>Yields:</p> Name Type Description <code>_GenericDimensionType</code> <code>'GenericDimension[Any]'</code> <p>A <code>GenericDimension</code> object of the specific type implied by <code>u</code>, in sorted order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(Unit.Foot.iterator([5, 1, 2], sort=True))  # Inferred as Iterable[Distance]\n[&lt;Distance: 1.0ft (12.0)&gt;, &lt;Distance: 2.0ft (24.0)&gt;, &lt;Distance: 5.0ft (60.0)&gt;]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def iterator(\n    self, items: Sequence[Number], /, *, sort: bool = False, reverse: bool = False\n) -&gt; Generator[\"GenericDimension[Any]\", None, None]:\n    \"\"\"Create a sorted sequence of `GenericDimension` objects from raw numeric values.\n\n    Args:\n        items: A sequence of raw numeric values (integers or floats).\n        sort: If set to `True`, the elements will be sorted before yield.\n        reverse: If set to `True`, the elements are sorted in descending order. Defaults to `False`.\n\n    Yields:\n        _GenericDimensionType: A `GenericDimension` object of the specific type implied by `u`, in sorted order.\n\n    Examples:\n        &gt;&gt;&gt; list(Unit.Foot.iterator([5, 1, 2], sort=True))  # Inferred as Iterable[Distance]\n        [&lt;Distance: 1.0ft (12.0)&gt;, &lt;Distance: 2.0ft (24.0)&gt;, &lt;Distance: 5.0ft (60.0)&gt;]\n    \"\"\"\n    iter_ = iterator(items, sort=sort, reverse=reverse)\n    for v in iter_:\n        yield self(v)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Unit.parse","title":"parse  <code>staticmethod</code>","text":"<pre><code>parse(\n    input_: Union[str, Number],\n    preferred: Optional[Union[Unit, str]] = None,\n) -&gt; Optional[Union[GenericDimension[Any], Any, Unit]]\n</code></pre> <p>Parse a value with optional unit specification into a unit measurement.</p> <p>Parameters:</p> Name Type Description Default <code>input_</code> <code>Union[str, Number]</code> <p>Value to parse - can be a number or string with optional unit.</p> required <code>preferred</code> <code>Optional[Union[Unit, str]]</code> <p>Preferred unit to use for numeric inputs, either as Unit enum or string alias.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Union[GenericDimension[Any], Any, Unit]]</code> <p>Parsed unit measurement if successful, raises exception on failure.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input type is not supported.</p> <code>UnitAliasError</code> <p>If unit alias cannot be parsed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Parse numeric value with preferred unit\n&gt;&gt;&gt; Unit.parse(100, Unit.Meter)\n&lt;Distance: 100.0m (3937.0079)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; # Parse string with embedded unit\n&gt;&gt;&gt; Unit.parse('2yd')\n&lt;Distance: 2.0yd (72.0)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; # Parse with PreferredUnit string\n&gt;&gt;&gt; Unit.parse(50, 'grain')\n&lt;Weight: 50.0gr (50.0)&gt;\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@staticmethod\ndef parse(\n    input_: Union[str, Number], preferred: Optional[Union[Unit, str]] = None\n) -&gt; Optional[Union[GenericDimension[Any], Any, Unit]]:\n    \"\"\"Parse a value with optional unit specification into a unit measurement.\n\n    Args:\n        input_: Value to parse - can be a number or string with optional unit.\n        preferred: Preferred unit to use for numeric inputs, either as Unit enum or string alias.\n\n    Returns:\n        Parsed unit measurement if successful, raises exception on failure.\n\n    Raises:\n        TypeError: If input type is not supported.\n        UnitAliasError: If unit alias cannot be parsed.\n\n    Examples:\n        &gt;&gt;&gt; # Parse numeric value with preferred unit\n        &gt;&gt;&gt; Unit.parse(100, Unit.Meter)\n        &lt;Distance: 100.0m (3937.0079)&gt;\n\n        &gt;&gt;&gt; # Parse string with embedded unit\n        &gt;&gt;&gt; Unit.parse('2yd')\n        &lt;Distance: 2.0yd (72.0)&gt;\n\n        &gt;&gt;&gt; # Parse with PreferredUnit string\n        &gt;&gt;&gt; Unit.parse(50, 'grain')\n        &lt;Weight: 50.0gr (50.0)&gt;\n    \"\"\"\n\n    def create_as_preferred(value_):\n        if isinstance(preferred, Unit):\n            return preferred(float(value_))\n        if isinstance(preferred, str):\n            if units_ := Unit._parse_unit(preferred):\n                return units_(float(value_))\n        raise UnitAliasError(f\"Unsupported {preferred=} unit alias\")\n\n    if isinstance(input_, (float, int)):\n        return create_as_preferred(input_)\n\n    if not isinstance(input_, str):\n        raise TypeError(f\"type, [str, float, int] expected for 'input_', got {type(input_)}\")\n\n    input_string = input_.replace(\" \", \"\")\n    if match := re.match(r\"^-?(?:\\d+\\.\\d*|\\.\\d+|\\d+\\.?)$\", input_string):\n        value = match.group()\n        return create_as_preferred(value)\n\n    if match := re.match(r\"(^-?(?:\\d+\\.\\d*|\\.\\d+|\\d+\\.?))(.*$)\", input_string):\n        value, alias = match.groups()\n        if units := Unit._parse_unit(alias):\n            return units(float(value))\n        raise UnitAliasError(f\"Unsupported unit {alias=}\")\n\n    raise UnitAliasError(f\"Can't parse unit {input_=}\")\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension","title":"GenericDimension","text":"<pre><code>GenericDimension(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>Generic[_GenericDimensionType]</code></p> <p>Abstract base class for typed unit dimensions.</p> <p>This class provides the foundation for all unit measurements in the ballistic calculation system. Each dimension (Distance, Velocity, Angular, etc.) inherits from this class and defines its own conversion factors and raw unit representation.</p> <p>Attributes:</p> Name Type Description <code>_value</code> <code>Number</code> <p>Internal value stored in the dimension's raw unit.</p> <code>_defined_units</code> <code>Unit</code> <p>The unit type this instance was created with.</p> <code>_conversion_factors</code> <code>Mapping[Unit, float]</code> <p>Mapping of units to their conversion factors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Subclasses define their own conversion factors\n&gt;&gt;&gt; class Distance(GenericDimension):\n...     _conversion_factors = {Unit.Meter: 39.3701, Unit.Yard: 36.0}\n</code></pre> <pre><code>&gt;&gt;&gt; # Create and convert measurements\n&gt;&gt;&gt; meters = Distance(100, Unit.Meter)\n&gt;&gt;&gt; yards = meters.convert(Unit.Yard)\n&gt;&gt;&gt; print(f\"100m = {yards.unit_value:.1f} yards\")\n100m = 109.4 yards\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Number</code> <p>Numeric value of the measurement in the specified units.</p> required <code>units</code> <code>Unit</code> <p>Unit enum specifying the unit type for the value.</p> required <p>Methods:</p> Name Description <code>new_from_raw</code> <p>Create a new instance from a raw value in base units.</p> <code>from_raw</code> <p>Convert a raw value to the specified units.</p> <code>to_raw</code> <p>Convert a value in specified units to the raw unit.</p> <code>convert</code> <p>Convert this measurement to different units within the same dimension.</p> <code>get_in</code> <p>Get the numeric value of this measurement in specified units.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension-attributes","title":"Attributes","text":""},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.units","title":"units  <code>property</code>","text":"<pre><code>units: Unit\n</code></pre> <p>Get the unit type this dimension instance was defined with.</p> <p>Returns:</p> Type Description <code>Unit</code> <p>Unit enum representing the unit type of this measurement.</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.unit_value","title":"unit_value  <code>property</code>","text":"<pre><code>unit_value: Number\n</code></pre> <p>Get the numeric value in the defined units.</p> <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value in the units this measurement was created with.</p> Note <p>Equivalent to get_in(self.units) but more efficient as a property.</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.raw_value","title":"raw_value  <code>property</code>","text":"<pre><code>raw_value: Number\n</code></pre> <p>Get the internal raw value used for calculations.</p> <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value in the dimension's raw unit (e.g., inches for Distance).</p>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension-functions","title":"Functions","text":""},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.new_from_raw","title":"new_from_raw  <code>classmethod</code>","text":"<pre><code>new_from_raw(raw_value: float, to_units: Unit) -&gt; Self\n</code></pre> <p>Create a new instance from a raw value in base units.</p> <p>Parameters:</p> Name Type Description Default <code>raw_value</code> <code>float</code> <p>Value in the dimension's raw unit (e.g., inches for Distance).</p> required <code>to_units</code> <code>Unit</code> <p>Target unit type for the new instance.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New instance with the raw value converted to the specified units.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef new_from_raw(cls, raw_value: float, to_units: Unit) -&gt; Self:\n    \"\"\"Create a new instance from a raw value in base units.\n\n    Args:\n        raw_value: Value in the dimension's raw unit (e.g., inches for Distance).\n        to_units: Target unit type for the new instance.\n\n    Returns:\n        New instance with the raw value converted to the specified units.\n    \"\"\"\n    value_in_units = raw_value / cls._get_conversion_factor(to_units)\n    return cls(value_in_units, to_units)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.from_raw","title":"from_raw  <code>classmethod</code>","text":"<pre><code>from_raw(raw_value: float, unit: Unit) -&gt; Number\n</code></pre> <p>Convert a raw value to the specified units.</p> <p>Parameters:</p> Name Type Description Default <code>raw_value</code> <code>float</code> <p>Value in the dimension's raw unit.</p> required <code>unit</code> <code>Unit</code> <p>Target unit type for conversion.</p> required <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value converted to the specified units.</p> Note <p>Static conversion method that doesn't create a unit instance.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef from_raw(cls, raw_value: float, unit: Unit) -&gt; Number:\n    \"\"\"Convert a raw value to the specified units.\n\n    Args:\n        raw_value: Value in the dimension's raw unit.\n        unit: Target unit type for conversion.\n\n    Returns:\n        Numeric value converted to the specified units.\n\n    Note:\n        Static conversion method that doesn't create a unit instance.\n    \"\"\"\n    cls._validate_unit_type(unit)\n    return raw_value / cls._get_conversion_factor(unit)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.to_raw","title":"to_raw  <code>classmethod</code>","text":"<pre><code>to_raw(value: Number, units: Unit) -&gt; Number\n</code></pre> <p>Convert a value in specified units to the raw unit.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Number</code> <p>Numeric value to convert.</p> required <code>units</code> <code>Unit</code> <p>Unit type of the input value.</p> required <p>Returns:</p> Type Description <code>Number</code> <p>Value converted to the dimension's raw unit.</p> Note <p>Used internally for storing values in consistent raw units.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef to_raw(cls, value: Number, units: Unit) -&gt; Number:\n    \"\"\"Convert a value in specified units to the raw unit.\n\n    Args:\n        value: Numeric value to convert.\n        units: Unit type of the input value.\n\n    Returns:\n        Value converted to the dimension's raw unit.\n\n    Note:\n        Used internally for storing values in consistent raw units.\n    \"\"\"\n    cls._validate_unit_type(units)\n    return value * cls._get_conversion_factor(units)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.convert","title":"convert","text":"<pre><code>convert(units: Unit) -&gt; Self\n</code></pre> <p>Convert this measurement to different units within the same dimension.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Unit</code> <p>Target unit type for conversion.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New instance of the same dimension type with value in target units.</p> <p>Raises:</p> Type Description <code>UnitConversionError</code> <p>If target units are incompatible with this dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance = Distance.Meter(100)\n&gt;&gt;&gt; print(f\"100m = {distance.convert(Distance.Yard)}\")\n100m = 109.4yd\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def convert(self, units: Unit) -&gt; Self:\n    \"\"\"Convert this measurement to different units within the same dimension.\n\n    Args:\n        units: Target unit type for conversion.\n\n    Returns:\n        New instance of the same dimension type with value in target units.\n\n    Raises:\n        UnitConversionError: If target units are incompatible with this dimension.\n\n    Examples:\n        &gt;&gt;&gt; distance = Distance.Meter(100)\n        &gt;&gt;&gt; print(f\"100m = {distance.convert(Distance.Yard)}\")\n        100m = 109.4yd\n    \"\"\"\n    return self.__class__.new_from_raw(self._value, units)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.GenericDimension.get_in","title":"get_in","text":"<pre><code>get_in(units: Unit) -&gt; Number\n</code></pre> <p>Get the numeric value of this measurement in specified units.</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Unit</code> <p>Target unit type for the value.</p> required <p>Returns:</p> Type Description <code>Number</code> <p>Numeric value in the specified units (float or int).</p> <p>Raises:</p> Type Description <code>UnitConversionError</code> <p>If target units are incompatible with this dimension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance = Distance.Meter(100)\n&gt;&gt;&gt; print(f\"100m = {distance.get_in(Distance.Yard):.5f} yards\")\n100m = 109.36133 yards\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def get_in(self, units: Unit) -&gt; Number:\n    \"\"\"Get the numeric value of this measurement in specified units.\n\n    Args:\n        units: Target unit type for the value.\n\n    Returns:\n        Numeric value in the specified units (float or int).\n\n    Raises:\n        UnitConversionError: If target units are incompatible with this dimension.\n\n    Examples:\n        &gt;&gt;&gt; distance = Distance.Meter(100)\n        &gt;&gt;&gt; print(f\"100m = {distance.get_in(Distance.Yard):.5f} yards\")\n        100m = 109.36133 yards\n    \"\"\"\n    return self.__class__.from_raw(self._value, units)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.counter","title":"counter","text":"<pre><code>counter(\n    start: Number = 0,\n    step: Number = 1,\n    end: Optional[Number] = None,\n) -&gt; Iterable[Number]\n</code></pre> <p>Generate a sequence of numbers with optional bounds.</p> <p>Creates an arithmetic sequence starting at 'start' with a constant increment/decrement of 'step'. Can generate infinite sequences or bounded sequences up to 'end'.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Number</code> <p>Initial value for the sequence. Defaults to 0.</p> <code>0</code> <code>step</code> <code>Number</code> <p>Increment/decrement step value. Cannot be 0 for infinite iteration.   Positive values create ascending sequences, negative values create descending sequences. Defaults to 1.</p> <code>1</code> <code>end</code> <code>Optional[Number]</code> <p>Final value (exclusive) for bounded sequences. If None, creates an infinite sequence. Defaults to None.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>Number</code> <code>Iterable[Number]</code> <p>The next value in the arithmetic sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'step' is 0 for infinite iteration, or if 'step' has the wrong sign         for the given 'start' and 'end' range (e.g., positive step with start &gt; end).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Finite ascending sequence\n&gt;&gt;&gt; list(counter(0, 1, 5))\n[0, 1, 2, 3, 4]\n</code></pre> <pre><code>&gt;&gt;&gt; # Finite descending sequence\n&gt;&gt;&gt; list(counter(10, -2, 0))\n[10, 8, 6, 4, 2]\n</code></pre> <pre><code>&gt;&gt;&gt; # Infinite sequence (first 3 values)\n&gt;&gt;&gt; iter_seq = counter(1, 0.5)\n&gt;&gt;&gt; [next(iter_seq) for _ in range(3)]\n[1, 1.5, 2.0]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def counter(start: Number = 0, step: Number = 1, end: Optional[Number] = None) -&gt; Iterable[Number]:\n    \"\"\"Generate a sequence of numbers with optional bounds.\n\n    Creates an arithmetic sequence starting at 'start' with a constant increment/decrement of 'step'.\n    Can generate infinite sequences or bounded sequences up to 'end'.\n\n    Args:\n        start: Initial value for the sequence. Defaults to 0.\n        step: Increment/decrement step value. Cannot be 0 for infinite iteration.\n              Positive values create ascending sequences, negative values create descending sequences. Defaults to 1.\n        end: Final value (exclusive) for bounded sequences. If None, creates an infinite sequence. Defaults to None.\n\n    Yields:\n        Number: The next value in the arithmetic sequence.\n\n    Raises:\n        ValueError: If 'step' is 0 for infinite iteration, or if 'step' has the wrong sign\n                    for the given 'start' and 'end' range (e.g., positive step with start &gt; end).\n\n    Examples:\n        &gt;&gt;&gt; # Finite ascending sequence\n        &gt;&gt;&gt; list(counter(0, 1, 5))\n        [0, 1, 2, 3, 4]\n\n        &gt;&gt;&gt; # Finite descending sequence\n        &gt;&gt;&gt; list(counter(10, -2, 0))\n        [10, 8, 6, 4, 2]\n\n        &gt;&gt;&gt; # Infinite sequence (first 3 values)\n        &gt;&gt;&gt; iter_seq = counter(1, 0.5)\n        &gt;&gt;&gt; [next(iter_seq) for _ in range(3)]\n        [1, 1.5, 2.0]\n    \"\"\"\n    if step == 0:\n        if end is None:\n            raise ValueError(\"For infinite iteration, 'step' cannot be zero.\")\n        else:\n            if (end &gt; start and start &lt;= end) or (end &lt; start and start &gt;= end) or (start == end):\n                yield start\n            return\n\n    current = start\n    if end is None:\n        while True:\n            yield current\n            current += step\n    else:\n        if step &gt; 0:\n            if start &gt; end:\n                raise ValueError(\"For an incremental step (step &gt; 0), 'start' cannot be greater than 'end'.\")\n            while current &lt; end:\n                yield current\n                current += step\n        else:  # step &lt; 0\n            if start &lt; end:\n                raise ValueError(\"For a decrementing step (step &lt; 0), 'start' cannot be less than 'end'.\")\n            while current &gt; end:\n                yield current\n                current += step\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.iterator","title":"iterator","text":"<pre><code>iterator(\n    items: Sequence[Number],\n    /,\n    *,\n    sort: bool = False,\n    key: Optional[Callable[[Number], Any]] = None,\n    reverse: bool = False,\n) -&gt; Generator[Number, None, None]\n</code></pre> <p>Create a generator from a sequence of numbers with optional sorting.</p> <p>Provides a flexible iterator interface for numeric sequences. Supports optional sorting with custom key functions and reverse ordering.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Sequence[Number]</code> <p>Sequence of numeric values (integers or floats) to iterate over.</p> required <code>sort</code> <code>bool</code> <p>If True, sort the items before iteration. Defaults to False.</p> <code>False</code> <code>key</code> <code>Optional[Callable[[Number], Any]]</code> <p>Optional function to extract comparison key from each item.  Used only when sort=True. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If True, reverse the iteration order (used with sorting).      Defaults to False.</p> <code>False</code> <p>Yields:</p> Name Type Description <code>Number</code> <code>Number</code> <p>Each numeric value from the sequence in the specified order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Basic iteration\n&gt;&gt;&gt; list(iterator([3, 1, 4, 2]))\n[3, 1, 4, 2]\n</code></pre> <pre><code>&gt;&gt;&gt; # Sorted iteration\n&gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True))\n[1, 2, 3, 4]\n</code></pre> <pre><code>&gt;&gt;&gt; # Reverse sorted iteration\n&gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True, reverse=True))\n[4, 3, 2, 1]\n</code></pre> <pre><code>&gt;&gt;&gt; # Custom key function\n&gt;&gt;&gt; list(iterator([-3, 1, -4, 2], sort=True, key=abs))\n[1, 2, -3, -4]\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def iterator(\n    items: Sequence[Number],\n    /,\n    *,\n    sort: bool = False,\n    key: Optional[Callable[[Number], Any]] = None,\n    reverse: bool = False,\n) -&gt; Generator[Number, None, None]:\n    \"\"\"Create a generator from a sequence of numbers with optional sorting.\n\n    Provides a flexible iterator interface for numeric sequences.\n    Supports optional sorting with custom key functions and reverse ordering.\n\n    Args:\n        items: Sequence of numeric values (integers or floats) to iterate over.\n        sort: If True, sort the items before iteration. Defaults to False.\n        key: Optional function to extract comparison key from each item.\n             Used only when sort=True. Defaults to None.\n        reverse: If True, reverse the iteration order (used with sorting).\n                 Defaults to False.\n\n    Yields:\n        Number: Each numeric value from the sequence in the specified order.\n\n    Examples:\n        &gt;&gt;&gt; # Basic iteration\n        &gt;&gt;&gt; list(iterator([3, 1, 4, 2]))\n        [3, 1, 4, 2]\n\n        &gt;&gt;&gt; # Sorted iteration\n        &gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True))\n        [1, 2, 3, 4]\n\n        &gt;&gt;&gt; # Reverse sorted iteration\n        &gt;&gt;&gt; list(iterator([3, 1, 4, 2], sort=True, reverse=True))\n        [4, 3, 2, 1]\n\n        &gt;&gt;&gt; # Custom key function\n        &gt;&gt;&gt; list(iterator([-3, 1, -4, 2], sort=True, key=abs))\n        [1, 2, -3, -4]\n    \"\"\"\n    if sort:\n        items = sorted(items, key=key, reverse=reverse)\n    for v in items:\n        yield v\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Angular","title":"Angular","text":"<pre><code>Angular(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Angular measurements.  Raw value is radians.</p> <p>This class tries to normalize angles to the range (-\u03c0, \u03c0].</p> <p>Methods:</p> Name Description <code>to_raw</code> <p>Normalize angle to (-\u03c0, \u03c0].</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Angular-functions","title":"Functions","text":""},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Angular.to_raw","title":"to_raw  <code>classmethod</code>","text":"<pre><code>to_raw(value: Number, units: Unit) -&gt; Number\n</code></pre> <p>Normalize angle to (-\u03c0, \u03c0].</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@override\n@classmethod\ndef to_raw(cls, value: Number, units: Unit) -&gt; Number:\n    \"\"\"Normalize angle to (-\u03c0, \u03c0].\"\"\"\n    radians = super().to_raw(value, units)\n    # Normalize to [-\u03c0, \u03c0)\n    r = (radians + pi) % (2.0 * pi) - pi\n    return r if r &gt; -pi else pi  # move -\u03c0 to +\u03c0\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Distance","title":"Distance","text":"<pre><code>Distance(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Distance measurements.  Raw value is inches.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Energy","title":"Energy","text":"<pre><code>Energy(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Energy measurements.  Raw unit is foot-pounds.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Pressure","title":"Pressure","text":"<pre><code>Pressure(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Pressure unit.  Raw value is mmHg.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Temperature","title":"Temperature","text":"<pre><code>Temperature(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Temperature unit.  Raw value is Fahrenheit.</p> <p>This dimension only supports addition and subtraction operations, and tries to clamp results at absolute zero.</p> <p>Methods:</p> Name Description <code>new_from_raw</code> <p>Create Temperature from raw Fahrenheit value into target units.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Temperature-functions","title":"Functions","text":""},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Temperature.new_from_raw","title":"new_from_raw  <code>classmethod</code>","text":"<pre><code>new_from_raw(\n    raw_value: float, to_units: Unit\n) -&gt; Temperature\n</code></pre> <p>Create Temperature from raw Fahrenheit value into target units.</p> <p>Unlike other dimensions, Temperature uses affine conversions; this method     relies on <code>from_raw</code> instead of dividing by a scale factor.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@override\n@classmethod\ndef new_from_raw(cls, raw_value: float, to_units: Unit) -&gt; Temperature:\n    \"\"\"Create Temperature from raw Fahrenheit value into target units.\n\n    Unlike other dimensions, Temperature uses affine conversions; this method\n        relies on `from_raw` instead of dividing by a scale factor.\n    \"\"\"\n    # Temperature conversion uses affine transforms; do not divide by a factor.\n    value_in_units = cls.from_raw(raw_value, to_units)\n    return cls(value_in_units, to_units)\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Time","title":"Time","text":"<pre><code>Time(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Time measurements.  Raw unit is seconds.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Velocity","title":"Velocity","text":"<pre><code>Velocity(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Velocity measurements.  Raw unit is meters per second.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.Weight","title":"Weight","text":"<pre><code>Weight(value: Number, units: Unit)\n</code></pre> <p>               Bases: <code>GenericDimension</code></p> <p>Weight unit.  Raw value is grains.</p> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>def __init__(self, value: Number, units: Unit):\n    \"\"\"Initialize a unit measurement with value and unit type.\n\n    Args:\n        value: Numeric value of the measurement in the specified units.\n        units: Unit enum specifying the unit type for the value.\n    \"\"\"\n    self._value: Number = self.__class__.to_raw(value, units)\n    self._defined_units: Unit = units\n</code></pre>"},{"location":"api/units/dimensions/#py_ballisticcalc.unit.UnitAliases","title":"<code>UnitAliases</code>  <code>module-attribute</code>","text":""},{"location":"api/units/preferred_units/","title":"PreferredUnits","text":""},{"location":"api/units/preferred_units/#py_ballisticcalc.unit.PreferredUnits","title":"<code>PreferredUnits</code>  <code>dataclass</code>","text":"<p>Configuration class for default units used throughout ballistic calculations.</p> <p>This class defines the default units that will be used when creating measurements without explicitly specifying units, and for displaying results in user interfaces. It provides a centralized way to configure unit preferences for an entire ballistic calculation session. This allows users to set their preferred unit system once and have it apply to all subsequent calculations.</p> Default Configuration <ul> <li>angular: Degree (for look-angle and barrel elevation)</li> <li>distance: Yard (traditional ballistic range unit)</li> <li>velocity: FPS (feet per second)</li> <li>pressure: InHg (inches of mercury, for barometric pressure)</li> <li>temperature: Fahrenheit</li> <li>diameter: Inch (bullet and bore diameter)</li> <li>length: Inch (bullet length, barrel length)</li> <li>weight: Grain (bullet weight, powder charge)</li> <li>adjustment: Mil (scope adjustment increments)</li> <li>drop: Inch (trajectory vertical measurements)</li> <li>energy: FootPound (kinetic energy)</li> <li>ogw: Pound (optimal game weight)</li> <li>sight_height: Inch (scope height above bore)</li> <li>target_height: Inch (target dimensions)</li> <li>twist: Inch (barrel twist rate)</li> <li>time: Second (flight time)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set metric preferences\n&gt;&gt;&gt; PreferredUnits.distance = Unit.Meter\n&gt;&gt;&gt; PreferredUnits.velocity = Unit.MPS\n</code></pre> <pre><code>&gt;&gt;&gt; # Reset to defaults\n&gt;&gt;&gt; PreferredUnits.restore_defaults()\n</code></pre> <pre><code>&gt;&gt;&gt; # Bulk configuration\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance='meter',\n...     velocity='mps',\n...     temperature='celsius'\n... )\n</code></pre> Note <p>Changing preferred units affects all subsequent unit creation and display.</p> <p>Methods:</p> Name Description <code>restore_defaults</code> <p>Reset all preferred units to their default values.</p> <code>set</code> <p>Set preferred units from keyword arguments.</p>"},{"location":"api/units/preferred_units/#py_ballisticcalc.unit.PreferredUnits-functions","title":"Functions","text":""},{"location":"api/units/preferred_units/#py_ballisticcalc.unit.PreferredUnits.restore_defaults","title":"<code>restore_defaults</code>  <code>classmethod</code>","text":"<p>Reset all preferred units to their default values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Changing default distance units:\n&gt;&gt;&gt; PreferredUnits.distance = Unit.Meter\n&gt;&gt;&gt; # Reset to defaults\n&gt;&gt;&gt; PreferredUnits.restore_defaults()\n&gt;&gt;&gt; PreferredUnits.distance\nyard\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef restore_defaults(cls):\n    \"\"\"Reset all preferred units to their default values.\n\n    Examples:\n        &gt;&gt;&gt; # Changing default distance units:\n        &gt;&gt;&gt; PreferredUnits.distance = Unit.Meter\n        &gt;&gt;&gt; # Reset to defaults\n        &gt;&gt;&gt; PreferredUnits.restore_defaults()\n        &gt;&gt;&gt; PreferredUnits.distance\n        yard\n    \"\"\"\n    for f in fields(cls):\n        if f.default is not MISSING:\n            setattr(cls, f.name, f.default)\n        elif getattr(f, \"default_factory\", MISSING) is not MISSING:\n            setattr(cls, f.name, f.default_factory())  # type: ignore\n</code></pre>"},{"location":"api/units/preferred_units/#py_ballisticcalc.unit.PreferredUnits.set","title":"<code>set</code>  <code>classmethod</code>","text":"<p>Set preferred units from keyword arguments.</p> <p>Allows bulk configuration of preferred units using either Unit enum values or string aliases. Invalid attributes or values are logged as warnings but do not raise exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Union[Unit, str, bool]</code> <p>Keyword arguments where keys are attribute names and values       are either Unit enum values or (string) UnitAliases.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Set using Unit enums\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance=Unit.Meter,\n...     velocity=Unit.MPS,\n...     temperature=Unit.Celsius\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Set using string aliases\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance='meter',\n...     velocity='mps',\n...     weight='gram'\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Mixed types\n&gt;&gt;&gt; PreferredUnits.set(\n...     distance=Unit.Yard,\n...     velocity='fps',\n...     adjustment='mil'\n... )\n</code></pre> Source code in <code>py_ballisticcalc/unit.py</code> <pre><code>@classmethod\ndef set(cls, **kwargs: Union[Unit, str, bool]):\n    \"\"\"Set preferred units from keyword arguments.\n\n    Allows bulk configuration of preferred units using either Unit enum values or string aliases.\n    Invalid attributes or values are logged as warnings but do not raise exceptions.\n\n    Args:\n        **kwargs: Keyword arguments where keys are attribute names and values\n                  are either Unit enum values or (string) UnitAliases.\n\n    Examples:\n        &gt;&gt;&gt; # Set using Unit enums\n        &gt;&gt;&gt; PreferredUnits.set(\n        ...     distance=Unit.Meter,\n        ...     velocity=Unit.MPS,\n        ...     temperature=Unit.Celsius\n        ... )\n\n        &gt;&gt;&gt; # Set using string aliases\n        &gt;&gt;&gt; PreferredUnits.set(\n        ...     distance='meter',\n        ...     velocity='mps',\n        ...     weight='gram'\n        ... )\n\n        &gt;&gt;&gt; # Mixed types\n        &gt;&gt;&gt; PreferredUnits.set(\n        ...     distance=Unit.Yard,\n        ...     velocity='fps',\n        ...     adjustment='mil'\n        ... )\n    \"\"\"\n    for attribute, value in kwargs.items():\n        if hasattr(PreferredUnits, attribute):\n            if isinstance(value, Unit):\n                setattr(PreferredUnits, attribute, value)\n            elif isinstance(value, str):\n                if _unit := Unit._parse_unit(value):\n                    setattr(PreferredUnits, attribute, _unit)\n                else:\n                    logger.warning(f\"{value=} not a member of Unit\")\n            elif isinstance(value, bool):\n                setattr(PreferredUnits, attribute, value)\n            else:\n                logger.warning(f\"type of {value=} have not been converted to a member of Unit\")\n        else:\n            logger.warning(f\"{attribute=} not found in preferred_units\")\n</code></pre>"},{"location":"api/units/preferred_units/#unit-presets","title":"Unit Presets","text":"<p>You can define and load <code>PreferredUnits</code> presets from <code>toml</code> files.  There are three such preset files in <code>/assets</code> that have predefined loader functions that can be invoked as follows:</p> <pre><code>from py_ballisticcalc import loadImperialUnits, loadMetricUnits, loadMixedUnits\n\nloadImperialUnits()\nloadMetricUnits()\nloadMixedUnits()\n</code></pre> <p>(Use just one of these methods \u2013 only the last one called counts.)</p>"},{"location":"api/units/preferred_units/#imperial-units","title":"Imperial Units","text":"<p>From <code>assets/.pybc-imperial.toml</code>:</p> <pre><code>angular = 'Degree'\ndistance = 'Foot'\nvelocity = 'FPS'\npressure = 'InHg'\ntemperature = 'Fahrenheit'\ndiameter = 'Inch'\nlength = 'Inch'\nweight = 'Grain'\nadjustment = 'Mil'\ndrop = 'Inch'\nenergy = 'FootPound'\nogw = 'Pound'\nsight_height = 'Inch'\ntarget_height = 'Inch'\ntwist = 'Inch'\ntime = 'Second'\n</code></pre>"},{"location":"api/units/preferred_units/#metric-units","title":"Metric Units","text":"<p>From <code>assets/.pybc-metrics.toml</code>:</p> <pre><code>angular = 'Degree'\ndistance = 'Meter'\nvelocity = 'MPS'\npressure = 'hPa'\ntemperature = 'Celsius'\ndiameter = 'Centimeter'\nlength = 'Centimeter'\nweight = 'Gram'\nadjustment = 'Mil'\ndrop = 'Centimeter'\nenergy = 'Joule'\nogw = 'Kilogram'\nsight_height = 'Centimeter'\ntarget_height = 'Meter'\ntwist = 'Centimeter'\ntime = 'Second'\n</code></pre>"},{"location":"api/units/preferred_units/#mixed-units","title":"Mixed Units","text":"<p>Mixed sets:</p> <ul> <li>metric units for distance, velocity, target, atmosphere</li> <li>imperial for bullet and gun dimensions.</li> </ul> <p>From <code>assets/.pybc-mixed.toml</code>:</p> <pre><code>angular = 'Degree'\ndistance = 'Meter'\nvelocity = 'MPS'\npressure = 'Bar'\ntemperature = 'Celsius'\ndiameter = 'Inch'\nlength = 'Inch'\nweight = 'Grain'\nadjustment = 'Mil'\ndrop = 'Centimeter'\nenergy = 'FootPound'\nogw = 'Kilogram'\nsight_height = 'Inch'\ntarget_height = 'Meter'\ntwist = 'Inch'\ntime = 'Second'\n</code></pre> <pre><code>UnitPropsDict: Mapping[Unit, UnitProps] = {\n    Unit.Radian: UnitProps(\"radian\", 6, \"rad\"),\n    Unit.Degree: UnitProps(\"degree\", 4, \"\u00b0\"),\n    Unit.MOA: UnitProps(\"MOA\", 2, \"MOA\"),\n    Unit.Mil: UnitProps(\"mil\", 3, \"mil\"),\n    Unit.MRad: UnitProps(\"mrad\", 2, \"mrad\"),\n    Unit.Thousandth: UnitProps(\"thousandth\", 2, \"ths\"),\n    Unit.InchesPer100Yd: UnitProps(\"inch/100yd\", 2, \"in/100yd\"),\n    Unit.CmPer100m: UnitProps(\"cm/100m\", 2, \"cm/100m\"),\n    Unit.OClock: UnitProps(\"hour\", 2, \"h\"),\n    Unit.Inch: UnitProps(\"inch\", 1, \"inch\"),\n    Unit.Foot: UnitProps(\"foot\", 2, \"ft\"),\n    Unit.Yard: UnitProps(\"yard\", 1, \"yd\"),\n    Unit.Mile: UnitProps(\"mile\", 3, \"mi\"),\n    Unit.NauticalMile: UnitProps(\"nautical mile\", 3, \"nm\"),\n    Unit.Millimeter: UnitProps(\"millimeter\", 3, \"mm\"),\n    Unit.Centimeter: UnitProps(\"centimeter\", 3, \"cm\"),\n    Unit.Meter: UnitProps(\"meter\", 1, \"m\"),\n    Unit.Kilometer: UnitProps(\"kilometer\", 3, \"km\"),\n    Unit.Line: UnitProps(\"line\", 3, \"ln\"),\n    Unit.FootPound: UnitProps(\"foot-pound\", 0, \"ft\u00b7lb\"),\n    Unit.Joule: UnitProps(\"joule\", 0, \"J\"),\n    Unit.MmHg: UnitProps(\"mmHg\", 0, \"mmHg\"),\n    Unit.InHg: UnitProps(\"inHg\", 6, \"inHg\"),\n    Unit.Bar: UnitProps(\"bar\", 2, \"bar\"),\n    Unit.hPa: UnitProps(\"hPa\", 4, \"hPa\"),\n    Unit.PSI: UnitProps(\"psi\", 4, \"psi\"),\n    Unit.Fahrenheit: UnitProps(\"fahrenheit\", 1, \"\u00b0F\"),\n    Unit.Celsius: UnitProps(\"celsius\", 1, \"\u00b0C\"),\n    Unit.Kelvin: UnitProps(\"kelvin\", 1, \"\u00b0K\"),\n    Unit.Rankin: UnitProps(\"rankin\", 1, \"\u00b0R\"),\n    Unit.MPS: UnitProps(\"mps\", 0, \"m/s\"),\n    Unit.KMH: UnitProps(\"kmh\", 1, \"km/h\"),\n    Unit.FPS: UnitProps(\"fps\", 1, \"ft/s\"),\n    Unit.MPH: UnitProps(\"mph\", 1, \"mph\"),\n    Unit.KT: UnitProps(\"knot\", 1, \"kt\"),\n    Unit.Grain: UnitProps(\"grain\", 1, \"gr\"),\n    Unit.Ounce: UnitProps(\"ounce\", 1, \"oz\"),\n    Unit.Gram: UnitProps(\"gram\", 1, \"g\"),\n    Unit.Pound: UnitProps(\"pound\", 0, \"lb\"),\n    Unit.Kilogram: UnitProps(\"kilogram\", 3, \"kg\"),\n    Unit.Newton: UnitProps(\"newton\", 3, \"N\"),\n    Unit.Minute: UnitProps(\n        \"minute\",\n        0,\n        \"min\",\n    ),\n    Unit.Second: UnitProps(\"second\", 1, \"s\"),\n    Unit.Millisecond: UnitProps(\n        \"millisecond\",\n        3,\n        \"ms\",\n    ),\n    Unit.Microsecond: UnitProps(\"microsecond\", 6, \"\u00b5s\"),\n    Unit.Nanosecond: UnitProps(\"nanosecond\", 9, \"ns\"),\n    Unit.Picosecond: UnitProps(\"picosecond\", 12, \"ps\"),\n}\n</code></pre>"},{"location":"api/units/preferred_units/#py_ballisticcalc.unit.UnitProps","title":"UnitProps","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Properties and display characteristics for unit measurements.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Human-readable name of the unit (e.g., 'meter', 'foot-pound').</p> <code>accuracy</code> <code>int</code> <p>Number of decimal places for formatting values for display.</p> <code>symbol</code> <code>str</code> <p>Standard symbol or abbreviation for the unit (e.g., 'm', 'ft\u00b7lb').</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = Distance.Yard(600)\n&gt;&gt;&gt; print(d &lt;&lt; Distance.Kilometer)\n0.549km\n&gt;&gt;&gt; UnitPropsDict[Unit.Kilometer] = UnitProps(\"kilometer\", 5, \" kilometers\")\n&gt;&gt;&gt; print(d &lt;&lt; Distance.Kilometer)\n0.54864 kilometers\n</code></pre>"},{"location":"api/units/preferred_units/#py_ballisticcalc.unit.UnitPropsDict","title":"<code>UnitPropsDict</code>  <code>module-attribute</code>","text":""},{"location":"concepts/","title":"Ballistic Concepts","text":""},{"location":"concepts/#coordinates","title":"Coordinates","text":"<p>Gravity gives \\(\\boldsymbol{y}\\): In ballistics, everything is referenced to the direction of gravity. The gravity vector points \"down,\" and this defines the vertical direction. In 3D Cartesian coordinates \\((x, y, z)\\) the gravity vector is \\((0, -g, 0)\\), where \\(g\\) is acceleration due to gravity (typically 32 feet/second\u00b2 or 9.8 meters/second\u00b2). The \\(y\\) coordinate describes vertical (up/down) position.</p> <p>Horizontal: Having defined the vertical axis using the gravity vector, we can then define horizontal as any vector perpendicular (or orthogonal) to the direction of gravity.</p> <p>Sight gives \\(\\boldsymbol{x}\\) axis: The second key reference in ballistics is the sight line. We set the horizontal axis to the sight line, which is typically a ray from the shooter's eye through the center of a sighting device like a scope.</p> <p>Muzzle gives origin: The origin of our 3D coordinate system <code>(0, 0, 0)</code> is the point on the sight line directly above the point that the projectile begins free flight. For a typical gun, free flight begins at the muzzle, which is vertically offset from the sight line by a <code>sight_height</code>, so the launch point is actually <code>(0, -sight_height, 0)</code>.  The following illustration shows this relationship: </p> <p>The \\(\\boldsymbol{x}\\) coordinate measures distance from launch along a horizontal sight line.</p> <p>The \\(\\boldsymbol{z}\\) coordinate describes position orthogonal to both the direction of gravity and the sight line. From the perspective of the sight, this is lateral position, also known as windage.</p>"},{"location":"concepts/#look-angle","title":"Look angle","text":"<p>Look angle, a.k.a. slant angle, is the elevation of the sight line (a.k.a., Line of Sight, or LoS) relative to the horizon. For angles close to horizontal (flat fire) this does not make a significant difference. When the look angle is significantly above or below the horizon the trajectory will be different because:</p> <ol> <li>Gravity is not orthogonal to the velocity.</li> <li>Air density changes with altitude, so the drag effects will vary across an arcing trajectory.</li> </ol> <p>The shooter typically cares about the line of sight (LoS): Sight adjustments are made relative to LoS.  Ranging errors \u2013 and hence danger space \u2013 follow the slant-height, not the horizontal height.</p> <p>The following diagram shows how slant distance and slant height relate by look angle to the underlying (distance \\(x\\), height \\(y\\)) trajectory data.  Understanding Slant Angle covers these concepts in more detail. </p>"},{"location":"concepts/#danger-space","title":"Danger Space","text":"<p>Danger space is a practical measure of sensitivity to ranging error. It is defined for a target of height \\(h\\) and distance \\(d\\), and it indicates how far forward and backward along the line of sight the target can move such that the trajectory will still hit somewhere (vertically) on the target.</p> <p></p>"},{"location":"concepts/#example","title":"Example","text":"<p><pre><code>from py_ballisticcalc import *\n\n# Define a standard .308 Winchester shot: G7 BC=0.22, muzzle velocity 2600fps\nzero = Shot(weapon=Weapon(sight_height=Distance.Inch(2)),\n            ammo=Ammo(DragModel(0.22, TableG7), mv=Velocity.FPS(2600)))\n\n# Set a 300-yard zero\ncalc = Calculator()\nzero_distance = Distance.Yard(300)\nzero_elevation = calc.set_weapon_zero(zero, zero_distance)\n\n# Plot the trajectory to 500 yards\nresult = calc.fire(zero, trajectory_range=Distance.Yard(500),\n                         trajectory_step=Distance.Yard(10), flags=TrajFlag.ALL)\nax = result.plot()\n\n# Compute and display danger space for a 10-inch target at 350 yards\ndanger_space = result.danger_space(Distance.Yard(350), Distance.Inch(10))\ndanger_space.overlay(ax)\nplt.show()\nprint(danger_space)\n</code></pre> <code>Danger space at 350.0yd for 10.0inch tall target ranges from 311.0yd to 381.1yd</code> </p>"},{"location":"concepts/#learn-by-example","title":"Learn by Example","text":"<ul> <li>Examples notebook</li> <li>Extreme Examples</li> </ul>"},{"location":"concepts/#api-pointers","title":"API Pointers","text":"Selected API references <p><code>py_ballisticcalc.interface.Calculator</code> <code>py_ballisticcalc.munition.Ammo</code> <code>py_ballisticcalc.drag_model.DragModel</code> <code>py_ballisticcalc.conditions.Atmo</code> <code>py_ballisticcalc.munition.Weapon</code> <code>py_ballisticcalc.shot.Shot</code> <code>py_ballisticcalc.trajectory_data.TrajectoryData</code> <code>py_ballisticcalc.trajectory_data.HitResult</code> <code>py_ballisticcalc.unit.Unit</code></p>"},{"location":"concepts/benchmarks/","title":"Summary of Ballistic Engine Benchmarks","text":"<p>This document summarizes the findings from the <code>examples/BenchmarkEngines.ipynb</code> notebook, which compares the performance and accuracy of the different calculation engines available in the <code>py-ballisticcalc</code> library.</p>"},{"location":"concepts/benchmarks/#introduction","title":"Introduction","text":"<p>The core of any ballistics calculator is a numerical integration engine (an ODE solver) that computes the trajectory of a projectile under the forces of gravity and air resistance. The choice of engine and its configuration represents a trade-off between precision and compute speed. This benchmark was created to explore these trade-offs and guide the selection of an appropriate engine for different use cases.</p> <p>The engines covered here:</p> <ol> <li>Euler (<code>euler_engine</code>): The most elementary, first-order integration method.  </li> <li>RK4 (<code>rk4_engine</code>): Runge-Kutta fourth-order integration.  </li> <li>Verlet (<code>verlet_engine</code>): Velocity-Verlet, which is a second-order symplectic method.</li> <li>Cython RK4 (<code>cythonized_rk4_engine</code>): Same as the RK4 engine, but implemented in Cython which is a variant of Python that compiles (instead of interpreting) for maximum compute speed.</li> <li>SciPy (<code>scipy_engine</code>): The SciPy library contains the most sophisticated numerical methods with compiled backends.</li> </ol>"},{"location":"concepts/benchmarks/#key-concepts","title":"Key Concepts","text":"<ul> <li>A ballistic trajectory consists of the position and velocity of a projectile as a function of time.</li> <li>All these numerical integrators approximate the trajectory by computing incremental time steps from the launch point of the projectile (at \\(t=0\\)).</li> <li>The smaller the time step, the less error in the approximation.</li> <li>The higher the order of the method the more quickly error is reduced as step size is decreased.</li> </ul>"},{"location":"concepts/benchmarks/#methodology","title":"Methodology","text":"<p>To provide a fair comparison, a standardized testing methodology was established:</p> <ol> <li> <p>Reference Trajectory: A highly accurate \"ground truth\" trajectory is computed using the <code>scipy_engine</code> with the <code>LSODA</code> method, configured with extremely low error tolerances (<code>1e-12</code>). This serves as the baseline against which all other calculations are measured.</p> </li> <li> <p>Test Scenario: The trajectory of a common long-range rifle shot is computed out to 2km for all tests:</p> <ul> <li>Ammunition: A 7.62mm, 10-gram bullet (G7 BC of 0.22).</li> <li>Muzzle Velocity: 800 m/s.</li> <li>Shot Angle: A high elevation (60 mils) to achieve a range of approximately 2 kilometers.</li> <li>Atmosphere: ICAO Standard Atmosphere.</li> </ul> </li> <li> <p>Error Calculation: The error for any given engine is defined as the vertical miss distance (in meters) at the exact horizontal range where the reference trajectory returns to zero elevation (just over 1,861m).</p> </li> <li> <p>Benchmarking: Each engine is run multiple times across a range of configurations (step size, or error tolerance in the case of SciPy). For each run, we measure:</p> <ul> <li>Error (m): As defined above.</li> <li>Integration Steps: The number of steps the solver took to compute the trajectory.</li> <li>Speed (s): The average time taken to compute the trajectory, measured using <code>%timeit</code>.</li> </ul> </li> </ol>"},{"location":"concepts/benchmarks/#summary-results","title":"Summary Results","text":"<ol> <li>Highest Precision: <code>scipy_engine</code>. The adaptive SciPy engine can deliver the most accurate results, and do so with an order of magnitude less compute than the (pure) Python engines.</li> <li>Highest Speed: <code>cythonized_rk4_engine</code>. The compiled RK4 engine is an order of magnitude faster than the SciPy engine.  It can't achieve the same micron-level precision when pushed to its limit, but it easily delivers results with error measured in millimeters at a distance of 2km, which is more than adequate for practical purposes.</li> </ol> <p>This chart shows the range of performance and speed observed for each engine.  Smaller values are better.  For each engine we can see that if we give it more calculation time we get results with smaller error.</p> <p></p>"},{"location":"concepts/benchmarks/#notes","title":"Notes","text":""},{"location":"concepts/benchmarks/#python-engines","title":"Python Engines","text":"<p>These engines are implemented from scratch in pure Python, and make it easy to see and understand exactly how the calculator works.  Their integration step size can be adjusted with the <code>cStepMultiplier</code> configuration parameter.</p> <ul> <li><code>rk4_engine</code>:  The RK4 algorithm is the most frequently used for ballistic calculators, and we continue to recommend it.  This is the default <code>py_ballisticcalc</code> engine.</li> <li><code>euler_engine</code>:  Euler's method is the most simple integration algorithm, which will be recognizable to any calculus student.  However, it is a first-order method with well known limitations and therefore recommended only for study.</li> <li><code>verlet_engine</code>: The velocity Verlet algorithm is a second-order integrator with the distinctive property of being symplectic, which makes it an excellent choice for modelling physical systems that should conserve energy.  It excels in a vacuum scenario (<code>examples/BenchmarkVacuumTraj.ipynb</code>), but otherwise its performance is similar to the simpler Euler method: A ballistic trajectory with air resistance is a dissipative system because energy is lost to drag. The Verlet method's strengths are in non-dissipative, time-reversible systems.</li> </ul>"},{"location":"concepts/benchmarks/#scipy-engine","title":"SciPy Engine","text":"<p>The <code>scipy_engine</code> employs the state-of-the-art numerical methods provided by the SciPy library.</p> <ul> <li>Integration Methods: It supports a variety of methods. Among those recommended for this purpose are <code>LSODA</code>, <code>RK45</code>, <code>DOP853</code>, and <code>BDF</code>. We have found <code>LSODA</code> and <code>RK45</code> to be most effective in our testing, so those are the ones analyzed here.</li> <li>Adaptive Step Size: These solvers use adaptive step sizes, dynamically adjusting their internal timestep to meet the user-specified <code>absolute_tolerance</code> and <code>relative_tolerance</code>.</li> <li>Performance: The SciPy solvers are in a class of their own. They achieve the highest accuracy with the fewest integration steps, demonstrating a superior accuracy-to-speed ratio. As the tolerance is tightened, the error decreases exponentially until it hits the limits of floating-point precision.</li> </ul> <p>SciPy is something of a black box: one cannot be certain exactly how it will proceed given a particular method and error tolerance.  Some illustrations of unexpected behavior can be found in our vacuum scenario study <code>examples/BenchmarkVacuumTraj.ipynb</code>.  However, we confirm that smaller error tolerance limits result in more iterations and smaller errors, as shown in the following chart summarizing tests on this scenario:</p> <p></p>"},{"location":"concepts/drag_model/","title":"\ud83e\ude82 DragModel","text":""},{"location":"concepts/drag_model/#drag-models","title":"Drag Models","text":"API Documentation <p><code>py_ballisticcalc.drag_model</code></p> <p>The drag subsystem models aerodynamic resistance via Ballistic Coefficients that reference standard drag tables (G1, G7, etc.), or custom Mach\u2013\\(C_d\\) pairs.</p> <ul> <li><code>DragModel</code>: Single-BC scaling of a reference drag table; optional weight/diameter/length for spin-drift calculations.</li> <li><code>BCPoint</code> + <code>DragModelMultiBC(...)</code>: Interpolate BC across velocity/Mach to better match measured data.</li> <li>Helpers: <code>make_data_points</code>, <code>sectional_density</code>, <code>linear_interpolation</code>.</li> </ul> <p>Use with <code>Ammo(dm=DragModel(...))</code> to parameterize the projectile.</p>"},{"location":"concepts/drag_model/#standard-models","title":"Standard Models","text":"API Documentation <p><code>py_ballisticcalc.drag_tables</code></p>"},{"location":"concepts/drag_model/#standard-tables","title":"Standard Tables","text":"<ul> <li><code>TableG1</code>: Flat-base bullet (most common sporting ammunition)</li> <li><code>TableG7</code>: Boat-tail, spitzer (long-range match bullets)</li> <li><code>TableG2</code>: Conical, banded, boat-tail artillery projectile</li> <li><code>TableG5</code>: Round-nose, boat-tail</li> <li><code>TableG6</code>: Flat-base, spire-point</li> <li><code>TableG8</code>: Flat-base, 10 caliber secant ogive</li> <li><code>TableGI</code>: Ingalls G1</li> <li><code>TableGS</code>: 9/16\" smooth sphere</li> <li><code>TableRA4</code>: .22LR 40gr</li> </ul>"},{"location":"concepts/drag_model/#standard-projectile-profiles","title":"Standard Projectile Profiles","text":""},{"location":"concepts/drag_model/#standard-drag-curves","title":"Standard Drag Curves","text":""},{"location":"concepts/engines/","title":"Engines","text":""},{"location":"concepts/engines/#summary","title":"Summary","text":"<p>py-ballisticcalc provides various calculation engines with identical public semantics.  The relative merits of the engines are detailed in benchmarks.</p> Engine Name Speed Dependencies Description <code>rk4_engine</code> Baseline (1x) None; default Runge-Kutta 4th-order integration <code>euler_engine</code> 0.5x (slower) None Euler 1st-order integration <code>verlet_engine</code> 0.7x (slower) None Verlet 2nd-order symplectic integration <code>cythonized_rk4_engine</code> 50x (faster) <code>[exts]</code> Compiled Runge-Kutta 4th-order <code>cythonized_euler_engine</code> 40x (faster) <code>[exts]</code> Compiled Euler integration <code>scipy_engine</code> 10x (faster) <code>scipy</code> Advanced numerical methods <ul> <li>This project will default to the <code>rk4_engine</code>.</li> <li>For higher speed and precision use the <code>scipy_engine</code>.</li> <li>For maximum speed use the <code>cythonized_rk4_engine</code>.</li> </ul> <p>To select a specific engine when creating a <code>Calculator</code>, use the optional <code>engine</code> argument:</p> <pre><code>from py_ballisticcalc import Calculator\ncalc = Calculator(engine=\"rk4_engine\")\n# or via entry-point path\ncalc = Calculator(engine=\"my_pkg.my_mod:MyEngine\")\n</code></pre>"},{"location":"concepts/engines/#cython-engines","title":"Cython Engines","text":"<p>Cythonized engines are compiled for maximum performance.  Include the <code>[exts]</code> option to install those:</p> pipuv <pre><code>pip install \"py-ballisticcalc[exts]\"\n</code></pre> <pre><code>uv add py-ballisticcalc[exts]\n</code></pre>"},{"location":"concepts/engines/#custom-engines","title":"Custom Engines","text":"<p>To define a custom engine: Create a separate module with a class that implements the <code>EngineProtocol</code>.  You can then load it like: <pre><code>from py_ballisticcalc import Calculator\n\ncalc = Calculator(engine=\"my_library.my_module:MyAwesomeEngine\")\n</code></pre></p> <p>Entry Point: You can also give the engine a named entry point in <code>pyproject.toml</code>/<code>setup.py</code>.  The entry point name should end with <code>_engine</code>.  Example:</p> <pre><code>[project.entry-points.py_ballisticcalc]\nmy_awesome_engine = \"my_library.my_module:MyAwesomeEngine\"\n</code></pre> <p>Then you can load the engine using the entry point name: <pre><code>from py_ballisticcalc import Calculator\n\ncalc = Calculator(engine=\"my_awesome_engine\")\n</code></pre></p> <p>Test a custom engine</p> <p>To test a specific engine with the project test suite, run <code>pytest</code> with <code>--engine</code> argument.  Examples: <pre><code>pytest ./tests --engine=\"my_awesome_engine\" \n# or\npytest ./tests --engine=\"my_library.my_module:MyAwesomeEngine\" \n</code></pre></p>"},{"location":"concepts/trajectory_data/","title":"Trajectory Data","text":"<p>Data structures and helpers for computed trajectories:</p> <ul> <li><code>TrajFlag</code>: Flags marking events (<code>ZERO_UP</code>, <code>ZERO_DOWN</code>, <code>MACH</code>, <code>RANGE</code>, <code>APEX</code>, etc.).</li> <li><code>BaseTrajData</code>: Minimal record of integration steps that can be used to interpolate for any <code>TrajectoryData</code> point.</li> <li><code>TrajectoryData</code>: Rich unit-aware rows for presentation/analysis.</li> <li><code>HitResult</code>: Container with convenience lookups and plotting/dataframe helpers.</li> <li><code>DangerSpace</code>: Analyze tolerance to ranging error at a given distance and target height.</li> </ul>"},{"location":"concepts/unit/","title":"Units &amp; Dimensions","text":"<p>This project provides easy management of units for the following Dimensions:</p> <ul> <li>Angle: <code>radian</code>, <code>degree</code>, <code>MOA</code>, <code>mil</code>, <code>mrad</code>, <code>thousandth</code>, <code>inch/100yd</code>, <code>cm/100m</code>, <code>o'clock</code></li> <li>Distance: <code>inch</code>, <code>foot</code>, <code>yard</code>, <code>mile</code>, <code>nautical mile</code>, <code>mm</code>, <code>cm</code>, <code>m</code>, <code>km</code>, <code>line</code></li> <li>Energy: <code>foot-pound</code>, <code>joule</code></li> <li>Pressure: <code>mmHg</code>, <code>inHg</code>, <code>bar</code>, <code>hPa</code>, <code>PSI</code></li> <li>Temperature: <code>Fahrenheit</code>, <code>Celsius</code>, <code>Kelvin</code>, <code>Rankine</code></li> <li>Time: <code>second</code>, <code>minute</code>, <code>millisecond</code>, <code>microsecond</code>, <code>nanosecond</code>, <code>picosecond</code></li> <li>Velocity: <code>m/s</code>, <code>km/h</code>, <code>ft/s</code>, <code>mph</code>, <code>knots</code></li> <li>Weight: <code>grain</code>, <code>ounce</code>, <code>gram</code>, <code>pound</code>, <code>kilogram</code>, <code>newton</code></li> </ul> <p>Each Dimension derives from the <code>GenericDimension</code> base class. Each Dimension maintains its values internally in a fixed raw unit (e.g., inches for distance, m/s for velocity) and provides conversion methods to any other supported Unit within that Dimension.</p>"},{"location":"concepts/unit/#features","title":"Features","text":"<ul> <li>Type-safe unit conversion, comparison, and arithmetic operators.</li> <li>String parsing via UnitAliases singleton.</li> <li>String display via UnitPropsDict singleton.</li> <li>Default/Preferred units are configurable via the PreferredUnits singleton.</li> </ul>"},{"location":"concepts/unit/#examples","title":"Examples","text":"<pre><code>from py_ballisticcalc.unit import *\n</code></pre>"},{"location":"concepts/unit/#creation","title":"Creation","text":"<p>The following expressions are equivalent: <pre><code>distance = Unit.Meter(100)\ndistance = Distance.Meter(100)\ndistance = Distance(100, Distance.Meter)\n\nPreferredUnits.distance = Unit.Meter\ndistance = PreferredUnits.distance(100)\n</code></pre></p>"},{"location":"concepts/unit/#parsing","title":"Parsing","text":"<p>You can also create <code>Unit</code> objects from strings, which will try to resolve the units by referring to <code>UnitAliases</code>.  The following expressions all return a <code>Unit.Yard(2)</code> object: <pre><code>Unit.parse('2yd')\nUnit.parse('2 yds')\nUnit.parse('2.0 yards')\nUnit.parse(2, 'yd')\n</code></pre></p>"},{"location":"concepts/unit/#display","title":"Display","text":""},{"location":"concepts/unit/#__str__","title":"<code>__str__</code>","text":"<p>String rendering is determined by the UnitPropsDict singleton, which lists both the precision and symbol to use when printing each <code>Unit</code>.  This example shows the default rendering of kilometers:</p> <pre><code>&gt;&gt;&gt; d = Distance.Yard(600)\n&gt;&gt;&gt; print(d &lt;&lt; Distance.Kilometer)\n0.549km\n</code></pre> <p>The default precision and symbol can be modified like this: <pre><code>&gt;&gt;&gt; UnitPropsDict[Unit.Kilometer] = UnitProps(\"kilometer\", 5, \" kilometers\")\n&gt;&gt;&gt; print(d &lt;&lt; Distance.Kilometer)\n0.54864 kilometers\n</code></pre></p>"},{"location":"concepts/unit/#__repr__","title":"<code>__repr__</code>","text":"<p><code>GenericDimension.repr</code> displays a string showing:</p> <ul> <li>Dimension type \u2013 e.g., \"Distance:\".</li> <li>The string representation of the instance \u2013 e.g., \"100.0yd\".</li> <li>The <code>.raw_value</code> of the object in the dimension's raw units \u2013 e.g., \"(3600.0)\" for Distance, whose raw units are inches.</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; Distance.Yard(10)\n&lt;Distance: 10.0yd (360.0)&gt;\n</code></pre></p>"},{"location":"concepts/unit/#conversion","title":"Conversion","text":"<pre><code>&gt;&gt;&gt; d = Distance.Yard(100)  \n&gt;&gt;&gt; d.convert(Unit.Meter)      # Conversion method -&gt; Distance\n&lt;Distance: 91.4m (3600.0)&gt;\n\n&gt;&gt;&gt; d &lt;&lt; Distance.Feet         # Conversion operator -&gt; Distance\n&lt;Distance: 300.0ft (3600.0)&gt;\n\n&gt;&gt;&gt; d.get_in(Distance.Foot)    # Conversion method -&gt; float\n300.0\n\n&gt;&gt;&gt; d &gt;&gt; Distance.Inch         # Conversion operator -&gt; float\n3600.0\n</code></pre>"},{"location":"concepts/unit/#comparison","title":"Comparison","text":"<p>All comparison operators (<code>&lt; &gt; &lt;= &gt;= == !=</code>) are supported for <code>Unit</code> objects in the same <code>Dimension</code>: <pre><code>&gt;&gt;&gt; Unit.Meter(1) == Unit.parse(100, 'cm')\nTrue\n\n&gt;&gt;&gt; Unit.Meter(100) &gt; Unit.Yard(100)\nTrue\n</code></pre></p>"},{"location":"concepts/unit/#arithmetic","title":"Arithmetic","text":"<p>You can add and subtract numbers and <code>Unit</code> objects in the same <code>Dimension</code>.  Except for <code>Temperature</code> objects, you can multiply and divide a <code>Unit</code> by scalars, and also take a ratio of two <code>Unit</code> objects in the same <code>Dimension</code>.</p> <pre><code>&gt;&gt;&gt; d = Distance.Yard(100)  \n&gt;&gt;&gt; d - 30\n&lt;Distance: 70.0yd (2520.0)&gt;\n\n&gt;&gt;&gt; d + Distance.Feet(2)\n&lt;Distance: 100.7yd (3624.0)&gt;\n\n&gt;&gt;&gt; 3 * d\n&lt;Distance: 300.0yd (10800.0)&gt;\n\n&gt;&gt;&gt; d / 2\n&lt;Distance: 50.0yd (1800.0)&gt;\n\n&gt;&gt;&gt; d / Unit.Foot(3)\n100.0\n</code></pre>"},{"location":"concepts/unit/#preferences","title":"Preferences","text":"<p>Default units are established using <code>PreferredUnits</code>.</p> <p>To show the current defaults:</p> <pre><code>from py_ballisticcalc import PreferredUnits\nprint(str(PreferredUnits))\n</code></pre> <p>To set custom defaults:</p> <ul> <li>Create <code>.pybc.toml</code> or <code>pybc.toml</code> in your project root directory (where venv was placed).</li> <li>Or place this file in user's home directory. (The file in project root has priority.)</li> <li>Or explicitly load a <code>toml</code> file like this:</li> </ul> <pre><code>from py_ballisticcalc import basicConfig\n\nbasicConfig(\"path/to/your_config.toml\")\n</code></pre> <p>There are three preset unit files in <code>/assets</code>:</p> <ul> <li>Imperial: <code>.pybc-imperial.toml</code></li> <li>Metric: <code>.pybc-metrics.toml</code></li> <li>Mixed: <code>.pybc-mixed.toml</code></li> </ul>"},{"location":"concepts/vector/","title":"Vector","text":"API Documentation <p><code>py_ballisticcalc.vector.Vector</code></p> <p>Immutable 3D vector used for positions and velocities in internal engine calculations. Provides magnitude, dot product, normalization, and arithmetic.</p>"},{"location":"concepts/vector/#key-features","title":"Key Features","text":"<ul> <li>Immutable vector implementation for thread safety and performance</li> <li>Comprehensive operator overloading for intuitive mathematical syntax</li> <li>High-precision magnitude calculations using math.hypot()</li> <li>Dot product operations for angle and projection calculations</li> <li>Normalization with numerical stability for near-zero vectors</li> <li>Compatible with both Python and Cython implementations</li> </ul>"},{"location":"concepts/vector/#sample-usage","title":"Sample Usage","text":"<pre><code>```python\nfrom py_ballisticcalc import Vector\n\n# Create position vector\nposition = Vector(100.0, 50.0, 0.0)\n\n# Create velocity vector\nvelocity = Vector(800.0, 0.0, 0.0)  # m/s\n\n# Vector arithmetic\nnew_position = position + velocity * time_step\n\n# Calculate distance\ndistance = position.magnitude()\n\n# Unit vector for direction\ndirection = velocity.normalize()\n\n# Dot product for angle calculations\ncos_angle = velocity.mul_by_vector(wind_vector) / (velocity.magnitude() * wind_vector.magnitude())\n```\n</code></pre>"},{"location":"concepts/conditions/atmo/","title":"Atmosphere (Atmo)","text":"<p>Atmospheric state to compute air density and local speed of sound (Mach 1). Supports ICAO standard atmosphere by altitude and custom pressure/temperature/humidity.</p> API Documentation <p><code>py_ballisticcalc.conditions.Atmo</code></p>"},{"location":"concepts/conditions/shot/","title":"Shot","text":"<p>The <code>Shot</code> class contains all information required to calculate a ballistic trajectory:</p> <ul> <li>Atmosphere and winds.</li> <li>Ammunition characteristics.</li> <li>Gun and Sight characteristics.</li> <li><code>look_angle</code> (a.k.a. slant angle): sight line angle relative to horizontal.</li> <li><code>relative_angle</code> (a.k.a. hold): adjustment added by shooter to the gun's <code>zero_elevation</code>.</li> <li><code>cant_angle</code>: any rotation of the sight away from vertical alignment above the gun's barrel.</li> <li><code>azimuth</code>: Azimuth of the shooting direction in degrees [0, 360). Optional, for Coriolis effects.</li> <li><code>latitude</code>: Latitude of the shooting location in degrees [-90, 90]. Optional, for Coriolis effects.</li> </ul> <p>If user supplies <code>latitude</code> and <code>azimuth</code> then engines will include Coriolis acceleration. If user supplies only <code>latitude</code> then a horizontal Coriolis approximation is applied.</p> API Documentation <p><code>py_ballisticcalc.shot.Shot</code></p>"},{"location":"concepts/conditions/wind/","title":"Wind","text":"<p>Piecewise-constant wind segments parameterized by speed and <code>direction_from</code> (0\u00b0 = from behind shooter; 90\u00b0 = from shooter\u2019s left). Each segment has an <code>until_distance</code> limit and a 3D vector representation used by integrators.</p> API Documentation <p><code>py_ballisticcalc.conditions.Wind</code></p>"},{"location":"concepts/munition/ammo/","title":"\ud83d\udca3 Ammo","text":"API Documentation <p><code>py_ballisticcalc.munition.Ammo</code></p> <p>An Ammo instance describes all details of a projectile and cartridge that can affect a trajectory:</p> <ul> <li>Drag curves, typically via Ballistic Coefficient referenced to a standard drag model.</li> <li>Muzzle velocity, including (optionally) any variations in velocity caused by powder temperature sensitivity.</li> <li>Size and weight, which determine spin drift and stability.</li> </ul>"},{"location":"concepts/munition/ammo/#example","title":"Example","text":"<p>Imports: <pre><code>from py_ballisticcalc import Ammo, Unit, DragModel\n</code></pre></p> <p>Create an Ammo instance: <pre><code>ammo = Ammo(\n    dm=DragModel(\n        bc=0.381,\n        drag_table=TableG7,\n        weight=Unit.Grain(300),\n        length=Unit.Inch(1.7),\n        diameter=Unit.Inch(0.338),\n    ),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True,\n)\n</code></pre> In this example, we use Unit helpers to initialize Ammo fields with specific units. We also can do it using <code>float</code> values, in which case those attributes will be initialized with unit types defined by <code>PreferredUnits</code> class.</p>"},{"location":"concepts/munition/weapon/","title":"\ud83d\udd2b Weapon","text":"API Documentation <p><code>py_ballisticcalc.munition.Weapon</code></p> <p>A <code>Weapon</code> instance is a mutable object that describes all details of a gun that can affect a trajectory.</p>"},{"location":"concepts/munition/weapon/#weapon-properties","title":"Weapon properties","text":"<ul> <li> <p><code>sight_height</code>: Sight height, which is the distance between the line of sight and barrel center at the muzzle, measured perpendicular to the line of sight as shown in the following figure:</p> </li> <li> <p><code>sight</code>: Sight details for converting adjustments into click values.</p> </li> <li> <p><code>twist</code>: Twist rate of barrel rifling, in terms of length to complete 1 rotation.  Positive values indicate right-hand twist, negative values indicate left-hand twist.</p> </li> <li> <p><code>zero_elevation</code>: Angle of barrel centerline relative to line of sight when the sight is set to \"zero.\" </p> </li> </ul>"},{"location":"concepts/munition/weapon/#example","title":"Example","text":"<p>Imports: <pre><code>from py_ballisticcalc import Weapon, Unit, Sight\n</code></pre></p> <p>Then create a Weapon instance: <pre><code>weapon = Weapon(\n    sight_height=Unit.Inch(2.),\n    twist=Unit.Inch(10.),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight(\n        'FFP', 2,\n        h_click_size=Unit.Mil(0.2),\n        v_click_size=Unit.Mil(0.2)\n    )\n)\n</code></pre> In this example, we use calls to Unit to initialize Weapon fields with specific unit types. We also can do it using <code>float</code> values, in which case those attributes will be initialized with unit types defined by <code>PreferredUnits</code> class.</p>"},{"location":"internals/architecture/","title":"Architecture Overview","text":"<p>Goals</p> <ul> <li>Keep a compact, well-tested ballistic calculator.</li> <li>Provide multiple integration engines (pure-Python and Cython-accelerated engines).</li> <li>Expose consistent APIs and event semantics (zero crossings, Mach crossing, apex) across engines.</li> </ul>"},{"location":"internals/architecture/#high-level-layers","title":"High-level layers","text":""},{"location":"internals/architecture/#1-public-api","title":"1. Public API","text":"<ul> <li><code>Calculator</code> is the top-level interface used by most clients.</li> </ul>"},{"location":"internals/architecture/#2-scene-shot-description","title":"2. Scene / shot description","text":"<ul> <li>py_ballisticcalc.shot.Shot captures the shot parameters: <code>ammo</code>, <code>weapon</code>, <code>look_angle</code>, <code>relative_angle</code>, <code>wind</code> and atmosphere.</li> <li>Ammo, Weapon, and Atmo live in <code>py_ballisticcalc.munition.py</code> and <code>py_ballisticcalc.conditions.py</code>.</li> </ul>"},{"location":"internals/architecture/#3-drag-model","title":"3. Drag model","text":"<ul> <li>py_ballisticcalc.drag_model and py_ballisticcalc.drag_tables provide the drag lookup and interpolation used by the integrators.</li> </ul>"},{"location":"internals/architecture/#4-integration-engines","title":"4. Integration engines","text":"<ul> <li>Engines implement EngineProtocol (see <code>py_ballisticcalc.generics.engine</code>).</li> <li>Cython engines are compiled in <code>py_ballisticcalc.exts/py_ballisticcalc_exts</code> for performance.  See <code>rk4_engine.pyx</code> and <code>euler_engine.pyx</code> implementations.</li> </ul>"},{"location":"internals/architecture/#5-trajectory-data-and-events","title":"5. Trajectory data and events","text":"<ul> <li><code>py_ballisticcalc.trajectory_data.py</code> defines <code>TrajFlag</code>, <code>BaseTrajData</code>, <code>TrajectoryData</code>, and <code>HitResult</code>.</li> <li><code>TrajFlag</code> event flags include: <code>ZERO_UP</code>, <code>ZERO_DOWN</code>, <code>MACH</code>, <code>RANGE</code>, <code>APEX</code>, and they are recorded with union semantics when they occur within a small time window.</li> <li>py_ballisticcalc.engines.base_engine.TrajectoryDataFilter:<ul> <li>Converts raw step samples to recorded <code>TrajectoryData</code> rows.</li> <li>Handles sampling by range/time.</li> <li>Detects <code>TrajFlag</code> events and performs interpolation for precise event timestamps/values.</li> <li>Applies unioning of flags within <code>BaseIntegrationEngine.SEPARATE_ROW_TIME_DELTA</code>.</li> </ul> </li> </ul>"},{"location":"internals/architecture/#6-search-helpers","title":"6. Search helpers","text":"<ul> <li>The engine provides root-finding and search helpers implemented on top of the <code>integrate()</code> method:<ul> <li><code>zero_angle</code>, which falls back on the more computationally demanding but reliable <code>find_zero_angle</code>, finds <code>barrel_elevation</code> to hit a sight distance.</li> <li><code>find_max_range</code> finds angle that maximizes slant range.</li> <li><code>find_apex</code> finds the apex, which is where vertical velocity crosses from positive to negative.</li> </ul> </li> <li>To ensure parity between engines, these searches run the same Python-side logic and temporarily relax termination constraints where needed.</li> </ul>"},{"location":"internals/architecture/#integration-details-parity","title":"Integration details &amp; parity","text":"<ul> <li>Cython engines return dense BaseTrajData samples; Python py_ballisticcalc.engines.base_engine.TrajectoryDataFilter is responsible for event interpolation. This design keeps the high-level semantics in one place and reduces duplication.</li> </ul>"},{"location":"internals/cython/","title":"Cython conventions for py-ballisticcalc","text":"<p>This document records the Cython conventions adopted by the project. It explains naming, error handling, Global Interpreter Lock (GIL) usage, and why these choices were made.</p> <p>Goals</p> <ul> <li>Keep hot numerical work free of the Python GIL to maximize throughput.</li> <li>Provide Python-friendly, well-tested public APIs while preserving C-level performance.</li> </ul>"},{"location":"internals/cython/#gil-and-nogil","title":"GIL and <code>nogil</code>","text":"<ul> <li><code>nogil</code> helpers operate on C types only (primitives, C structs, raw pointers).</li> <li>All allocations performed in <code>nogil</code> must use C allocation (malloc/realloc) and return raw pointers; wrappers must free or wrap these pointers and raise proper Python exceptions if needed.</li> <li>Wrappers acquire GIL (are standard Python <code>def</code>) and construct Python objects from C results.</li> </ul>"},{"location":"internals/cython/#naming-conventions","title":"Naming conventions","text":"<ul> <li>Nogil helpers: suffix with <code>_nogil</code> or <code>_c_nogil</code> (we use <code>_interpolate_nogil</code>, <code>_append_nogil</code>).</li> <li>Try-style helpers: prefix with <code>_try_</code> for functions that return a status instead of raising (e.g. <code>_try_grow</code>).</li> <li>C-level internal implementations: prefix with <code>_</code> and end with <code>_c</code> for functions that are \"C-level but may be called with the GIL\" (e.g. <code>_append_c</code>).</li> <li>Public Python-facing methods: plain names (e.g. <code>append</code>, <code>interpolate_at</code>). These are <code>def</code> wrappers that call into <code>cdef</code>/<code>nogil</code> helpers.</li> </ul>"},{"location":"internals/cython/#error-handling-conventions","title":"Error handling conventions","text":"<ul> <li><code>nogil</code> functions must not raise Python exceptions.<ul> <li>Use status codes (<code>int</code> or <code>bint</code>) and/or out-parameters to signal errors.</li> <li>Example convention:<ul> <li>return 1 for success, 0 for failure; or</li> <li>return 0 for success and negative error codes for specific failures.</li> </ul> </li> </ul> </li> <li>Python wrappers map status codes to Python exceptions (MemoryError, IndexError, ValueError, etc.).</li> <li>For allocators: provide <code>_ensure_capacity_try_nogil</code> that attempts realloc and returns success/failure without raising.</li> </ul>"},{"location":"internals/cython/#exception-annotation-on-nogil","title":"Exception annotation on nogil","text":"<ul> <li> <p><code>.pxd</code> declarations for <code>nogil</code> functions or module-level functions should have explicit exception values. Cython warns that cimporters calling them without the GIL will require exception checks. If you intend for these functions to never raise Cython exceptions, you must declare them <code>noexcept</code>.</p> </li> <li> <p>Declaring them <code>noexcept</code> in the <code>.pxd</code> is the clearest way to indicate that a function will not propagate a Python exception.</p> </li> <li> <p>Specify an explicit exception value (e.g., <code>except NULL</code> or <code>except False</code>) where appropriate to avoid implicit exception checks if the function can indicate an error via its return value but does not raise a Python exception.</p> </li> </ul>"},{"location":"internals/cython/#pxd-and-api-exposure","title":".pxd and API exposure","text":"<ul> <li>Declare <code>nogil</code> helpers, <code>cdef</code> functions, and <code>enums</code> in <code>.pxd</code> so they can be <code>cimport</code>ed by other Cython modules and used without Python overhead.</li> <li>Keep public Python wrappers (<code>def</code> methods) unexposed in <code>.pxd</code> by default. This encourages other Cython modules to call the <code>nogil</code> helper or <code>cdef</code> function directly instead of the Python wrapper.</li> </ul>"},{"location":"internals/cython/#examples-patterns-used","title":"Examples (patterns used)","text":"<ul> <li> <p>Interpolation (nogil core): <pre><code>cdef enum InterpKey: KEY_TIME, KEY_MACH, KEY_POS_X, ...\ncdef BaseTraj_t* _interpolate_nogil(self, Py_ssize_t idx, InterpKey key_kind, double key_value) nogil\n\ndef interpolate_at(self, idx, key_attribute, key_value):\n    # map key_attribute -&gt; InterpKey\n    with nogil:\n        outp = self._interpolate_nogil(idx, key_kind, key_value)\n    if outp is NULL:\n        raise IndexError(...)\n    result = BaseTrajDataT(...)\n    free(outp)\n    return result\n</code></pre></p> </li> <li> <p>Append (nogil fast-path + GIL grow): <pre><code>cdef bint _ensure_capacity_try_nogil(self, size_t min_capacity) nogil\ncdef void _append_nogil(self, double time, ...) nogil\n\ndef append(self, time, ...):\n    if not self._ensure_capacity_try_nogil(self._length + 1):\n        # acquire GIL and call a grow function that may raise MemoryError\n        self._ensure_capacity(self._length + 1)\n    with nogil:\n        self._append_nogil(time, ...)\n</code></pre></p> </li> </ul>"},{"location":"internals/cython/#practical-notes","title":"Practical notes","text":"<ul> <li><code>nogil</code> is only legal on functions that return C types or are annotated to not return Python objects.</li> <li><code>with nogil:</code> blocks are used to call <code>nogil</code> helpers but the block cannot contain Python operations.</li> <li>When calling <code>malloc</code> in <code>nogil</code>, check the return value and <code>return NULL</code> on failure; do not raise Python exceptions inside <code>nogil</code>.</li> <li>In <code>nogil</code> code you can\u2019t safely pass Python <code>cdef class</code> instances (they carry Python object headers and refcounts).</li> </ul>"},{"location":"internals/cython/#why-this-approach","title":"Why this approach","text":"<ul> <li>Minimizes GIL contention in tight numeric loops (integration engine and interpolation hot paths).</li> <li>Provides explicit, auditable separation of concerns (numeric work vs Python object handling).</li> <li>Gives tests and Python scripts simple interfaces while guaranteeing C-level callers can use the fastest path.</li> </ul>"},{"location":"internals/cython/#when-to-use-cpdef-vs-cdef-def-wrapper","title":"When to use <code>cpdef</code> vs <code>cdef</code> + <code>def</code> wrapper","text":"<ul> <li> <p>Use <code>cpdef</code> when:</p> <ul> <li>The function is small and its behavior is identical whether called from Python or Cython.</li> <li>You want a convenient, single definition that exposes both a fast C-level entrypoint (for cimports) and a Python-callable function without writing a separate wrapper.</li> <li>The function does not need special GIL management (no <code>nogil</code> core) and does not require bespoke exception mapping or complex Python-object construction.</li> </ul> </li> <li> <p>Prefer <code>cdef</code> + <code>def</code> wrapper when:</p> <ul> <li>The hot-path work must run without the GIL (you need a <code>nogil</code> numeric core) or you need tight control over GIL acquire/release.</li> <li>The function must return Python objects, raise Python exceptions, or perform Python-side housekeeping that should only live in the wrapper.</li> <li>You need different behavior or different APIs for C callers vs Python callers (for example, C callers get raw pointers or status codes while Python callers get high-level objects and exceptions).</li> <li>You want to avoid exposing a C-level symbol to other modules inadvertently; <code>cdef</code> keeps the C API internal unless you explicitly declare it in a <code>.pxd</code>.</li> </ul> </li> <li> <p>Rationale</p> <p><code>cpdef</code> is convenient and can be slightly faster for Python callers than a handwritten wrapper, but it bundles the Python-callable surface with the C implementation. That reduces flexibility and clarity: you get less explicit control of error translation, GIL handling, and resource lifetimes. For numeric hot paths and any code that must be <code>nogil</code>-safe, the <code>cdef</code> + <code>def</code> wrapper pattern is safer and clearer: the <code>cdef</code> core can be <code>nogil</code> and return C-only results/statuses while the <code>def</code> wrapper handles Python conversions and raises exceptions. This separation also helps prevent <code>cimport</code> cycles that can occur when <code>cpdef</code> methods from different modules call each other.</p> </li> <li> <p>Practical decision rule</p> <ul> <li>If the function is purely a utility that both Cython modules and Python code will call and it neither needs <code>nogil</code> nor special exception mapping, <code>cpdef</code> is acceptable.</li> <li>If the function is a hot numeric path, manipulates raw buffers/pointers, or needs careful error/status handling, implement a <code>cdef</code> nogil core and a <code>def</code> wrapper.</li> </ul> </li> </ul>"},{"location":"internals/cython/#c-helpers","title":"C helpers","text":"<p>For any object in the hot path we create a C helper as follows:</p> <ol> <li>Define a C struct in <code>bclib.h</code>, and list helper functions.  Example: <code>typedef struct ... ShotProps_t</code> and <code>void ShotProps_t_free_resources(ShotProps_t*shot_props_ptr)</code></li> <li>Implement any helper functions in <code>bclib.c</code>.  These are typically to allocate and free memory.  Example: <code>ShotProps_t_free_resources()</code>.</li> <li>Copy the <code>struct</code> as a <code>ctypedef</code> to <code>cy_bindings.pxd</code>.  (This could be automated at compile time but is not at present.)</li> <li>Put any conversion logic in <code>cy_bindings.pyx</code>.  E.g., <code>cdef ShotProps_t ShotProps_t_from_pyshot(object shot_props):</code></li> </ol>"},{"location":"internals/cython/#memory-leak-detection-strategy","title":"Memory / leak detection strategy","text":"<p>We intentionally avoid embedding ad\u2011hoc global allocation counters inside the C core. Instead we rely on layered techniques that scale better and keep production code minimal:</p> <ol> <li> <p>Deterministic construction/destruction loops (stress tests)</p> <ul> <li>Repeatedly build and discard objects (e.g. drag curves, Mach lists, trajectory buffers) inside      a pytest <code>@pytest.mark.stress</code> test. If RSS or object counts trend upward unbounded, investigate.</li> <li>Keep the loop count high enough to amplify tiny leaks (hundreds\u2013thousands) but bounded to keep CI fast.</li> </ul> </li> <li> <p>Python heap/object monitoring (snapshots and trend checks)</p> <ul> <li>Use <code>tracemalloc</code> inside a <code>@pytest.mark.stress</code> test to obtain a before/after snapshot across a high\u2011iteration drag evaluation or trajectory generation loop. Rather than asserting on raw absolute bytes (which can be noisy across allocators/platforms), we:<ol> <li>Warm up (one integration) to populate caches/one\u2011time allocations.</li> <li>Start tracing, run N evaluation batches, force a <code>gc.collect()</code> between batches.</li> <li>Compare snapshots; fail only if net retained size exceeds a conservative threshold (kept local to the test as a constant so CI adjustments are simple).</li> </ol> </li> <li> <p>Example idiom (trimmed):</p> <p><pre><code>import tracemalloc, gc\ntracemalloc.start()\nsnap0 = tracemalloc.take_snapshot()\nfor _ in range(BATCHES):\n    run_drag_evals()\n    gc.collect()\nsnap1 = tracemalloc.take_snapshot()\ntotal_diff = sum(stat.size_diff for stat in snap1.compare_to(snap0, 'filename'))\nassert total_diff &lt; LEAK_THRESHOLD_BYTES\n</code></pre>      - We deliberately scope thresholds and batch counts inside the test (no env vars) to keep behavior deterministic and self\u2011documenting.</p> </li> </ul> </li> <li> <p>Platform tools (C allocations / native leaks)</p> <ul> <li>Linux / WSL: <code>valgrind --leak-check=full python -m pytest tests -k stress</code> (slow but definitive)</li> <li>AddressSanitizer (ASan): build extension with <code>CFLAGS=\"-O2 -g -fsanitize=address\"</code> &amp;      <code>LDFLAGS=\"-fsanitize=address\"</code> then run stress tests; reports use\u2011after\u2011free, double free, leaks.</li> <li>macOS: <code>leaks</code> tool or Instruments (Allocations &amp; Leaks templates).</li> <li>Windows: Visual Studio Diagnostics, Dr. Memory, or Application Verifier + Debug CRT (set      <code>_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF)</code> inside a small harness).</li> </ul> </li> <li> <p>Cython boundary audits</p> <ul> <li>Enable Cython annotation (<code>CYTHON_ANNOTATE=1</code>) to inspect Python interaction hot spots.</li> <li>Review that every <code>malloc</code> / <code>realloc</code> / <code>calloc</code> has a matching <code>free</code> in normal and error paths.</li> <li>Ensure early returns after partial allocation free prior blocks.</li> </ul> </li> <li> <p>Monitoring RSS (coarse indicator)</p> <ul> <li>Use <code>psutil.Process().memory_info().rss</code> sampled before/after a stress loop. Accept small (&lt;1\u20132%) drift      due to allocator fragmentation but investigate linear growth.</li> </ul> </li> </ol>"},{"location":"internals/cython/#when-to-escalate","title":"When to escalate","text":"<p>Use lightweight Python tooling first (stress + tracemalloc). Escalate to Valgrind / ASan only when a leak pattern is confirmed or a corruption (crash, inconsistent data) is suspected.</p>"},{"location":"internals/cython/#debugging-tips","title":"Debugging tips","text":"<ul> <li>Reproduce failure with a focused pytest call (pass the test path) to avoid long runs.</li> <li>Add temporary debug prints in Python-side filter rather than in C to avoid recompiles.</li> <li>To iterate on Cython code rapidly: keep <code>pyx</code> edits small and incremental, run <code>py -m pip install -e ./py_ballisticcalc.exts</code> to rebuild the extension in-place.</li> </ul>"},{"location":"internals/cython/#troubleshooting-native-issues","title":"Troubleshooting native issues","text":"<ul> <li>Crash inside C function: rebuild with <code>-O0 -g</code> and run under <code>gdb --args python -m pytest ...</code>.</li> <li>Sporadic NaNs in trajectory: print intermediate Mach, density, drag values for the iteration where the     NaN first appears; confirm inputs within expected ranges; check for division by zero in slope formulas.</li> </ul>"},{"location":"internals/cython/#contribution-checklist","title":"Contribution checklist","text":"<ul> <li>Keep parity: match Python reference implementations for event semantics unless you intentionally change behavior (document that change).</li> <li>Add tests for any public behavioral change.</li> <li>Keep Cython numeric code focused on inner loops and return dense samples for Python post-processing.</li> </ul>"},{"location":"internals/cython/#tests","title":"Tests","text":"<ul> <li><code>pytest ./py_ballisticcalc.exts/tests</code> for cython-specific tests.</li> <li>We use <code>@pytest.mark.stress</code> to keep stress tests separate.  To run those: <code>pytest ./py_ballisticcalc.exts/tests -m stress</code></li> </ul>"},{"location":"internals/details/","title":"Developer Details","text":"<p>This page is for contributors who want to modify algorithms, add engines, or extend the project.</p>"},{"location":"internals/details/#recommended-one-step-dev-setup-cross-platform","title":"Recommended one-step dev setup (cross-platform)","text":"<pre><code># create/sync venv with dev + exts\nuv sync --python 3.13 --dev --extra exts\n\n# install editable local packages into the active venv\nuv pip install -e ./py_ballisticcalc.exts\nuv pip install -e .\n\n# activate &amp; test\nsource .venv/bin/activate   # Linux/macOS\n# .\\.venv\\Scripts\\activate  # Windows\npython -m pytest tests --engine=\"rk4_engine\"\n</code></pre> <p>Notes:</p> <ul> <li>The repo includes a <code>sitecustomize.py</code> that disables user site-packages and warns if you are not using the local <code>.venv</code>, to prevent stale/external packages from shadowing your build.</li> <li>If you prefer pip, using <code>python -m pip install -e ./py_ballisticcalc.exts</code> (then <code>python -m pip install -e .</code>) works fine when the venv is activated.</li> </ul>"},{"location":"internals/details/#ci-and-uvlock","title":"CI and <code>uv.lock</code>","text":"<p>Development dependencies and reproducible developer/CI installs are pinned in <code>uv.lock</code>.</p> <ul> <li>This lockfile is for maintainers and CI reproducibility; it is not used by library consumers who install via pip/pyproject.</li> <li>If you use <code>uv</code> for environment management, run <code>uv sync --dev</code> (optionally with <code>--extra exts</code> to install the Cython subproject) to produce the locked environment used by CI.</li> </ul>"},{"location":"internals/details/#code-locations-responsibilities","title":"Code locations &amp; responsibilities","text":"<ul> <li><code>py_ballisticcalc/</code> \u2014 core Python package.<ul> <li><code>engines/</code> \u2014 Python engine implementations and <code>TrajectoryDataFilter</code>.</li> <li><code>trajectory_data.py</code> \u2014 <code>BaseTrajData</code>, <code>TrajectoryData</code>, <code>HitResult</code>, <code>TrajFlag</code>, interpolation helpers.</li> <li><code>conditions.py</code>, <code>munition.py</code> \u2014 shot and environment objects.</li> <li><code>drag_model.py</code>, <code>drag_tables.py</code> \u2014 drag lookup and interpolation.</li> </ul> </li> <li><code>py_ballisticcalc.exts/</code> \u2014 Cython subproject.<ul> <li><code>py_ballisticcalc_exts/base_engine.pyx</code> \u2014 Cython wrapper that orchestrates C-layer stepping and defers event logic to Python.</li> <li><code>py_ballisticcalc_exts/</code> <code>rk4_engine.pyx</code>, <code>euler_engine.pyx</code> \u2014 Cython engine implementations.</li> <li><code>py_ballisticcalc_exts/cy_bindings.pyx/.pxd</code> \u2014 helper functions and bridging helpers for C structs.</li> </ul> </li> </ul>"},{"location":"internals/details/#how-engines-are-wired","title":"How engines are wired","text":"<p>Public call flow (simplified):</p> <ol> <li><code>Calculator.fire()</code> calls <code>engine.integrate()</code>.</li> <li><code>BaseIntegrationEngine.integrate()</code> converts units, calls engine <code>_integrate()</code>, which feeds <code>TrajectoryDataFilter</code>.</li> <li><code>_integrate()</code> returns a <code>HitResult</code> consisting of <code>TrajectoryData</code> rows and post-processing functions.</li> </ol>"},{"location":"internals/details/#testing-parity","title":"Testing &amp; parity","text":"<ul> <li>The project runs many parity tests that assert identical results between Python and Cython engines. When adding features, run the whole test suite using the <code>--engine=\"engine_name\"</code> argument.</li> <li>Focus tests on:<ul> <li>Event parity (ZERO_UP/ZERO_DOWN/MACH/APEX) and interpolation accuracy.</li> <li>Search functions (<code>find_zero_angle</code>, <code>find_max_range</code>, <code>find_apex</code>).</li> <li>Dense output correctness (HitResult.base_data) and shape.</li> </ul> </li> </ul>"},{"location":"internals/details/#benchmarking","title":"Benchmarking","text":"<p><code>scripts/benchmark.py</code> checks execution speed on two standardized scenarios named <code>Trajectory</code> and <code>Zero</code>.</p> <p>Note</p> <p>If you are contemplating work that could affect performance you should run <code>benchmark.py</code> before modifying any code to set a baseline, and then re-run the benchmark afterwards to confirm whether the changes have affected performance.</p> <pre><code># Run benchmarks on all engines:\nuv run python scripts/benchmark.py --all\n\n# Run benchmarks on specific engine:\nuv run python scripts/benchmark.py --engine=\"rk4_engine\"\n</code></pre>"},{"location":"internals/details/#understanding-benchmark-results","title":"Understanding benchmark results","text":"<p>The benchmark numbers are only meaningful for comparing different versions of the project run on the same computer (and under the same operating conditions \u2014 i.e., same processor and memory availability).</p> <p>Each benchmark run will be logged to <code>./benchmarks/benchmarks.csv</code>, which will contain a row for each engine and scenario, with the following columns:</p> <ul> <li><code>timestamp</code> \u2014 of the run.</li> <li><code>version</code> \u2014 of the project (as listed in <code>pyproject.toml</code>).</li> <li><code>branch</code> \u2014 name reported by <code>git</code> (if any).</li> <li><code>git_hash</code> \u2014 version (short) reported by <code>git</code>.</li> <li><code>case</code> \u2014 which scenario was run (<code>Trajectory</code> or <code>Zero</code>).</li> <li><code>engine</code> \u2014 which engine was run.</li> <li><code>repeats</code> \u2014 how many iterations of the case were run to determine runtime statistics.</li> <li><code>mean_ms</code> \u2014 average runtime (in milliseconds) for the case.</li> <li><code>stdev_ms</code> \u2014 standard deviation of runtimes observed.</li> <li><code>min_ms</code> \u2014 fastest runtime observed.</li> <li><code>max_ms</code> \u2014 slowest runtime observed.</li> </ul> <p>The key statistic to look at is <code>mean_ms</code>.  The other three statistics are useful for validating that figure and detecting benchmarking problems.  Ideally:</p> <ul> <li><code>stdev_ms</code> should be very small relative to <code>mean_ms</code>.  If it is not then you should check for other processes that could be consuming compute while running the benchmarks and try to disable those.  Alternatively, you can increase the number of iterations used for benchmark by setting a larger <code>--repeats</code> argument.  (More samples should reduce the variance from the mean.)</li> <li><code>min_ms</code> and <code>max_ms</code> should be similar to <code>mean_ms</code>.  If <code>max_ms</code> is much larger than <code>mean_ms</code> then you may have other processes competing for compute during the benchmark run.  Or you may need a longer warmup, which you can set with the <code>--warmup</code> argument.</li> </ul>"},{"location":"internals/details/#cython-notes-common-pitfalls","title":"Cython notes &amp; common pitfalls","text":"<ul> <li>Cython is used only for performance-critical numeric loops. Keep higher-level semantics in Python to avoid code duplication and subtle parity issues.</li> <li>Common Cython pitfalls observed in this codebase:<ul> <li>Indentation and cdef scoping errors \u2014 ensure <code>cdef</code> declarations live at the top of a C function or appropriate scope.</li> <li>Avoid using Python booleans when declaring typed C variables (use <code>bint</code> and 0/1 assignment in the C context).</li> <li>Keep initialisation of C structs and memory allocation clear; release resources in <code>_free_trajectory</code>.</li> </ul> </li> </ul>"},{"location":"internals/details/#build-test-commands","title":"Build / test commands","text":"<pre><code># optional: install editable C extensions and main package\npy -m pip install -e ./py_ballisticcalc.exts\npy -m pip install -e .\n\n# run a single test file\npy -m pytest tests/test_exts_basic.py\n\n# run full tests\npy -m pytest\n</code></pre>"},{"location":"internals/details/#where-to-ask-questions","title":"Where to ask questions","text":"<p>Open an issue on the repository with a minimal reproduction and a note about the engine(s) involved.</p>"},{"location":"internals/logger/","title":"Logger","text":""},{"location":"internals/logger/#py_ballisticcalc.logger","title":"logger","text":"<p>Logging configuration and utilities for py_ballisticcalc library.</p> <p>This module provides a centralized logging system for the py_ballisticcalc library, including both console and optional file logging capabilities. The logger is configured with appropriate formatters and can be dynamically adjusted for different logging needs.</p> <p>The module exposes a pre-configured logger instance and utility functions for managing file-based logging. By default, only console logging is enabled with INFO level, but file logging can be enabled as needed for debugging or detailed analysis.</p> Global Variables <ul> <li>logger: Pre-configured logger instance for the library.</li> <li>file_handler: Global file handler reference (None when file logging disabled).</li> </ul> <p>Functions:</p> Name Description <code>enable_file_logging</code> <p>Enable logging to a file with DEBUG level.</p> <code>disable_file_logging</code> <p>Disable file logging and clean up resources.</p> <p>Examples:</p> <p>Basic logging usage: <pre><code>from py_ballisticcalc.logger import logger\n\nlogger.info(\"Ballistic calculation started\")\nlogger.warning(\"Trajectory calculation ended before requested distance\")\nlogger.error(\"Unable to find angle to hit target\")\n</code></pre></p> <p>Enable file logging for debugging: <pre><code>from py_ballisticcalc.logger import enable_file_logging, disable_file_logging\n\n# Enable detailed logging to file\nenable_file_logging(\"ballistics_debug.log\")\n\n# Perform calculations with detailed logging\n# ... ballistic calculations ...\n\n# Clean up file logging\ndisable_file_logging()\n</code></pre></p> Note <p>The logger name 'py_balcalc' is used for historical compatibility. All log messages from the library components will be routed through this logger.</p> <p>Attributes:</p> Name Type Description <code>__all__</code> <code>formatter</code> <code>console_handler</code> <code>logger</code> <code>Logger</code> <code>file_handler</code> <code>Optional[FileHandler]</code>"},{"location":"internals/logger/#py_ballisticcalc.logger-attributes","title":"Attributes","text":""},{"location":"internals/logger/#py_ballisticcalc.logger.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = (\n    \"logger\",\n    \"enable_file_logging\",\n    \"disable_file_logging\",\n)\n</code></pre>"},{"location":"internals/logger/#py_ballisticcalc.logger.formatter","title":"formatter  <code>module-attribute</code>","text":"<pre><code>formatter = Formatter('%(levelname)s:%(name)s:%(message)s')\n</code></pre>"},{"location":"internals/logger/#py_ballisticcalc.logger.console_handler","title":"console_handler  <code>module-attribute</code>","text":"<pre><code>console_handler = StreamHandler()\n</code></pre>"},{"location":"internals/logger/#py_ballisticcalc.logger.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger: Logger = getLogger('py_balcalc')\n</code></pre>"},{"location":"internals/logger/#py_ballisticcalc.logger.file_handler","title":"file_handler  <code>module-attribute</code>","text":"<pre><code>file_handler: Optional[FileHandler] = None\n</code></pre>"},{"location":"internals/logger/#py_ballisticcalc.logger-functions","title":"Functions","text":""},{"location":"internals/logger/#py_ballisticcalc.logger.enable_file_logging","title":"enable_file_logging","text":"<pre><code>enable_file_logging(filename: str = 'debug.log') -&gt; None\n</code></pre> <p>Enable logging to a file with DEBUG level output.</p> <p>This function configures file-based logging, replacing any existing file handler. File logging captures all DEBUG level messages and above with timestamp information, providing detailed logging for debugging and analysis purposes.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the log file to create. Defaults to \"debug.log\".      The file will be created in the current working directory      unless an absolute path is provided.</p> <code>'debug.log'</code> Note <p>If file logging is already enabled, the existing file handler will be removed and replaced with a new one using the specified filename. The file will be opened in append mode, so existing content is preserved.</p> <p>Examples:</p> <pre><code>from py_ballisticcalc.logger import enable_file_logging, logger\n\n# Enable detailed file logging\nenable_file_logging(\"trajectory_analysis.log\")\n\n# All subsequent log messages will be written to file\nlogger.debug(\"Detailed calculation step information\")\nlogger.info(\"Calculation completed successfully\")\n</code></pre> Source code in <code>py_ballisticcalc/logger.py</code> <pre><code>def enable_file_logging(filename: str = \"debug.log\") -&gt; None:\n    \"\"\"Enable logging to a file with DEBUG level output.\n\n    This function configures file-based logging, replacing any existing file handler.\n    File logging captures all DEBUG level messages and above with timestamp information,\n    providing detailed logging for debugging and analysis purposes.\n\n    Args:\n        filename: Name of the log file to create. Defaults to \"debug.log\".\n                 The file will be created in the current working directory\n                 unless an absolute path is provided.\n\n    Note:\n        If file logging is already enabled, the existing file handler will be\n        removed and replaced with a new one using the specified filename.\n        The file will be opened in append mode, so existing content is preserved.\n\n    Examples:\n        ```python\n        from py_ballisticcalc.logger import enable_file_logging, logger\n\n        # Enable detailed file logging\n        enable_file_logging(\"trajectory_analysis.log\")\n\n        # All subsequent log messages will be written to file\n        logger.debug(\"Detailed calculation step information\")\n        logger.info(\"Calculation completed successfully\")\n        ```\n    \"\"\"\n    global file_handler\n    # Remove the existing file handler if it exists\n    if file_handler is not None:\n        disable_file_logging()\n\n    # Add a new file handler\n    file_handler = logging.FileHandler(filename)\n    file_handler.setLevel(logging.DEBUG)  # Log everything to the file\n    file_formatter = logging.Formatter(\"%(asctime)s:%(levelname)s:%(message)s\")\n    file_handler.setFormatter(file_formatter)\n    logger.addHandler(file_handler)\n</code></pre>"},{"location":"internals/logger/#py_ballisticcalc.logger.disable_file_logging","title":"disable_file_logging","text":"<pre><code>disable_file_logging() -&gt; None\n</code></pre> <p>Disable file logging and clean up resources.</p> <p>This function removes the file handler from the logger and properly closes the file handle, ensuring no resource leaks. After calling this function, only console logging will remain active.</p> Note <p>If no file logging is currently enabled, this function has no effect. It's safe to call this function multiple times or when file logging is already disabled.</p> <p>Examples:</p> <pre><code>from py_ballisticcalc.logger import disable_file_logging\n\n# Clean up file logging when done with detailed analysis\ndisable_file_logging()\n\n# Only console logging remains active\n</code></pre> Source code in <code>py_ballisticcalc/logger.py</code> <pre><code>def disable_file_logging() -&gt; None:\n    \"\"\"Disable file logging and clean up resources.\n\n    This function removes the file handler from the logger and properly closes the file handle,\n    ensuring no resource leaks. After calling this function, only console logging will remain active.\n\n    Note:\n        If no file logging is currently enabled, this function has no effect.\n        It's safe to call this function multiple times or when file logging is already disabled.\n\n    Examples:\n        ```python\n        from py_ballisticcalc.logger import disable_file_logging\n\n        # Clean up file logging when done with detailed analysis\n        disable_file_logging()\n\n        # Only console logging remains active\n        ```\n    \"\"\"\n    global file_handler\n    if file_handler is not None:\n        logger.removeHandler(file_handler)\n        file_handler.close()\n        file_handler = None\n</code></pre>"}]}