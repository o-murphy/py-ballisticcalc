"""GENERATED BY GEMINI AI"""

import math

import numpy as np
from typing_extensions import Union, List

from py_ballisticcalc.conditions import Shot
from py_ballisticcalc.exceptions import ZeroFindingError, RangeError
from py_ballisticcalc.logger import logger
from py_ballisticcalc.trajectory_calc import *
from py_ballisticcalc.trajectory_calc import _TrajectoryDataFilter, _WindSock
from py_ballisticcalc.trajectory_data import TrajectoryData, TrajFlag
from py_ballisticcalc.unit import Distance, Angular
from py_ballisticcalc.vector import Vector


# pylint: disable=too-many-instance-attributes
class TrajectoryCalcRK4(TrajectoryCalc):

    def zero_angle(self, shot_info: Shot, distance: Distance) -> Angular:
        """
        Iterative algorithm to find barrel elevation needed for a particular zero

        Args:
            shot_info (Shot): Shot parameters
            distance (Distance): Zero distance

        Returns:
            Angular: Barrel elevation to hit height zero at zero distance
        """
        self._init_trajectory(shot_info)

        _cZeroFindingAccuracy = self._config.cZeroFindingAccuracy
        _cMaxIterations = self._config.cMaxIterations

        distance_feet = distance >> Distance.Foot  # no need convert it twice
        zero_distance = math.cos(self.look_angle) * distance_feet
        height_at_zero = math.sin(self.look_angle) * distance_feet

        iterations_count = 0
        zero_finding_error = _cZeroFindingAccuracy * 2
        # x = horizontal distance down range, y = drop, z = windage
        while zero_finding_error > _cZeroFindingAccuracy and iterations_count < _cMaxIterations:
            # Check height of trajectory at the zero distance (using current self.barrel_elevation)
            try:
                t = self._integrate(shot_info, zero_distance, zero_distance, TrajFlag.NONE)[0]
                height = t.height >> Distance.Foot
            except RangeError as e:
                if e.last_distance is None:
                    raise e
                last_distance_foot = e.last_distance >> Distance.Foot
                proportion = (last_distance_foot) / zero_distance
                height = (e.incomplete_trajectory[-1].height >> Distance.Foot) / proportion

            zero_finding_error = math.fabs(height - height_at_zero)

            if zero_finding_error > _cZeroFindingAccuracy:
                # Adjust barrel elevation to close height at zero distance
                self.barrel_elevation -= (height - height_at_zero) / zero_distance
            else:  # last barrel_elevation hit zero!
                break
            iterations_count += 1
        if zero_finding_error > _cZeroFindingAccuracy:
            # ZeroFindingError contains an instance of last barrel elevation; so caller can check how close zero is
            raise ZeroFindingError(zero_finding_error, iterations_count, Angular.Radian(self.barrel_elevation))
        return Angular.Radian(self.barrel_elevation)

    def _acceleration(self, velocity_vector: np.ndarray, density_ratio: float, mach: float,
                      wind_vector: np.ndarray) -> np.ndarray:
        velocity_adjusted = velocity_vector - wind_vector
        velocity_mag = np.linalg.norm(velocity_adjusted)
        drag_force = density_ratio * velocity_mag * self.drag_by_mach(velocity_mag / mach)
        gravity_np = self.gravity_vector.to_numpy()
        return (velocity_adjusted * (
            -drag_force) + gravity_np) / self.weight  # a = F/m (implicitly using weight as mass proxy)

    def _integrate_rk4(self, shot_info: Shot, maximum_range: float, record_step: float,
                       filter_flags: Union[TrajFlag, int], time_step: float = 0.0) -> List["TrajectoryData"]:
        """
        Calculate trajectory for specified shot using RK4 integration.
        """

        _cMinimumVelocity = self._config.cMinimumVelocity
        _cMaximumDrop = self._config.cMaximumDrop
        _cMinimumAltitude = self._config.cMinimumAltitude

        ranges: List[TrajectoryData] = []
        dt = self.calc_step / max(1.0, self.muzzle_velocity)  # Initial guess for time step
        time = 0.0
        range_vector = np.array([0.0, -self.cant_cosine * self.sight_height, -self.cant_sine * self.sight_height],
                                dtype=np.float64)
        velocity_vector = np.array([
            self.muzzle_velocity * math.cos(self.barrel_elevation) * math.cos(self.barrel_azimuth),
            self.muzzle_velocity * math.sin(self.barrel_elevation),
            self.muzzle_velocity * math.cos(self.barrel_elevation) * math.sin(self.barrel_azimuth)
        ], dtype=np.float64)

        wind_sock = _WindSock(shot_info.winds)
        wind_vector_np = wind_sock.current_vector().to_numpy()

        data_filter = _TrajectoryDataFilter(filter_flags=filter_flags, range_step=record_step,
                                            initial_position=Vector(*range_vector),
                                            initial_velocity=Vector(*velocity_vector),
                                            time_step=time_step)
        data_filter.setup_seen_zero(range_vector[1], self.barrel_elevation, self.look_angle)

        while range_vector[0] <= maximum_range + min(self.calc_step, record_step):

            current_range = range_vector[0]
            if current_range >= wind_sock.next_range:
                wind_vector_np = wind_sock.vector_for_range(current_range).to_numpy()

            altitude = self.alt0 + range_vector[1]
            density_ratio, mach = shot_info.atmo.get_density_and_mach_for_altitude(altitude)

            # RK4 steps
            k1_v = self._acceleration(velocity_vector, density_ratio, mach, wind_vector_np)
            k1_r = velocity_vector

            k2_v = self._acceleration(velocity_vector + 0.5 * dt * k1_v, density_ratio, mach, wind_vector_np)
            k2_r = velocity_vector + 0.5 * dt * k1_r

            k3_v = self._acceleration(velocity_vector + 0.5 * dt * k2_v, density_ratio, mach, wind_vector_np)
            k3_r = velocity_vector + 0.5 * dt * k2_r

            k4_v = self._acceleration(velocity_vector + dt * k3_v, density_ratio, mach, wind_vector_np)
            k4_r = velocity_vector + dt * k3_r

            velocity_vector += (dt / 6.0) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v)
            range_vector += (dt / 6.0) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r)
            time += dt

            velocity_mag = np.linalg.norm(velocity_vector)

            if filter_flags:
                if (data := data_filter.should_record(Vector(*range_vector), Vector(*velocity_vector), mach,
                                                      time)) is not None:
                    ranges.append(create_trajectory_row(data.time, data.position, data.velocity,
                                                        velocity_mag, data.mach,
                                                        self.spin_drift(data.time), self.look_angle,
                                                        density_ratio, 0.0, self.weight,
                                                        data_filter.current_flag))  # Drag is part of acceleration

            if (velocity_mag < _cMinimumVelocity or range_vector[1] < _cMaximumDrop or
                    self.alt0 + range_vector[1] < _cMinimumAltitude):
                ranges.append(create_trajectory_row(
                    time, Vector(*range_vector), Vector(*velocity_vector),
                    velocity_mag, mach, self.spin_drift(time), self.look_angle,
                    density_ratio, 0.0, self.weight, data_filter.current_flag
                ))
                reason = RangeError.MinimumVelocityReached if velocity_mag < _cMinimumVelocity else \
                    RangeError.MaximumDropReached if range_vector[1] < _cMaximumDrop else \
                        RangeError.MinimumAltitudeReached
                raise RangeError(reason, ranges)

            dt = self.calc_step / max(1.0, velocity_mag)  # Adjust time step based on velocity

        if len(ranges) < 2:
            ranges.append(create_trajectory_row(
                time, Vector(*range_vector), Vector(*velocity_vector),
                velocity_mag, mach, self.spin_drift(time), self.look_angle,
                density_ratio, 0.0, self.weight, TrajFlag.NONE))

        logger.debug(f"euler rk4 it (time-based)")
        return ranges

    def _integrate(self, shot_info: Shot, maximum_range: float, record_step: float,
                   filter_flags: Union[TrajFlag, int], time_step: float = 0.0) -> List["TrajectoryData"]:
        # Choose the RK4 implementation
        return self._integrate_rk4(shot_info, maximum_range, record_step, filter_flags, time_step)


__all__ = (
    'TrajectoryCalcRK4',
)
