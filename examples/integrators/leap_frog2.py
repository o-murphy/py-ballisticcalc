"""GENERATED BY GEMINI AI"""

import math
from typing import List, Union
import logging

from py_ballisticcalc.trajectory_data import TrajFlag, TrajectoryData
from py_ballisticcalc.exceptions import RangeError
from py_ballisticcalc.vector import Vector
from py_ballisticcalc.trajectory_calc import _WindSock, _TrajectoryDataFilter, Config
from py_ballisticcalc.conditions import Shot

logger = logging.getLogger(__name__)

def leapfrog_pure_python_integrator(engine_instance, shot_info: Shot, maximum_range: float, record_step: float,
                                    filter_flags: Union[TrajFlag, int], time_step: float = 0.0) -> List["TrajectoryData"]:
    """
    Pure Python Leapfrog integration function.
    """
    _cMinimumVelocity = engine_instance._config.cMinimumVelocity
    _cMaximumDrop = engine_instance._config.cMaximumDrop
    _cMinimumAltitude = engine_instance._config.cMinimumAltitude

    ranges: List[TrajectoryData] = []
    time: float = .0
    drag: float = .0
    mach: float = .0
    density_factor: float = .0
    wind_sock = _WindSock(shot_info.winds)
    wind_vector = wind_sock.current_vector()
    velocity = engine_instance.muzzle_velocity
    range_vector = Vector(.0, -engine_instance.cant_cosine * engine_instance.sight_height, -engine_instance.cant_sine * engine_instance.sight_height)
    velocity_vector: Vector = Vector(
        math.cos(engine_instance.barrel_elevation) * math.cos(engine_instance.barrel_azimuth),
        math.sin(engine_instance.barrel_elevation),
        math.cos(engine_instance.barrel_elevation) * math.sin(engine_instance.barrel_azimuth)
    ).mul_by_const(velocity)
    min_step = min(engine_instance.calc_step, record_step)
    data_filter = _TrajectoryDataFilter(filter_flags=filter_flags, range_step=record_step,
                                        initial_position=range_vector, initial_velocity=velocity_vector,
                                        time_step=time_step)
    data_filter.setup_seen_zero(range_vector.y, engine_instance.barrel_elevation, engine_instance.look_angle)

    it = 0
    while range_vector.x <= maximum_range + min_step:
        it += 1
        data_filter.clear_current_flag()
        if range_vector.x >= wind_sock.next_range:
            wind_vector = wind_sock.vector_for_range(range_vector.x)
        density_factor, mach = shot_info.atmo.get_density_factor_and_mach_for_altitude(
            engine_instance.alt0 + range_vector.y)
        if filter_flags:
            if (data := data_filter.should_record(range_vector, velocity_vector, mach, time)) is not None:
                ranges.append(engine_instance.create_trajectory_row(data.time, data.position, data.velocity,
                                                    data.velocity.magnitude(), data.mach,
                                                    engine_instance.spin_drift(data.time), engine_instance.look_angle,
                                                    density_factor, drag, engine_instance.weight, data_filter.current_flag
                                                    ))
        velocity_adjusted = velocity_vector - wind_vector
        velocity_mag = velocity_adjusted.magnitude()
        delta_time = engine_instance.calc_step / max(1.0, velocity_mag)
        drag = density_factor * velocity_mag * engine_instance.drag_by_mach(velocity_mag / mach)
        velocity_vector -= (velocity_adjusted * drag - engine_instance.gravity_vector) * delta_time
        delta_range_vector = velocity_vector * delta_time
        range_vector += delta_range_vector
        time += delta_time

        if (
                velocity_mag < _cMinimumVelocity
                or range_vector.y < _cMaximumDrop
                or engine_instance.alt0 + range_vector.y < _cMinimumAltitude
        ):
            ranges.append(engine_instance.create_trajectory_row(
                time, range_vector, velocity_vector,
                velocity_mag, mach, engine_instance.spin_drift(time), engine_instance.look_angle,
                density_factor, drag, engine_instance.weight, data_filter.current_flag
            ))
            reason = RangeError.MinimumVelocityReached if velocity_mag < _cMinimumVelocity else \
                     RangeError.MaximumDropReached if range_vector.y < _cMaximumDrop else \
                     RangeError.MinimumAltitudeReached
            raise RangeError(reason, ranges)

    if len(ranges) < 2:
        ranges.append(engine_instance.create_trajectory_row(
            time, range_vector, velocity_vector,
            velocity_mag, mach, engine_instance.spin_drift(time), engine_instance.look_angle,
            density_factor, drag, engine_instance.weight, TrajFlag.NONE))
    logger.debug(f"pure python euler it {it}")
    return ranges

class PurePythonLeapfrogEngine:
    def __init__(self, config: Config, muzzle_velocity: float, sight_height: float,
                 cant_angle: float, barrel_elevation: float, barrel_azimuth: float,
                 look_angle: float, alt0: float, calc_step: float, weight: float):
        self._config = config
        self.muzzle_velocity = muzzle_velocity
        self.sight_height = sight_height
        self.cant_angle = cant_angle
        self.barrel_elevation = barrel_elevation
        self.barrel_azimuth = barrel_azimuth
        self.look_angle = look_angle
        self.alt0 = alt0
        self.calc_step = calc_step
        self.weight = weight
        self.gravity_vector = Vector(0.0, -32.174, 0.0)
        self.cant_cosine = math.cos(cant_angle)
        self.cant_sine = math.sin(cant_angle)

    def drag_by_mach(self, mach: float) -> float:
        return 0.5  # Replace with your drag model

    def spin_drift(self, time: float) -> float:
        return 0.0  # Replace with your spin drift model

    def create_trajectory_row(self, *args, **kwargs):
        # Assume this method is available in your BallisticEngine or a utility module
        from py_ballisticcalc.trajectory_calc import create_trajectory_row  # Import locally to avoid circular dependency
        return create_trajectory_row(*args, **kwargs)

    def _acceleration(self, velocity_vector: Vector, density_factor: float, mach: float, wind_vector: Vector) -> Vector:
        velocity_adjusted = velocity_vector - wind_vector
        velocity_mag = velocity_adjusted.magnitude()
        current_mach = velocity_mag / mach if mach != 0 else 1.0
        drag_coeff = self.drag_by_mach(current_mach)
        drag_force_magnitude = density_factor * velocity_mag * drag_coeff
        if velocity_mag > 1e-10:
            drag_force_vector = velocity_adjusted * (-drag_force_magnitude / velocity_mag)
        else:
            drag_force_vector = Vector(0.0, 0.0, 0.0)
        gravity_vector_py = self.gravity_vector
        net_force = drag_force_vector + gravity_vector_py
        return net_force * (1.0 / self.weight)

    def integrate(self, shot_info: Shot, maximum_range: float, record_step: float,
                  filter_flags: Union[TrajFlag, int], time_step: float = 0.0) -> List["TrajectoryData"]:
        _cMinimumVelocity = self._config.cMinimumVelocity
        _cMaximumDrop = self._config.cMaximumDrop
        _cMinimumAltitude = self._config.cMinimumAltitude

        ranges: List["TrajectoryData"] = []
        time = 0.0
        range_vector = Vector(.0, -self.cant_cosine * self.sight_height, -self.cant_sine * self.sight_height)
        velocity_vector = Vector(
            self.muzzle_velocity * math.cos(self.barrel_elevation) * math.cos(self.barrel_azimuth),
            self.muzzle_velocity * math.sin(self.barrel_elevation),
            self.muzzle_velocity * math.cos(self.barrel_elevation) * math.sin(self.barrel_azimuth)
        )
        dt = self.calc_step / max(1.0, velocity_vector.magnitude())
        wind_sock = _WindSock(shot_info.winds)
        wind_vector = wind_sock.current_vector()
        data_filter = _TrajectoryDataFilter(filter_flags=filter_flags, range_step=record_step,
                                            initial_position=range_vector, initial_velocity=velocity_vector,
                                            time_step=time_step)
        data_filter.setup_seen_zero(range_vector.y, self.barrel_elevation, self.look_angle)

        altitude_initial = self.alt0 + range_vector.y
        density_factor_initial, mach_initial = shot_info.atmo.get_density_factor_and_mach_for_altitude(altitude_initial)
        accel_t = self._acceleration(velocity_vector, density_factor_initial, mach_initial, wind_vector)
        velocity_vector_half = velocity_vector + accel_t * (0.5 * dt)

        it = 0
        while range_vector.x <= maximum_range + min(self.calc_step, record_step):
            it += 1
            data_filter.clear_current_flag()
            if range_vector.x >= wind_sock.next_range:
                wind_vector = wind_sock.vector_for_range(range_vector.x)
            range_vector += velocity_vector_half * dt
            time += dt
            altitude = self.alt0 + range_vector.y
            density_factor, mach = shot_info.atmo.get_density_factor_and_mach_for_altitude(altitude)
            accel_t_plus_dt = self._acceleration(velocity_vector_half, density_factor, mach, wind_vector)
            velocity_vector = velocity_vector_half + accel_t_plus_dt * (0.5 * dt)
            accel_next = self._acceleration(velocity_vector, density_factor, mach, wind_vector)
            velocity_vector_half = velocity_vector + accel_next * (0.5 * dt)
            velocity_mag = velocity_vector.magnitude()

            if filter_flags:
                if (data := data_filter.should_record(range_vector, velocity_vector, mach, time)) is not None:
                    current_drag_val = density_factor * velocity_mag * self.drag_by_mach(velocity_mag / mach)
                    ranges.append(self.create_trajectory_row(data.time, data.position, data.velocity,
                                                              velocity_mag, data.mach,
                                                              self.spin_drift(data.time), self.look_angle,
                                                              density_factor, current_drag_val, self.weight, data_filter.current_flag))

            if (velocity_mag < _cMinimumVelocity or range_vector.y < _cMaximumDrop or
                    self.alt0 + range_vector.y < _cMinimumAltitude):
                current_drag_val = density_factor * velocity_mag * self.drag_by_mach(velocity_mag / mach)
                ranges.append(self.create_trajectory_row(
                    time, range_vector, velocity_vector,
                    velocity_mag, mach, self.spin_drift(time), self.look_angle,
                    density_factor, current_drag_val, self.weight, data_filter.current_flag
                ))
                reason = RangeError.MinimumVelocityReached if velocity_mag < _cMinimumVelocity else \
                         RangeError.MaximumDropReached if range_vector.y < _cMaximumDrop else \
                         RangeError.MinimumAltitudeReached
                raise RangeError(reason, ranges)

            dt = self.calc_step / max(1.0, velocity_mag)

        if len(ranges) < 2:
            velocity_mag = velocity_vector.magnitude()
            current_drag_val = density_factor * velocity_mag * self.drag_by_mach(velocity_mag / mach)
            ranges.append(self.create_trajectory_row(
                time, range_vector, velocity_vector,
                velocity_mag, mach, self.spin_drift(time), self.look_angle,
                density_factor, current_drag_val, self.weight, TrajFlag.NONE))

        logger.debug(f"pure python leapfrog it {it}")
        return ranges

    def _integrate(self, shot_info: Shot, maximum_range: float, record_step: float,
                   filter_flags: Union[TrajFlag, int], time_step: float = 0.0) -> List["TrajectoryData"]:
        return self.integrate(shot_info, maximum_range, record_step, filter_flags, time_step)

# --- (Your TrajectoryData NamedTuple and other imports remain the same) ---