"""GENERATED BY GEMINI AI"""

import math
from typing import Generator, Tuple

from typing_extensions import Union, List

from py_ballisticcalc.conditions import Shot
from py_ballisticcalc.engines import BaseIntegrationEngine, _WindSock
from py_ballisticcalc.trajectory_data import TrajectoryData, TrajFlag
from py_ballisticcalc.vector import Vector


# pylint: disable=too-many-instance-attributes
class LeapFrogEngine(BaseIntegrationEngine):
    """
    All calculations are done in units of feet and fps.

    Attributes:
        barrel_azimuth (float): The azimuth angle of the barrel.
        barrel_elevation (float): The elevation angle of the barrel.
        twist (float): The twist rate of the barrel.
        gravity_vector (Vector): The gravity vector.
    """

    def _acceleration_pure_python(self, velocity_vector: Vector, density_factor: float, mach: float,
                                  wind_vector: Vector) -> Vector:
        """
        Calculates the acceleration vector (a = F/m) using pure Python Vector operations.
        """
        velocity_adjusted = velocity_vector.subtract(wind_vector)
        velocity_mag = velocity_adjusted.magnitude()

        # Handle potential division by zero for mach
        current_mach = velocity_mag / mach if mach != 0 else 1.0  # Use 1.0 or appropriate default if mach is zero

        drag_coeff = self.drag_by_mach(current_mach)
        drag_force_magnitude = density_factor * velocity_mag * drag_coeff

        # Drag force is opposite to velocity_adjusted direction
        # Ensure velocity_adjusted is not zero to avoid division by zero in normalization
        if velocity_mag > 1e-10:  # Check for near-zero velocity to prevent division by zero
            drag_force_vector = velocity_adjusted.mul_by_const(-drag_force_magnitude / velocity_mag)
        else:
            drag_force_vector = Vector(0.0, 0.0, 0.0)  # No drag if no velocity

        gravity_vector_py = self.gravity_vector  # Already a Vector object

        # Net force = Drag Force + Gravity Force
        net_force = drag_force_vector.add(gravity_vector_py)

        return drag_force_magnitude, net_force.mul_by_const(1.0 / self.weight)  # a = F/m (implicitly using weight as mass proxy)

    def _integration_generator(self, shot_info: Shot) -> Generator[
        Tuple[float, Vector, Vector, float, float, float, float], None, None]:

        # Initial state
        time = 0.0
        drag = 0.0
        range_vector = Vector(.0, -self.cant_cosine * self.sight_height, -self.cant_sine * self.sight_height)
        velocity_vector = Vector(
            self.muzzle_velocity * math.cos(self.barrel_elevation) * math.cos(self.barrel_azimuth),
            self.muzzle_velocity * math.sin(self.barrel_elevation),
            self.muzzle_velocity * math.cos(self.barrel_elevation) * math.sin(self.barrel_azimuth)
        )

        # Initial time step (dt) - will be adjusted based on current velocity
        dt = self.calc_step / max(1.0, velocity_vector.magnitude())

        wind_sock = _WindSock(shot_info.winds)
        wind_vector = wind_sock.current_vector()

        # Calculate initial acceleration to get v(t + dt/2)
        altitude_initial = self.alt0 + range_vector.y
        density_factor_initial, mach_initial = shot_info.atmo.get_density_factor_and_mach_for_altitude(altitude_initial)

        # Calculate acceleration at t
        drag, accel_t = self._acceleration_pure_python(velocity_vector, density_factor_initial, mach_initial, wind_vector)

        # First half-step for velocity
        velocity_vector_half = velocity_vector.add(accel_t.mul_by_const(0.5 * dt))

        while True:

            current_range = range_vector.x
            if current_range >= wind_sock.next_range:
                wind_vector = wind_sock.vector_for_range(current_range)

            # Update position for full step
            range_vector = range_vector.add(velocity_vector_half.mul_by_const(dt))
            time += dt

            # Update air density and mach at new position
            altitude = self.alt0 + range_vector.y
            density_factor, mach = shot_info.atmo.get_density_factor_and_mach_for_altitude(altitude)

            # Calculate acceleration at t + dt (using v_half and new position)
            drag, accel_t_plus_dt = self._acceleration_pure_python(velocity_vector_half, density_factor, mach, wind_vector)

            # Update velocity for second half-step
            velocity_vector = velocity_vector_half.add(accel_t_plus_dt.mul_by_const(0.5 * dt))

            # Prepare for next iteration: new velocity_vector_half
            accel_next = self._acceleration_pure_python(velocity_vector, density_factor, mach, wind_vector)
            velocity_vector_half = velocity_vector.add(accel_next.mul_by_const(0.5 * dt))

            velocity_mag = velocity_vector.magnitude()

            yield (
                time, range_vector, velocity_vector, velocity_mag,
                mach, density_factor, drag
            )

            # Adjust time step for next iteration based on new velocity
            dt = self.calc_step / max(1.0, velocity_mag)


    def _integrate(self, shot_info: Shot, maximum_range: float, record_step: float,
                   filter_flags: Union[TrajFlag, int], time_step: float = 0.0) -> List["TrajectoryData"]:
        # Choose the pure Python Leapfrog implementation
        return self._integrate_leapfrog_pure_python(shot_info, maximum_range, record_step, filter_flags, time_step)


__all__ = (
    'LeapFrogEngine',
)
