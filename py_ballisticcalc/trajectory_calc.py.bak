from dataclasses import dataclass
from math import sqrt, fabs, pow, sin, cos, log10, floor, atan
from typing import NamedTuple

from .conditions import *
from .munition import *
from .settings import Settings
from .trajectory_data import TrajectoryData, TrajFlag
from .unit import *

__all__ = ('TrajectoryCalc',)

# cZeroFindingAccuracy = 0.000005
cZeroFindingAccuracy = 0.00000005
cMinimumVelocity = 50.0
cMaximumDrop = -15000
cMaxIterations = 10
cGravityConstant = -32.17405


class CurvePoint(NamedTuple):
    a: float
    b: float
    c: float


@dataclass
class Vector:
    x: float
    y: float
    z: float

    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def magnitude(self):
        return sqrt(self.x * self.x + self.y * self.y + self.z * self.z)

    def mul_by_const(self, a):
        return Vector(self.x * a, self.y * a, self.z * a)

    def mul_by_vector(self, b):
        return self.x * b.x + self.y * b.y + self.z * b.z

    def add(self, b):
        return Vector(self.x + b.x, self.y + b.y, self.z + b.z)

    def subtract(self, b):
        return Vector(self.x - b.x, self.y - b.y, self.z - b.z)

    def negate(self):
        return Vector(-self.x, -self.y, -self.z)

    def normalize(self):
        m = self.magnitude()
        if fabs(m) < 1e-10:
            return Vector(self.x, self.y, self.z)
        return self.mul_by_const(1.0 / m)

    def __add__(self, other):
        return self.add(other)

    def __radd__(self, other):
        return self.add(other)

    def __iadd__(self, other):
        return self.add(other)

    def __sub__(self, other):
        return self.subtract(other)

    def __rsub__(self, other):
        return self.subtract(other)

    def __isub__(self, other):
        return self.subtract(other)

    def __mul__(self, other):
        if isinstance(other, (int, float)):
            return self.mul_by_const(other)
        elif isinstance(other, Vector):
            return self.mul_by_vector(other)
        raise TypeError(other)

    def __rmul__(self, other):
        return self.__mul__(other)

    def __imul__(self, other):
        return self.__mul__(other)

    def __neg__(self):
        return self.negate()


class TrajectoryCalc:

    def __init__(self, ammo: Ammo):
        self.ammo = ammo
        self._bc = self.ammo.dm.value
        self._table_data = ammo.dm.drag_table
        self._curve = calculate_curve(self._table_data)

    @staticmethod
    def get_calc_step(step):
        maximum_step = Settings._MAX_CALC_STEP_SIZE

        step /= 2

        if step > maximum_step:
            step_order = int(floor(log10(step)))
            maximum_order = int(floor(log10(maximum_step)))
            step /= pow(10, step_order - maximum_order + 1)

        return step

    def sight_angle(self, weapon: Weapon, atmo: Atmo):
        return self._sight_angle(self.ammo, weapon, atmo)

    def trajectory(self, weapon: Weapon, atmo: Atmo,
                   shot_info: Shot, winds: list[Wind],
                   filter_flags: TrajFlag = TrajFlag.RANGE):
        return self._trajectory(self.ammo, weapon, atmo, shot_info, winds, filter_flags)

    def _sight_angle(self, ammo, weapon, atmo):
        calc_step = self.get_calc_step(weapon.zero_distance.units(10) >> Distance.Foot)
        zero_distance = weapon.zero_distance >> Distance.Foot
        maximum_range = zero_distance + calc_step
        sight_height = weapon.sight_height >> Distance.Foot
        mach = atmo.mach >> Velocity.FPS
        density_factor = atmo.density_factor()
        muzzle_velocity = ammo.mv >> Velocity.FPS
        barrel_azimuth = 0.0
        barrel_elevation = 0.0
        iterations_count = 0
        zero_finding_error = cZeroFindingAccuracy * 2
        gravity_vector = Vector(.0, cGravityConstant, .0)

        # x - distance towards target, y - drop and z - windage
        while zero_finding_error > cZeroFindingAccuracy and iterations_count < cMaxIterations:
            velocity = muzzle_velocity
            time = 0.0
            range_vector = Vector(.0, -sight_height, .0)
            velocity_vector = Vector(
                cos(barrel_elevation) * cos(barrel_azimuth),
                sin(barrel_elevation),
                cos(barrel_elevation) * sin(barrel_azimuth)
            ) * velocity

            while range_vector.x <= maximum_range:
                if velocity < cMinimumVelocity or range_vector.y < cMaximumDrop:
                    break

                delta_time = calc_step / velocity_vector.x

                drag = density_factor * velocity * self.drag_by_match(velocity / mach)

                velocity_vector -= (velocity_vector * drag - gravity_vector) * delta_time
                delta_range_vector = Vector(calc_step, velocity_vector.y * delta_time,
                                            velocity_vector.z * delta_time)
                range_vector += delta_range_vector
                velocity = velocity_vector.magnitude()
                time += delta_range_vector.magnitude() / velocity

                if fabs(range_vector.x - zero_distance) < 0.5 * calc_step:
                    zero_finding_error = fabs(range_vector.y)
                    barrel_elevation -= range_vector.y / range_vector.x
                    break

            iterations_count += 1

        return Angular.Radian(barrel_elevation)

    def _trajectory(self, ammo, weapon, atmo,
                    shot_info, winds, filter_flags):

        twist = weapon.twist >> Distance.Inch
        length = ammo.length >> Distance.Inch
        diameter = ammo.dm.diameter >> Distance.Inch
        weight = ammo.dm.weight >> Weight.Grain

        step = shot_info.step >> Distance.Foot
        maximum_range = (shot_info.max_range >> Distance.Foot) + 1
        calc_step = self.get_calc_step(step)

        ranges_length = int(floor(maximum_range / step)) + 1
        len_winds = len(winds)
        current_item = 0
        current_wind = 0
        twist_coefficient = 0

        stability_coefficient = 1.0
        next_wind_range = 1e7

        barrel_elevation = (shot_info.sight_angle >> Angular.Radian) + (
                shot_info.shot_angle >> Angular.Radian)
        alt0 = atmo.altitude >> Distance.Foot
        sight_height = weapon.sight_height >> Distance.Foot

        next_range_distance = .0
        barrel_azimuth = .0

        gravity_vector = Vector(.0, cGravityConstant, .0)
        range_vector = Vector(.0, -sight_height, .0)

        ranges = []

        previous_y = 0
        previous_mach = 0
        # _flag

        time = 0

        if len_winds < 1:
            wind_vector = Vector(.0, .0, .0)
        else:
            if len_winds > 1:
                next_wind_range = winds[0].until_distance() >> Distance.Foot
            wind_vector = wind_to_vector(shot_info, winds[0])

        if Settings.USE_POWDER_SENSITIVITY:
            velocity = ammo.get_velocity_for_temp(atmo.temperature) >> Velocity.FPS
        else:
            velocity = ammo.mv >> Velocity.FPS

        # x - distance towards target, y - drop and z - windage
        velocity_vector = Vector(cos(barrel_elevation) * cos(barrel_azimuth), sin(barrel_elevation),
                                 cos(barrel_elevation) * sin(barrel_azimuth)) * velocity

        if twist != 0 and length and diameter:
            stability_coefficient = calculate_stability_coefficient(ammo, weapon, atmo)
            twist_coefficient = -1 if twist > 0 else 1

        while range_vector.x <= maximum_range + calc_step:
            _flag = TrajFlag.NONE

            if velocity < cMinimumVelocity or range_vector.y < cMaximumDrop:
                break

            density_factor, mach = atmo.get_density_factor_and_mach_for_altitude(alt0 + range_vector.y)

            if range_vector.x >= next_wind_range:
                current_wind += 1
                wind_vector = wind_to_vector(shot_info, winds[current_wind])

                if current_wind == len_winds - 1:
                    next_wind_range = 1e7
                else:
                    next_wind_range = winds[current_wind].until_distance() >> Distance.Foot

            # Zero-crossing check
            if range_vector.y < 0 < previous_y:
                _flag |= TrajFlag.ZERO

            # Mach crossing check
            if (velocity / mach < 1) and (previous_mach > 1):
                _flag |= TrajFlag.MACH

            # Next range check
            if range_vector.x >= next_range_distance:
                _flag |= TrajFlag.RANGE
                next_range_distance += step
                current_item += 1

            if _flag & filter_flags:
                windage = range_vector.z

                if twist != 0:
                    windage += (1.25 * (stability_coefficient + 1.2) * pow(time, 1.83) * twist_coefficient) / 12

                ranges.append(
                    create_trajectory_row(time, range_vector, velocity_vector,
                                          velocity, mach, windage, weight, _flag)
                )

                if current_item == ranges_length:
                    break

            previous_y = range_vector.y
            previous_mach = velocity / mach

            velocity_adjusted = velocity_vector - wind_vector

            delta_time = calc_step / velocity_vector.x
            velocity = velocity_adjusted.magnitude()

            drag = density_factor * velocity * self.drag_by_match(velocity / mach)

            velocity_vector -= (velocity_adjusted * drag - gravity_vector) * delta_time
            delta_range_vector = Vector(calc_step,
                                        velocity_vector.y * delta_time,
                                        velocity_vector.z * delta_time)
            range_vector += delta_range_vector
            velocity = velocity_vector.magnitude()
            time += delta_range_vector.magnitude() / velocity

        return ranges

    def drag_by_match(self, mach):
        cd = calculate_by_curve(self._table_data, self._curve, mach)
        return cd * 2.08551e-04 / self._bc

    @property
    def cdm(self):
        return self._cdm()

    def _cdm(self):
        """
        Returns custom drag function based on input data
        """

        drag_table = self.ammo.dm.drag_table
        cdm = []
        bc = self.ammo.dm.value

        for point in drag_table:
            st_mach = point['Mach']
            st_cd = calculate_by_curve(drag_table, self._curve, st_mach)
            # cd = st_cd * ff
            cd = st_cd * bc
            cdm.append({'CD': cd, 'Mach': st_mach})

        return cdm


def calculate_stability_coefficient(ammo, rifle, atmo):
    weight = ammo.dm.weight >> Weight.Grain
    diameter = ammo.dm.diameter >> Distance.Inch
    twist = fabs(rifle.twist >> Distance.Inch) / diameter
    length = (ammo.length >> Distance.Inch) / diameter
    ft = atmo.temperature >> Temperature.Fahrenheit
    mv = ammo.mv >> Velocity.FPS
    pt = atmo.pressure >> Pressure.InHg
    sd = 30 * weight / (pow(twist, 2) * pow(diameter, 3) * length * (1 + pow(length, 2)))
    fv = pow(mv / 2800, 1.0 / 3.0)
    ftp = ((ft + 460) / (59 + 460)) * (29.92 / pt)
    return sd * fv * ftp


def wind_to_vector(shot, wind):
    sight_cosine = cos(shot.sight_angle >> Angular.Radian)
    sight_sine = sin(shot.sight_angle >> Angular.Radian)
    cant_cosine = cos(shot.cant_angle >> Angular.Radian)
    cant_sine = sin(shot.cant_angle >> Angular.Radian)
    range_velocity = (wind.velocity >> Velocity.FPS) * cos(wind.direction_from >> Angular.Radian)
    cross_component = (wind.velocity >> Velocity.FPS) * sin(wind.direction_from >> Angular.Radian)
    range_factor = -range_velocity * sight_sine
    return Vector(range_velocity * sight_cosine,
                  range_factor * cant_cosine + cross_component * cant_sine,
                  cross_component * cant_cosine - range_factor * cant_sine)


def create_trajectory_row(time, range_vector, velocity_vector,
                          velocity, mach, windage, weight, flag):
    drop_adjustment = get_correction(range_vector.x, range_vector.y)
    windage_adjustment = get_correction(range_vector.x, windage)
    trajectory_angle = atan(velocity_vector.y / velocity_vector.x)

    return TrajectoryData(
        time=time,
        distance=Distance.Foot(range_vector.x),
        drop=Distance.Foot(range_vector.y),
        drop_adj=Angular.Radian(drop_adjustment),
        windage=Distance.Foot(windage),
        windage_adj=Angular.Radian(windage_adjustment),
        velocity=Velocity.FPS(velocity),
        mach=velocity / mach,
        energy=Energy.FootPound(calculate_energy(weight, velocity)),
        angle=Angular.Radian(trajectory_angle),
        ogw=Weight.Pound(calculate_ogv(weight, velocity)),
        flag=flag
    )


def get_correction(distance, offset):
    if distance != 0:
        return atan(offset / distance)
    return 0  # better None


def calculate_energy(bullet_weight, velocity):
    return bullet_weight * pow(velocity, 2) / 450400


def calculate_ogv(bullet_weight, velocity):
    return pow(bullet_weight, 2) * pow(velocity, 3) * 1.5e-12


def calculate_curve(data_points):
    rate = (data_points[1]['CD'] - data_points[0]['CD']) / (data_points[1]['Mach'] - data_points[0]['Mach'])
    curve = [CurvePoint(0, rate, data_points[0]['CD'] - data_points[0]['Mach'] * rate)]
    len_data_points = int(len(data_points))
    len_data_range = len_data_points - 1

    for i in range(1, len_data_range):
        x1 = data_points[i - 1]['Mach']
        x2 = data_points[i]['Mach']
        x3 = data_points[i + 1]['Mach']
        y1 = data_points[i - 1]['CD']
        y2 = data_points[i]['CD']
        y3 = data_points[i + 1]['CD']
        a = ((y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1)) / (
                (x3 * x3 - x1 * x1) * (x2 - x1) - (x2 * x2 - x1 * x1) * (x3 - x1))
        b = (y2 - y1 - a * (x2 * x2 - x1 * x1)) / (x2 - x1)
        c = y1 - (a * x1 * x1 + b * x1)
        curve_point = CurvePoint(a, b, c)
        curve.append(curve_point)

    num_points = len_data_points
    rate = (data_points[num_points - 1]['CD'] - data_points[num_points - 2]['CD']) / \
           (data_points[num_points - 1]['Mach'] - data_points[num_points - 2]['Mach'])
    curve_point = CurvePoint(0, rate, data_points[num_points - 1]['CD'] - data_points[num_points - 2]['Mach'] * rate)
    curve.append(curve_point)
    return curve


def calculate_by_curve(data, curve, mach):
    num_points = int(len(curve))
    mlo = 0
    mhi = num_points - 2

    while mhi - mlo > 1:
        mid = int(floor(mhi + mlo) / 2.0)
        if data[mid]['Mach'] < mach:
            mlo = mid
        else:
            mhi = mid

    if data[mhi]['Mach'] - mach > mach - data[mlo]['Mach']:
        m = mlo
    else:
        m = mhi
    curve_m = curve[m]
    return curve_m.c + mach * (curve_m.b + curve_m.a * mach)
