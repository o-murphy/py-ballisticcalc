#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "BeautifulSoup4",
# ]
# ///

import re
from typing import Tuple, Dict
from pathlib import Path

from bs4 import BeautifulSoup


PROJECT_ROOT = Path(__file__).parent.parent
REPORTS_DIR = PROJECT_ROOT / "py_ballisticcalc.exts" / "py_ballisticcalc_exts"
HTML_REPORT_PATH = PROJECT_ROOT / "cythonization.html"

def calculate_cythonization_percentage(html_content: str) -> (float, float, float):
    """
    Calculates the Cythonization percentage from HTML content generated by Cython's
    annotation tool, mirroring the logic of the provided JavaScript script.

    Args:
        html_content: A string containing the HTML output from Cython's annotation.

    Returns:
        A dictionary containing the calculated metrics:
        - 'total_lines': Total non-empty, non-commented lines.
        - 'python_overhead_lines': Lines with any Python interaction score.
        - 'total_score_sum': Sum of all individual line scores.
        - 'cythonization_percentage': Overall Cythonization percentage based on scores.
        - 'python_overhead_lines_percentage': Percentage of lines with Python overhead.
    """
    soup = BeautifulSoup(html_content, 'html.parser')

    total_lines = 0
    python_overhead_lines = 0
    total_score_sum = 0

    # Select all lines with the 'pre.cython.line' class
    # These correspond to the annotated lines in Cython's HTML output
    # cython_lines = soup.find_all('pre', {"class": 'cython line'})
    cython_lines = soup.find_all('pre', {"class": ['cython', 'line']})

    for pre in cython_lines:
        line_text = pre.get_text().strip()

        # Skip lines that are comments, docstrings, or effectively empty.
        # These regex patterns correctly account for the line number prefix
        # that is present in the `line_text` from the HTML.
        # The logic precisely matches the JavaScript's filtering conditions.
        if (
                re.match(r'^\d+:\s*#', line_text)  # Matches "1: # This is a comment"
                or re.match(r'^\d+:\s*"""', line_text)  # Matches "2: """Docstring"""
                or not re.search(r':\s*\S', line_text)  # Matches "3:", "4:   ", but not "5: actual_code"
        ):
            continue  # Skip this line from all calculations

        total_lines += 1

        # Extract the score from the class attribute (e.g., 'score-62')
        score = 0
        for cls in pre.get('class', []):
            if cls.startswith('score-'):
                try:
                    score = int(cls.split('-')[1])
                    break
                except ValueError:
                    # Handle cases where score might not be a valid integer, though unlikely
                    print(f"Warning: Could not parse score from class '{cls}' for line: {line_text}")
                    score = 0  # Default to 0 if parsing fails

        # Add score to totalScore only for eligible lines
        total_score_sum += score

        # Any nonzero score means it has Python overhead
        if score > 0:
            python_overhead_lines += 1

    return total_lines, total_score_sum, python_overhead_lines


def format_result(total_lines, total_score_sum, python_overhead_lines):
    # Calculate percentages, mirroring the JavaScript's formulas
    cythonization_percentage = 0.0
    python_overhead_lines_percentage = 0.0

    if total_lines > 0:
        # This corresponds to `(1 - totalScore / (totalLines*100)) * 100` in JS
        cythonization_percentage = (1 - total_score_sum / (total_lines * 100)) * 100
        # This corresponds to `(pythonOverheadLines / totalLines) * 100` (which is `100 - cythonizedLinesPercent` in JS output)
        python_overhead_lines_percentage = (python_overhead_lines / total_lines) * 100
    else:
        print("No eligible lines found for calculation.")

    return {
        "total_lines": total_lines,
        "python_overhead_lines": python_overhead_lines,
        "total_score_sum": total_score_sum,
        "cythonization_percentage": round(cythonization_percentage, 2),
        "python_overhead_lines_percentage": round(python_overhead_lines_percentage, 2)
    }


def compose_results(results: Dict[Path, Tuple[float, float, float]]) -> (float, float, float):
    sum_col1 = 0.0
    sum_col2 = 0.0
    sum_col3 = 0.0

    for path, values_tuple in results.items():
        sum_col1 += values_tuple[0]
        sum_col2 += values_tuple[1]
        sum_col3 += values_tuple[2]

    return (sum_col1, sum_col2, sum_col3)



def print_result(name: str, result: Tuple[float, float, float]):
    result = format_result(*result)
    print(name)
    print(f"Total Score Sum: {result['total_score_sum']}, Possible Score: {result['total_lines'] * 100}")
    print(f"Total Non-Empty Lines: {result['total_lines']}")
    print(f"Python Overhead Lines: {result['python_overhead_lines']}")
    print(f"Cythonization Percentage: {result['cythonization_percentage']}%")
    print(f"Python Overhead Lines Percentage: {result['python_overhead_lines_percentage']}%")
    print()


def generate_html_report(results: Dict[Path, Tuple[float, float, float]]) -> str:
    """
    Generates a pretty HTML report summarizing Cythonization percentages for multiple files.

    Args:
        results: A dictionary where keys are Path objects (file names) and values are
                 tuples of (total_lines, total_score_sum, python_overhead_lines).

    Returns:
        A string containing the complete HTML report.
    """
    html_content = """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Cythonization Report</title>
        <style>
            body {
                font-family: 'Inter', sans-serif; /* Using a common sans-serif font */
                margin: 20px;
                background-color: #f4f7f6;
                color: #333;
                line-height: 1.6;
            }
            .container {
                max-width: 900px;
                margin: 0 auto;
                padding: 20px;
                background-color: #ffffff;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }
            h1 {
                color: #2c3e50;
                text-align: center;
                margin-bottom: 30px;
                font-size: 2.5em;
                border-bottom: 2px solid #e0e0e0;
                padding-bottom: 15px;
            }
            h2 {
                color: #34495e;
                margin-top: 40px;
                margin-bottom: 20px;
                font-size: 1.8em;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 10px;
            }
            .file-section, .total-section {
                margin-bottom: 30px;
                padding: 20px;
                background-color: #ecf0f1;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 15px;
            }
            th, td {
                padding: 12px 15px;
                border: 1px solid #ddd;
                text-align: left;
            }
            th {
                background-color: #4a69bd;
                color: white;
                font-weight: bold;
            }
            tr:nth-child(even) {
                background-color: #f9f9f9;
            }
            tr:hover {
                background-color: #f1f1f1;
            }
            .percentage {
                font-weight: bold;
                color: #27ae60; /* Green for good percentages */
            }
            .overhead-percentage {
                font-weight: bold;
                color: #e74c3c; /* Red for high overhead */
            }
            .footer {
                text-align: center;
                margin-top: 40px;
                font-size: 0.9em;
                color: #7f8c8d;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Cythonization Report</h1>
            <p>This report summarizes the Cythonization percentage for various source files, indicating the level of Python interaction within the compiled code.</p>
    """

    # Add total summary report
    total_raw_result = compose_results(results)
    total_formatted_result = format_result(*total_raw_result)

    html_content += f"""
                <div class="total-section">
                    <h2>Overall Summary</h2>
                    <table>
                        <tr><th>Metric</th><th>Value</th></tr>
                        <tr><td>Total Score Sum</td><td>{total_formatted_result['total_score_sum']}</td></tr>
                        <tr><td>Possible Score</td><td>{total_formatted_result['total_lines'] * 100}</td></tr>
                        <tr><td>Total Non-Empty Lines</td><td>{total_formatted_result['total_lines']}</td></tr>
                        <tr><td>Python Overhead Lines</td><td>{total_formatted_result['python_overhead_lines']}</td></tr>
                        <tr><td>Overall Cythonization Percentage</td><td class="percentage">{total_formatted_result['cythonization_percentage']}%</td></tr>
                        <tr><td>Overall Python Overhead Lines Percentage</td><td class="overhead-percentage">{total_formatted_result['python_overhead_lines_percentage']}%</td></tr>
                    </table>
                </div>
        """

    # Add individual file reports
    for report_path, raw_result in results.items():
        formatted_result = format_result(*raw_result)
        file_name = report_path.stem # Get just the file name without extension
        html_content += f"""
            <div class="file-section">
                <h2>File: {file_name}.html</h2>
                <table>
                    <tr><th>Metric</th><th>Value</th></tr>
                    <tr><td>Total Score Sum</td><td>{formatted_result['total_score_sum']}</td></tr>
                    <tr><td>Possible Score</td><td>{formatted_result['total_lines'] * 100}</td></tr>
                    <tr><td>Total Non-Empty Lines</td><td>{formatted_result['total_lines']}</td></tr>
                    <tr><td>Python Overhead Lines</td><td>{formatted_result['python_overhead_lines']}</td></tr>
                    <tr><td>Cythonization Percentage</td><td class="percentage">{formatted_result['cythonization_percentage']}%</td></tr>
                    <tr><td>Python Overhead Lines Percentage</td><td class="overhead-percentage">{formatted_result['python_overhead_lines_percentage']}%</td></tr>
                </table>
            </div>
        """

    html_content += """
            <div class="footer">
                <p>&copy; 2023 Cythonization Reporter. Generated on {current_date}.</p>
            </div>
        </div>
    </body>
    </html>
    """.format(current_date=Path.cwd().name) # A placeholder, replace with actual date if needed

    return html_content


if __name__ == "__main__":

    reports = (p for p in REPORTS_DIR.iterdir() if p.suffix == '.html')
    results = {}
    report: Path
    for report in reports:
        with open(report) as html_file:
            html_content_from_file = html_file.read()

        results[report] = (calculate_cythonization_percentage(html_content_from_file))

    for report, result in results.items():
        print_result(f"File: {report.stem} :", result)

    print_result("Total:", compose_results(results))

    # Generate and save the HTML report
    if results:
        html_report_output = generate_html_report(results)
        output_file_path = HTML_REPORT_PATH  # Save in the same directory as source htmls
        try:
            with open(output_file_path, 'w', encoding='utf-8') as f:
                f.write(html_report_output)
            print(f"\nHTML report generated successfully: {output_file_path}")
        except IOError as e:
            print(f"Error saving HTML report to {output_file_path}: {e}")
    else:
        print("\nNo Cythonization reports found or processed to generate an HTML report.")
