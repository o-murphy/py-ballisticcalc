{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-ballisticcalc","text":"<p>py-ballisticcalc is the most flexible library for ballistic trajectory calculations for Python.</p>"},{"location":"about/","title":"About project","text":"<p>The library provides trajectory calculation for ballistic projectiles including air rifles, bows, firearms, artillery, and so on.</p> <p>The 3DoF model that is used in this calculator is rooted in public C code of JBM's calculator, ported to C#, optimized, fixed and extended with elements described in Litz's Applied Ballistics book and from the friendly project of Alexandre Trofimov and then ported to Go.</p> <p>This Python3 implementation has been expanded to support multiple ballistic coefficients and custom drag functions, such as those derived from Doppler radar data.</p> <p>The online version of Go documentation is located here.</p> <p>C# version of the package is located here, and the online version of C# API documentation is located here.</p> <p>RISK NOTICE</p> <p>The library performs very limited simulation of a complex physical process and so it performs a lot of approximations. Therefore, the calculation results MUST NOT be considered as completely and reliably reflecting actual behavior or characteristics of projectiles. While these results may be used for educational purpose, they must NOT be considered as reliable for the areas where incorrect calculation may cause making a wrong decision, financial harm, or can put a human life at risk.</p> <p>THE CODE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"contributing/","title":"Contributing","text":"<p>We'd love you to contribute to py_ballisticcalc!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"from importlib_metadata import metadata; print(metadata('py-ballisticcalc')['Version'])\"\n</code></pre> <p>Please try to always include the above unless you're unable to install py-ballisticcalc or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be extremely simple to get started and create a Pull Request. py-ballisticcalc is released regularly so you should see your improvements release in a matter of days or weeks \ud83d\ude80.</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily, py-ballisticcalc has few dependencies, and tests don't need access to databases, etc. Because of this, setting up and running the tests should be very simple.</p> <p>Note</p> <p>You should know the py-ballisticcalc requires cython to compile py-ballisticcalc.exts module to get high productivity calculations</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>You'll need the following prerequisites:</p> <ul> <li>Any Python version between Python 3.9 and 3.12</li> <li>venv or uv or other virtual environment tool</li> <li>git</li> </ul>"},{"location":"contributing/#installation-and-setup","title":"Installation and setup","text":"<p>Fork the repository on GitHub and clone your fork locally.</p> <pre><code># Clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/py-ballisticcalc.git\ncd py-ballisticcalc\n\n# Setup virtual environment (we will use `venv` there)\npython -m venv .venv\nsource .venv/bin/activate\n\n# Install package in editable mode with `dev` requirements to local environment \npip install -e .[dev]\n</code></pre> <p>If you want to contribute to cythonized extensions you can also install them in editable mode</p> <pre><code>pip install -e ./py_ballisticcalc.exts[dev]\n</code></pre>"},{"location":"contributing/#check-out-a-new-branch-and-make-your-changes","title":"Check out a new branch and make your changes","text":"<p>Create a new branch for your changes.</p> <pre><code># Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# Make your changes...\n</code></pre>"},{"location":"contributing/#run-tests-and-linting","title":"Run tests and linting","text":"<p>Run tests and linting locally to make sure everything is working as expected.</p> <pre><code># Run automated code linting\npylint ./py_ballisticcalc \n\n# Run mypy static analysing \nmypy ./py_ballisticcalc\n\n# Run automated tests\npytest tests\n</code></pre> <p>If you've made any changes to the documentation (including changes to function signatures, class definitions, or docstrings that will appear in the API documentation), make sure it builds successfully.</p> <p>We use <code>mkdocs-material[imaging]</code> to support social previews. You can find directions on how to install the required dependencies here.</p> <pre><code># Install dependencies for docs building\npip install -e .[docs]\n\n# Rebuild docs locally before commiting them to the branch   \nmkdocs build\n\n# Use this command to serve docs locally \nmkdocs serve\n</code></pre> <p>If this isn't working due to issues with the imaging plugin, try commenting out the <code>social</code> plugin line in <code>mkdocs.yml</code> and running <code>mkdocs build</code> again.</p>"},{"location":"contributing/#commit-and-push-your-changes","title":"Commit and push your changes","text":"<p>Commit your changes, push your branch to GitHub, and create a pull request.</p> <p>Please follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.</p> <p>When your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.</p>"},{"location":"contributing/#documentation-style","title":"Documentation style","text":"<p>Documentation is written in Markdown and built using Material for MkDocs. API documentation is build from docstrings using mkdocstrings.</p>"},{"location":"contributing/#code-documentation","title":"Code documentation","text":"<p>When contributing to py-ballisticcalc, please make sure that all code is well documented. The following should be documented using properly formatted docstrings:</p> <ul> <li>Modules</li> <li>Class definitions</li> <li>Function definitions</li> <li>Module-level variables</li> </ul> <p>py-ballisticcalc uses Google-style docstrings formatted according to PEP 257 guidelines. ( See Example Google Style Python Docstrings for further examples.)</p> <p>pydocstyle is used for linting docstrings. You can run <code>pydocstyle .\\py_ballisticcalc\\</code> to check your docstrings.</p> <p>Where this is a conflict between Google-style docstrings and pydocstyle linting, follow the pydocstyle linting hints.</p> <p>Class attributes and function arguments should be documented in the format \"name: description.\" When applicable, a return type should be documented with just a description. Types are inferred from the signature.</p> <pre><code>class Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n</code></pre> <pre><code>def bar(self, baz: int) -&gt; str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n</code></pre> <p>You may include example code in docstrings. </p> <p>Class and instance attributes</p> <p>Class attributes should be documented in the class docstring.</p> <p>Instance attributes should be documented as \"Args\" in the <code>__init__</code> docstring.</p>"},{"location":"contributing/#documentation-style_1","title":"Documentation Style","text":"<p>In general, documentation should be written in a friendly, approachable style. It should be easy to read and understand, and should be as concise as possible while still being complete.</p> <p>Code examples are encouraged, but should be kept short and simple. However, every code example should be complete, self-contained, and runnable. (If you're not sure how to do this, ask for help!) We prefer print output to naked asserts, but if you're testing something that doesn't have a useful print output, asserts are fine.</p>"},{"location":"contributors/","title":"Our People","text":"<p>py-ballisticcalc has an amazing community of contributors, reviewers, and experts that help propel the project forward. Here, we celebrate those people and their contributions.</p>"},{"location":"contributors/#contributors","title":"Contributors","text":"<p>This project exists thanks to all the people who contribute.</p> <p></p> <p>Special thanks to:</p> <ul> <li>David Bookstaber - Ballistics Expert  For help understanding and improving the functionality</li> <li>Nikolay Gekht For the sources code on C# and GO-lang from which this project firstly was forked</li> </ul>"},{"location":"help/","title":"Getting help with py-ballisticcalc","text":"<p>If you need help getting started with py-ballisticcalc or with advanced usage, the following sources may be useful.</p>"},{"location":"help/#usage-documentation","title":"Usage Documentation","text":"<p>The usage documentation is the most complete guide on how to use py-ballisticcalc.</p>"},{"location":"help/#github-discussions","title":"GitHub Discussions","text":"<p>GitHub discussions are useful for asking questions, your question and the answer will help everyone.</p>"},{"location":"install/","title":"Installation","text":"<p>Installation is as simple as:</p> pipuv <pre><code>pip install py-ballisticcalc\n</code></pre> <pre><code>uv add py-ballisticcalc \n</code></pre> <p>py-ballisticcalc has a few dependencies:</p> <ul> <li><code>typing-extensions</code>: Backport of the standard library typing module.</li> </ul> <p>If you've got Python 3.9+ and <code>pip</code> installed, you're good to go.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>py-ballisticcalc has the following optional dependencies:</p> <ul> <li><code>py_ballisticcalc.exts</code>: Cython based implementation of some classes to increase performance. py_ballisticcalc.exts package.</li> </ul> <p>To install optional dependencies along with py-ballisticcalc:</p> pipuv <pre><code># with the `py_ballisticcalc.exts` extra:\npip install 'py-ballisticcalc[exts]'\n</code></pre> <pre><code># with dependencies for data visualisation    \npip install py-ballisticcalc[visualize]\n</code></pre> <pre><code># with the `py_ballisticcalc.exts` extra:\nuv add 'py-ballisticcalc[exts]'\n</code></pre> <pre><code># with dependencies for data visualisation    \nuv add  'py-ballisticcalc[visualize]'\n</code></pre> <p>Of course, you can also install requirements manually with <code>pip install py-ballisticcalc.exts pandas matplotlib</code>.</p> <p>To install latest version from sources in editable mode</p> <pre><code>git clone github.com/o-murphy/py-ballisticcalc\ncd py-ballisticcalc\npip install -e .[dev]\n# optionally install binary extensions\npip install -e ./py_ballisticcalc.exts[dev]\n</code></pre>"},{"location":"why/","title":"Why use Pydantic py-ballisticcalc?","text":""},{"location":"api/constants/","title":"Constants","text":"<p>Global Constants</p>"},{"location":"api/constants/#global-atmosphere-constants","title":"Global atmosphere constants","text":"Constant Description Value Unit / Notes <code>cStandardHumidity</code> Relative Humidity in percents 0.0 % <code>cPressureExponent</code> =gM/RL 5.255876 - <code>cA0</code> Coefficient A0 1.24871 - <code>cA1</code> Coefficient A1 0.0988438 - <code>cA2</code> Coefficient A2 0.00152907 - <code>cA3</code> Coefficient A3 -3.07031e-06 - <code>cA4</code> Coefficient A4 4.21329e-07 - <code>cA5</code> Coefficient A5 3.342e-04 -"},{"location":"api/constants/#isa-metric-prefer_units","title":"ISA, metric prefer_units","text":"Constant Description Value Unit / Notes <code>cDegreesCtoK</code> Celsius to Kelvin conversion 273.15 \u00b0K = \u00b0C + 273.15 <code>cStandardTemperatureC</code> Standard temperature in Celsius 15.0 \u00b0C <code>cLapseRateMetric</code> Metric lapse rate -6.5e-03 \u00b0C/m <code>cStandardPressureMetric</code> Standard pressure (metric) 1013.25 hPa <code>cSpeedOfSoundMetric</code> Speed of sound in metric 331.3 m/s <code>cStandardDensityMetric</code> Standard air density (metric) 1.2250 kg/m\u00b3 <code>cDensityImperialToMetric</code> Density conversion (imperial to metric) 16.0185 lb/ft\u00b3 to kg/m\u00b3"},{"location":"api/constants/#icao-standard-atmosphere","title":"ICAO standard atmosphere","text":"Constant Description Value Unit / Notes <code>cDegreesFtoR</code> Fahrenheit to Rankine conversion 459.67 \u00b0R = \u00b0F + 459.67 <code>cStandardTemperatureF</code> Standard temperature in Fahrenheit 59.0 \u00b0F <code>cLapseRateImperial</code> Imperial lapse rate -3.56616e-03 \u00b0F/ft <code>cStandardPressure</code> Standard pressure (imperial) 29.92 InHg <code>cSpeedOfSoundImperial</code> Speed of sound (imperial) 49.0223 fps <code>cStandardDensity</code> Standard air density (imperial) 0.076474 lb/ft\u00b3"},{"location":"api/constants/#runtime-limits-constants","title":"Runtime limits constants","text":"Constant Description Value Unit / Notes <code>cLowestTempF</code> Lowest temperature recorded -130 \u00b0F <code>cMaxWindDistanceFeet</code> Maximum wind distance 1e8 ft"},{"location":"api/drag_model/","title":"DragModel","text":"<p>Drag model of projectile</p>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragDataPoint","title":"DragDataPoint  <code>dataclass</code>","text":"<pre><code>DragDataPoint(Mach: float, CD: float)\n</code></pre> <p>Drag coefficient at Mach number</p>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.BCPoint","title":"BCPoint  <code>dataclass</code>","text":"<pre><code>BCPoint(BC: float, Mach: Optional[float] = None, V: Optional[Union[float, Velocity]] = None)\n</code></pre> <p>For multi-bc drag models, designed to sort by Mach ascending</p> Source code in <code>py_ballisticcalc\\drag_model.py</code> <pre><code>def __init__(self,\n             BC: float,\n             Mach: Optional[float] = None,\n             V: Optional[Union[float, Velocity]] = None):\n\n    if BC &lt;= 0:\n        raise ValueError('Ballistic coefficient must be positive')\n\n    if Mach and V:\n        raise ValueError(\"You cannot specify both 'Mach' and 'V' at the same time\")\n\n    if not Mach and not V:\n        raise ValueError(\"One of 'Mach' and 'V' must be specified\")\n\n    self.BC = BC\n    self.V = PreferredUnits.velocity(V or 0)\n    if V:\n        self.Mach = (self.V &gt;&gt; Velocity.MPS) / self._machC()\n    elif Mach:\n        self.Mach = Mach\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragModel","title":"DragModel","text":"<pre><code>DragModel(bc: float, drag_table: DragTableDataType, weight: Union[float, Weight] = 0, diameter: Union[float, Distance] = 0, length: Union[float, Distance] = 0)\n</code></pre> <p>:param bc: Ballistic Coefficient of bullet = weight / diameter^2 / i,         where weight is in pounds, diameter is in inches, and         is the bullet's form factor relative to the selected drag model. :param drag_table: If passed as List of {Mach, CD} dictionaries, this         will be converted to a List of DragDataPoints. :param weight: Bullet weight in grains :param diameter: Bullet diameter in inches :param length: Bullet length in inches NOTE: .weight, .diameter, .length are only relevant for computing spin drift</p> Source code in <code>py_ballisticcalc\\drag_model.py</code> <pre><code>def __init__(self, bc: float,\n             drag_table: DragTableDataType,\n             weight: Union[float, Weight] = 0,\n             diameter: Union[float, Distance] = 0,\n             length: Union[float, Distance] = 0):\n\n    if len(drag_table) &lt;= 0:\n        # TODO: maybe have to require minimum items count, cause few values don't give a valid result\n        raise ValueError('Received empty drag table')\n    if bc &lt;= 0:\n        raise ValueError('Ballistic coefficient must be positive')\n\n    self.drag_table = make_data_points(drag_table)\n\n    self.BC = bc\n    self.length = PreferredUnits.length(length)\n    self.weight = PreferredUnits.weight(weight)\n    self.diameter = PreferredUnits.diameter(diameter)\n    if weight &gt; 0 and diameter &gt; 0:\n        self.sectional_density = self._get_sectional_density()\n        self.form_factor = self._get_form_factor(self.BC)\n</code></pre>"},{"location":"api/drag_model/#py_ballisticcalc.drag_model.DragModelMultiBC","title":"DragModelMultiBC","text":"<pre><code>DragModelMultiBC(bc_points: List[BCPoint], drag_table: DragTableDataType, weight: Union[float, Weight] = 0, diameter: Union[float, Distance] = 0, length: Union[float, Distance] = 0) -&gt; DragModel\n</code></pre> <p>Compute a drag model based on multiple BCs. If weight and diameter are provided then we set bc=sectional density. Otherwise, we set bc=1 and the drag_table contains final drag terms. :param bc_points: :param drag_table: list of dicts containing drag table data :param weight: Bullet weight in grains :param diameter: Bullet diameter in inches :param length: Bullet length in inches</p> Source code in <code>py_ballisticcalc\\drag_model.py</code> <pre><code>def DragModelMultiBC(bc_points: List[BCPoint],\n                     drag_table: DragTableDataType,\n                     weight: Union[float, Weight] = 0,\n                     diameter: Union[float, Distance] = 0,\n                     length: Union[float, Distance] = 0) -&gt; DragModel:\n    \"\"\"\n    Compute a drag model based on multiple BCs.\n    If weight and diameter are provided then we set bc=sectional density.\n    Otherwise, we set bc=1 and the drag_table contains final drag terms.\n    :param bc_points:\n    :param drag_table: list of dicts containing drag table data\n    :param weight: Bullet weight in grains\n    :param diameter: Bullet diameter in inches\n    :param length: Bullet length in inches\n    \"\"\"\n    weight = PreferredUnits.weight(weight)\n    diameter = PreferredUnits.diameter(diameter)\n    if weight &gt; 0 and diameter &gt; 0:\n        bc = sectional_density(weight &gt;&gt; Weight.Grain, diameter &gt;&gt; Distance.Inch)\n    else:\n        bc = 1.0\n\n    drag_table = make_data_points(drag_table)  # Convert from list of dicts to list of DragDataPoints\n\n    bc_points.sort(key=lambda p: p.Mach)  # Make sure bc_points are sorted for linear interpolation\n    bc_interp = linear_interpolation([x.Mach for x in drag_table],\n                                     [x.Mach for x in bc_points],\n                                     [x.BC / bc for x in bc_points])\n\n    for i, point in enumerate(drag_table):\n        point.CD = point.CD / bc_interp[i]\n    return DragModel(bc, drag_table, weight, diameter, length)\n</code></pre>"},{"location":"api/trajectory_data/","title":"TrajectoryData","text":""},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult","title":"HitResult  <code>dataclass</code>","text":"<pre><code>HitResult(shot: Shot, trajectory: list[TrajectoryData], extra: bool = False)\n</code></pre> <p>Results of the shot</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.zeros","title":"zeros","text":"<pre><code>zeros() -&gt; list[TrajectoryData]\n</code></pre> <p>:return: zero crossing points</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def zeros(self) -&gt; list[TrajectoryData]:\n    \"\"\":return: zero crossing points\"\"\"\n    self.__check_extra__()\n    data = [row for row in self.trajectory if row.flag &amp; TrajFlag.ZERO]\n    if len(data) &lt; 1:\n        raise ArithmeticError(\"Can't find zero crossing points\")\n    return data\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.index_at_distance","title":"index_at_distance","text":"<pre><code>index_at_distance(d: Distance) -&gt; int\n</code></pre> <p>:param d: Distance for which we want Trajectory Data :return: Index of first trajectory row with .distance &gt;= d; otherwise -1</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def index_at_distance(self, d: Distance) -&gt; int:\n    \"\"\"\n    :param d: Distance for which we want Trajectory Data\n    :return: Index of first trajectory row with .distance &gt;= d; otherwise -1\n    \"\"\"\n    # Get index of first trajectory point with distance &gt;= at_range\n    return next((i for i in range(len(self.trajectory))\n                 if self.trajectory[i].distance &gt;= d), -1)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.get_at_distance","title":"get_at_distance","text":"<pre><code>get_at_distance(d: Distance) -&gt; TrajectoryData\n</code></pre> <p>:param d: Distance for which we want Trajectory Data :return: First trajectory row with .distance &gt;= d</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def get_at_distance(self, d: Distance) -&gt; TrajectoryData:\n    \"\"\"\n    :param d: Distance for which we want Trajectory Data\n    :return: First trajectory row with .distance &gt;= d\n    \"\"\"\n    if (i := self.index_at_distance(d)) &lt; 0:\n        raise ArithmeticError(\n            f\"Calculated trajectory doesn't reach requested distance {d}\"\n        )\n    return self.trajectory[i]\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.danger_space","title":"danger_space","text":"<pre><code>danger_space(at_range: Union[float, Distance], target_height: Union[float, Distance], look_angle: Optional[Union[float, Angular]] = None) -&gt; DangerSpace\n</code></pre> <p>Assume that the trajectory hits the center of a target at any distance. Now we want to know how much ranging error we can tolerate if the critical region of the target has height h.  I.e., we want to know how far forward and backward along the line of sight we can move a target such that the trajectory is still within h/2 of the original drop.</p> <p>:param at_range: Danger space is calculated for a target centered at this sight distance :param target_height: Target height (h) determines danger space :param look_angle: Ranging errors occur along the look angle to the target</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def danger_space(self,\n                 at_range: Union[float, Distance],\n                 target_height: Union[float, Distance],\n                 look_angle: Optional[Union[float, Angular]] = None\n                 ) -&gt; DangerSpace:\n    \"\"\"\n    Assume that the trajectory hits the center of a target at any distance.\n    Now we want to know how much ranging error we can tolerate if the critical region\n    of the target has height *h*.  I.e., we want to know how far forward and backward\n    along the line of sight we can move a target such that the trajectory is still\n    within *h*/2 of the original drop.\n\n    :param at_range: Danger space is calculated for a target centered at this sight distance\n    :param target_height: Target height (*h*) determines danger space\n    :param look_angle: Ranging errors occur along the look angle to the target\n    \"\"\"\n    self.__check_extra__()\n\n    at_range = PreferredUnits.distance(at_range)\n    target_height = PreferredUnits.distance(target_height)\n    target_height_half = target_height.raw_value / 2.0\n\n    _look_angle: Angular\n    if look_angle is None:\n        _look_angle = self.shot.look_angle\n    else:\n        _look_angle = PreferredUnits.angular(look_angle)\n\n    # Get index of first trajectory point with distance &gt;= at_range\n    if (index := self.index_at_distance(at_range)) &lt; 0:\n        raise ArithmeticError(\n            f\"Calculated trajectory doesn't reach requested distance {at_range}\"\n        )\n\n    def find_begin_danger(row_num: int) -&gt; TrajectoryData:\n        \"\"\"\n        Beginning of danger space is last .distance' &lt; .distance where\n            (.drop' - target_center) &gt;= target_height/2\n        :param row_num: Index of the trajectory point for which we are calculating danger space\n        :return: Distance marking beginning of danger space\n        \"\"\"\n        center_row = self.trajectory[row_num]\n        for prime_row in reversed(self.trajectory[:row_num]):\n            if (prime_row.target_drop.raw_value - center_row.target_drop.raw_value) &gt;= target_height_half:\n                return prime_row\n        return self.trajectory[0]\n\n    def find_end_danger(row_num: int) -&gt; TrajectoryData:\n        \"\"\"\n        End of danger space is first .distance' &gt; .distance where\n            (target_center - .drop') &gt;= target_height/2\n        :param row_num: Index of the trajectory point for which we are calculating danger space\n        :return: Distance marking end of danger space\n        \"\"\"\n        center_row = self.trajectory[row_num]\n        for prime_row in self.trajectory[row_num + 1:]:\n            if (center_row.target_drop.raw_value - prime_row.target_drop.raw_value) &gt;= target_height_half:\n                return prime_row\n        return self.trajectory[-1]\n\n    return DangerSpace(self.trajectory[index],\n                       target_height,\n                       find_begin_danger(index),\n                       find_end_danger(index),\n                       _look_angle)\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.dataframe","title":"dataframe","text":"<pre><code>dataframe(formatted: bool = False) -&gt; DataFrame\n</code></pre> <p>:param formatted: False for values as floats; True for strings with prefer_units :return: the trajectory table as a DataFrame</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def dataframe(self, formatted: bool = False) -&gt; 'DataFrame':  # type: ignore\n    \"\"\"\n    :param formatted: False for values as floats; True for strings with prefer_units\n    :return: the trajectory table as a DataFrame\n    \"\"\"\n    try:\n        from py_ballisticcalc.visualize.dataframe import hit_result_as_dataframe\n        return hit_result_as_dataframe(self, formatted)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get trajectory as pandas.DataFrame\"\n        )from err\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.HitResult.plot","title":"plot","text":"<pre><code>plot(look_angle: Optional[Angular] = None) -&gt; Axes\n</code></pre> <p>:return: graph of the trajectory</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def plot(self, look_angle: Optional[Angular] = None) -&gt; 'Axes':  # type: ignore\n    \"\"\":return: graph of the trajectory\"\"\"\n    try:\n        from py_ballisticcalc.visualize.plot import hit_result_as_plot  # type: ignore\n        return hit_result_as_plot(self, look_angle)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get results as a plot\"\n        ) from err\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag","title":"TrajFlag","text":"<p>               Bases: <code>int</code></p> <p>Flags for marking trajectory row if Zero or Mach crossing Also uses to set a filters for a trajectory calculation loop</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajFlag.name","title":"name  <code>staticmethod</code>","text":"<pre><code>name(value: Union[int, TrajFlag]) -&gt; str\n</code></pre> <p>Return a concatenated name representation of the given flag value.</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>@staticmethod\ndef name(value: Union[int, 'TrajFlag']) -&gt; str:\n    \"\"\"Return a concatenated name representation of the given flag value.\"\"\"\n    if value in _TrajFlagNames:\n        return _TrajFlagNames[value]\n\n    parts = [name for bit, name in _TrajFlagNames.items() if bit and (value &amp; bit) == bit]\n    if \"ZERO_UP\" in parts and \"ZERO_DOWN\" in parts:\n        parts.remove(\"ZERO_UP\")\n        parts.remove(\"ZERO_DOWN\")\n    return \"|\".join(parts) if parts else \"UNKNOWN\"\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.DangerSpace","title":"DangerSpace","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Stores the danger space data for distance specified</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.DangerSpace.overlay","title":"overlay","text":"<pre><code>overlay(ax: Axes, label: Optional[str] = None)\n</code></pre> <p>Highlights danger-space region on plot</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def overlay(self, ax: 'Axes', label: Optional[str] = None):  # type: ignore\n    \"\"\"Highlights danger-space region on plot\"\"\"\n    try:\n        from py_ballisticcalc.visualize.plot import add_danger_space_overlay  # type: ignore\n        add_danger_space_overlay(self, ax, label)\n    except ImportError as err:\n        raise ImportError(\n            \"Use `pip install py_ballisticcalc[charts]` to get results as a plot\"\n        ) from err\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData","title":"TrajectoryData","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Data for one point in ballistic trajectory</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>float</code> <p>bullet flight time</p> <code>distance</code> <code>Distance</code> <p>x-axis coordinate</p> <code>velocity</code> <code>Velocity</code> <p>velocity</p> <code>mach</code> <code>float</code> <p>velocity in Mach prefer_units</p> <code>height</code> <code>Distance</code> <p>y-axis coordinate</p> <code>target_drop</code> <code>Distance</code> <p>drop relative to sight-line</p> <code>drop_adj</code> <code>Angular</code> <p>sight adjustment to zero target_drop at this distance</p> <code>windage</code> <code>Distance</code> <code>windage_adj</code> <code>Angular</code> <code>look_distance</code> <code>Distance</code> <p>sight-line distance = .distance/cosine(look_angle)</p> <code>#</code> <code>look_height (Distance</code> <p>y-coordinate of sight-line = .distance*tan(look_angle)</p> <code>angle</code> <code>Angular</code> <p>Angle of velocity vector relative to x-axis</p> <code>density_factor</code> <code>float</code> <p>Ratio of air density here to standard density</p> <code>drag</code> <code>float</code> <p>Current drag coefficient</p> <code>energy</code> <code>Energy</code> <code>ogw</code> <code>Weight</code> <p>optimal game weight</p> <code>flag</code> <code>int</code> <p>row type</p>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.formatted","title":"formatted","text":"<pre><code>formatted() -&gt; Tuple[str, ...]\n</code></pre> <p>:return: matrix of formatted strings for each value of trajectory in default prefer_units</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def formatted(self) -&gt; Tuple[str, ...]:\n    \"\"\"\n    :return: matrix of formatted strings for each value of trajectory in default prefer_units\n    \"\"\"\n\n    def _fmt(v: AbstractDimension, u: Unit) -&gt; str:\n        \"\"\"simple formatter\"\"\"\n        return f\"{v &gt;&gt; u:.{u.accuracy}f} {u.symbol}\"\n\n    return (\n        f'{self.time:.3f} s',\n        _fmt(self.distance, PreferredUnits.distance),\n        _fmt(self.velocity, PreferredUnits.velocity),\n        f'{self.mach:.2f} mach',\n        _fmt(self.height, PreferredUnits.drop),\n        _fmt(self.target_drop, PreferredUnits.drop),\n        _fmt(self.drop_adj, PreferredUnits.adjustment),\n        _fmt(self.windage, PreferredUnits.drop),\n        _fmt(self.windage_adj, PreferredUnits.adjustment),\n        _fmt(self.look_distance, PreferredUnits.distance),\n        _fmt(self.angle, PreferredUnits.angular),\n        f'{self.density_factor:.3e}',\n        f'{self.drag:.3f}',\n        _fmt(self.energy, PreferredUnits.energy),\n        _fmt(self.ogw, PreferredUnits.ogw),\n\n        TrajFlag.name(self.flag)\n    )\n</code></pre>"},{"location":"api/trajectory_data/#py_ballisticcalc.trajectory_data.TrajectoryData.in_def_units","title":"in_def_units","text":"<pre><code>in_def_units() -&gt; Tuple[float, ...]\n</code></pre> <p>:return: matrix of floats of the trajectory in default prefer_units</p> Source code in <code>py_ballisticcalc\\trajectory_data\\_trajectory_data.py</code> <pre><code>def in_def_units(self) -&gt; Tuple[float, ...]:\n    \"\"\"\n    :return: matrix of floats of the trajectory in default prefer_units\n    \"\"\"\n    return (\n        self.time,\n        self.distance &gt;&gt; PreferredUnits.distance,\n        self.velocity &gt;&gt; PreferredUnits.velocity,\n        self.mach,\n        self.height &gt;&gt; PreferredUnits.drop,\n        self.target_drop &gt;&gt; PreferredUnits.drop,\n        self.drop_adj &gt;&gt; PreferredUnits.adjustment,\n        self.windage &gt;&gt; PreferredUnits.drop,\n        self.windage_adj &gt;&gt; PreferredUnits.adjustment,\n        self.look_distance &gt;&gt; PreferredUnits.distance,\n        self.angle &gt;&gt; PreferredUnits.angular,\n        self.density_factor,\n        self.drag,\n        self.energy &gt;&gt; PreferredUnits.energy,\n        self.ogw &gt;&gt; PreferredUnits.ogw,\n        self.flag\n    )\n</code></pre>"},{"location":"api/vector/","title":"Vector","text":"<p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>distance</p> <code>y</code> <code>float</code> <p>horizontal</p> <code>z</code> <code>float</code> <p>vertical</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>distance</p> required <code>y</code> <code>float</code> <p>horizontal</p> required <code>z</code> <code>float</code> <p>vertical</p> required"},{"location":"api/vector/#py_ballisticcalc.vector._vector.Vector.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y: float\n</code></pre>"},{"location":"api/vector/#py_ballisticcalc.vector._vector.Vector.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z: float\n</code></pre>"},{"location":"api/conditions/atmo/","title":"Atmo","text":"<p>Atmo </p> <p>Atmospheric conditions and density calculations</p> Properties <p>altitude: Altitude relative to sea level pressure: Unadjusted barometric pressure, a.k.a. station pressure temperature: Temperature humidity: Relative humidity [0% to 100%] powder_temp: Temperature of powder (if different from atmosphere).     (Used when Ammo.use_powder_sensitivity is True) density_ratio: Ratio of current density to standard atmospheric density mach: Velocity of sound (Mach 1) for current atmosphere</p> <p>Parameters:</p> Name Type Description Default <code>altitude</code> <code>Optional[Union[float, Distance]]</code> <p>Altitude relative to sea level</p> <code>None</code> <code>pressure</code> <code>Optional[Union[float, Pressure]]</code> <p>Atmospheric pressure</p> <code>None</code> <code>temperature</code> <code>Optional[Union[float, Temperature]]</code> <p>Atmospheric temperature</p> <code>None</code> <code>humidity</code> <code>float</code> <p>Atmospheric relative humidity [0% to 100%]</p> <code>0.0</code> <code>powder_t</code> <code>Optional[Union[float, Temperature]]</code> <p>Custom temperature of powder different to atmospheric. Used when Ammo.use_powder_sensitivity is True</p> <code>None</code> Example <p>This is how you can create an Atmo <pre><code>from py_ballisticcalc import Atmo\natmo = Atmo(\n    altitude=Unit.Meter(100),\n    pressure=Unit.hPa(1000),\n    temperature=Unit.Celsius(20),\n    humidity=50,\n    powder_t=Unit.Celsius(15)\n)\n</code></pre></p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>def __init__(self,\n             altitude: Optional[Union[float, Distance]] = None,\n             pressure: Optional[Union[float, Pressure]] = None,\n             temperature: Optional[Union[float, Temperature]] = None,\n             humidity: float = 0.0,\n             powder_t: Optional[Union[float, Temperature]] = None):\n    \"\"\"\n    Create a new Atmo instance with given parameters\n\n    Args:\n        altitude: Altitude relative to sea level\n        pressure: Atmospheric pressure\n        temperature: Atmospheric temperature\n        humidity: Atmospheric relative humidity [0% to 100%]\n        powder_t: Custom temperature of powder different to atmospheric.\n            Used when Ammo.use_powder_sensitivity is True\n\n    Example:\n        This is how you can create an Atmo\n        ```python\n        from py_ballisticcalc import Atmo\n        atmo = Atmo(\n            altitude=Unit.Meter(100),\n            pressure=Unit.hPa(1000),\n            temperature=Unit.Celsius(20),\n            humidity=50,\n            powder_t=Unit.Celsius(15)\n        )\n        ```\n    \"\"\"\n    self._initializing = True\n    self._altitude = PreferredUnits.distance(altitude or 0)\n    self._pressure = PreferredUnits.pressure(pressure or Atmo.standard_pressure(self.altitude))\n    self._temperature = PreferredUnits.temperature(temperature or Atmo.standard_temperature(self.altitude))\n    # If powder_temperature not provided we use atmospheric temperature:\n    self._powder_temp = PreferredUnits.temperature(powder_t or self.temperature)\n    self._t0 = self.temperature &gt;&gt; Temperature.Celsius\n    self._p0 = self.pressure &gt;&gt; Pressure.hPa\n    self._a0 = self.altitude &gt;&gt; Distance.Foot\n    self._mach = Atmo.machF(self._temperature &gt;&gt; Temperature.Fahrenheit)\n    self.humidity = humidity\n    self._initializing = False\n    self.update_density_ratio()\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.altitude","title":"altitude  <code>property</code>","text":"<pre><code>altitude: Distance\n</code></pre> <p>Altitude relative to sea level</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.pressure","title":"pressure  <code>property</code>","text":"<pre><code>pressure: Pressure\n</code></pre> <p>Unadjusted barometric pressure, a.k.a. station pressure</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: Temperature\n</code></pre> <p>Local air temperature</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.humidity","title":"humidity  <code>property</code> <code>writable</code>","text":"<pre><code>humidity: float\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>Relative humidity [0% to 100%]</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.powder_temp","title":"powder_temp  <code>property</code>","text":"<pre><code>powder_temp: Temperature\n</code></pre> <p>Powder temperature</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_ratio","title":"density_ratio  <code>property</code>","text":"<pre><code>density_ratio: float\n</code></pre> <p>Ratio of current density to standard atmospheric density</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.mach","title":"mach  <code>property</code>","text":"<pre><code>mach: Velocity\n</code></pre> <p>Velocity of sound (Mach 1) for current atmosphere</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard_temperature","title":"standard_temperature  <code>staticmethod</code>","text":"<pre><code>standard_temperature(altitude: Distance) -&gt; Temperature\n</code></pre> <p>Note: This model only valid up to troposphere (~36,000 ft). Args:     altitude: ASL in units of feet. Returns:     ICAO standard temperature for altitude</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>@staticmethod\ndef standard_temperature(altitude: Distance) -&gt; Temperature:\n    \"\"\"\n    Note: This model only valid up to troposphere (~36,000 ft).\n    Args:\n        altitude: ASL in units of feet.\n    Returns:\n        ICAO standard temperature for altitude\n    \"\"\"\n    return Temperature.Fahrenheit(cStandardTemperatureF\n                                  + (altitude &gt;&gt; Distance.Foot) * cLapseRateImperial)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard_pressure","title":"standard_pressure  <code>staticmethod</code>","text":"<pre><code>standard_pressure(altitude: Distance) -&gt; Pressure\n</code></pre> This model only valid up to troposphere (~36,000 ft). <p>Ref: https://en.wikipedia.org/wiki/Barometric_formula#Pressure_equations</p> <p>Args:     altitude: Distance above sea level (ASL) Returns:     ICAO standard pressure for altitude</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>@staticmethod\ndef standard_pressure(altitude: Distance) -&gt; Pressure:\n    \"\"\"\n    Note: This model only valid up to troposphere (~36,000 ft).\n        Ref: https://en.wikipedia.org/wiki/Barometric_formula#Pressure_equations\n    Args:\n        altitude: Distance above sea level (ASL)\n    Returns:\n        ICAO standard pressure for altitude\n    \"\"\"\n    return Pressure.hPa(cStandardPressureMetric\n        * math.pow(1 + cLapseRateMetric * (altitude &gt;&gt; Distance.Meter) / (cStandardTemperatureC + cDegreesCtoK),\n                   cPressureExponent))\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.standard","title":"standard  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>standard = icao\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.icao","title":"icao  <code>staticmethod</code>","text":"<pre><code>icao(altitude: Union[float, Distance] = 0, temperature: Optional[Temperature] = None, humidity: float = cStandardHumidity) -&gt; Atmo\n</code></pre> <p>Note: This model only valid up to troposphere (~36,000 ft). Args:     altitude: relative to sea level     temperature: air temperature Returns:     Atmo instance of standard ICAO atmosphere at given altitude.     If temperature not specified uses standard temperature.</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>@staticmethod\ndef icao(altitude: Union[float, Distance] = 0, temperature: Optional[Temperature] = None, humidity: float = cStandardHumidity) -&gt; 'Atmo':\n    \"\"\"\n    Note: This model only valid up to troposphere (~36,000 ft).\n    Args:\n        altitude: relative to sea level\n        temperature: air temperature\n    Returns:\n        Atmo instance of standard ICAO atmosphere at given altitude.\n        If temperature not specified uses standard temperature.\n    \"\"\"\n    altitude = PreferredUnits.distance(altitude)\n    if temperature is None:\n        temperature = Atmo.standard_temperature(altitude)\n    pressure = Atmo.standard_pressure(altitude)\n\n    return Atmo(altitude, pressure, temperature, humidity)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machF","title":"machF  <code>staticmethod</code>","text":"<pre><code>machF(fahrenheit: float) -&gt; float\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fahrenheit</code> <code>float</code> <p>Fahrenheit temperature</p> required <p>Returns:     Mach 1 in fps for given temperature</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>@staticmethod\ndef machF(fahrenheit: float) -&gt; float:\n    \"\"\"\n    Args:\n        fahrenheit: Fahrenheit temperature\n    Returns:\n        Mach 1 in fps for given temperature\n    \"\"\"\n    if fahrenheit &lt; -cDegreesFtoR:\n        fahrenheit = cLowestTempF\n        warnings.warn(f\"Invalid temperature: {fahrenheit}\u00b0F. Adjusted to ({cLowestTempF}\u00b0F).\"\n                      , RuntimeWarning)\n    return math.sqrt(fahrenheit + cDegreesFtoR) * cSpeedOfSoundImperial\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.machC","title":"machC  <code>staticmethod</code>","text":"<pre><code>machC(celsius: float) -&gt; float\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>celsius</code> <code>float</code> <p>Celsius temperature</p> required <p>Returns:     Mach 1 in m/s for Celsius temperature</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>@staticmethod\ndef machC(celsius: float) -&gt; float:\n    \"\"\"\n    Args:\n        celsius: Celsius temperature\n    Returns:\n        Mach 1 in m/s for Celsius temperature\n    \"\"\"\n    if celsius &lt; -cDegreesCtoK:\n        bad_temp = celsius\n        celsius = Atmo.cLowestTempC\n        warnings.warn(f\"Invalid temperature: {bad_temp}\u00b0C. Adjusted to ({celsius}\u00b0C).\"\n                      , RuntimeWarning)\n    return Atmo.machK(celsius + cDegreesCtoK)\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_metric","title":"density_metric  <code>property</code>","text":"<pre><code>density_metric: float\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>density in kg/m^3</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.density_imperial","title":"density_imperial  <code>property</code>","text":"<pre><code>density_imperial: float\n</code></pre> <p>Returns:</p> Type Description <code>float</code> <p>density in lb/ft^3</p>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.temperature_at_altitude","title":"temperature_at_altitude","text":"<pre><code>temperature_at_altitude(altitude: float) -&gt; float\n</code></pre> <p>Temperature at altitude interpolated from zero conditions using lapse rate. Args:     altitude: ASL in ft Returns:     temperature in \u00b0C</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>def temperature_at_altitude(self, altitude: float) -&gt; float:\n    \"\"\"\n    Temperature at altitude interpolated from zero conditions using lapse rate.\n    Args:\n        altitude: ASL in ft\n    Returns:\n        temperature in \u00b0C\n    \"\"\"\n    t = (altitude - self._a0) * cLapseRateKperFoot + self._t0\n    if t &lt; Atmo.cLowestTempC:\n        t = Atmo.cLowestTempC\n        warnings.warn(f\"Temperature interpolated from altitude fell below minimum temperature limit.  \"\n                      f\"Model not accurate here.  Temperature bounded at cLowestTempF: {cLowestTempF}\u00b0F.\"\n                      , RuntimeWarning)\n    return t\n</code></pre>"},{"location":"api/conditions/atmo/#py_ballisticcalc.conditions.Atmo.get_density_factor_and_mach_for_altitude","title":"get_density_factor_and_mach_for_altitude","text":"<pre><code>get_density_factor_and_mach_for_altitude(altitude: float) -&gt; Tuple[float, float]\n</code></pre> <p>Ref: https://en.wikipedia.org/wiki/Barometric_formula#Density_equations Args:     altitude: ASL in units of feet.         Note: Altitude above 36,000 ft not modelled this way. Returns:     density ratio and Mach 1 (fps) for the specified altitude</p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>def get_density_factor_and_mach_for_altitude(self, altitude: float) -&gt; Tuple[float, float]:\n    \"\"\"\n    Ref: https://en.wikipedia.org/wiki/Barometric_formula#Density_equations\n    Args:\n        altitude: ASL in units of feet.\n            Note: Altitude above 36,000 ft not modelled this way.\n    Returns:\n        density ratio and Mach 1 (fps) for the specified altitude\n    \"\"\"\n    # Within 30 ft of initial altitude use initial values to save compute\n    if math.fabs(self._a0 - altitude) &lt; 30:\n        mach = self._mach\n        density_ratio = self._density_ratio\n    else:\n        if altitude &gt; 36089:\n            warnings.warn(\"Density request for altitude above troposphere.\"\n                           \" Atmospheric model not valid here.\", RuntimeWarning)\n        t = self.temperature_at_altitude(altitude) + cDegreesCtoK\n        mach = Velocity.MPS(Atmo.machK(t)) &gt;&gt; Velocity.FPS\n        p = self.pressure_at_altitude(altitude)\n        density_delta = ((self._t0 + cDegreesCtoK) * p) / (self._p0 * t)\n        density_ratio = self._density_ratio * density_delta\n        # # Alternative simplified model:\n        # # Ref https://en.wikipedia.org/wiki/Density_of_air#Exponential_approximation\n        # # see doc/'Air Density Models.svg' for comparison\n        #density_ratio = self._density_ratio * math.exp(-(altitude - self._a0) / 34122)\n    return density_ratio, mach\n</code></pre>"},{"location":"api/conditions/shot/","title":"Shot","text":"<p>Shot </p> <p>A base class for creating Shot. Stores shot parameters for the trajectory calculation.</p> <p>Attributes:</p> Name Type Description <code>look_angle</code> <code>Angular</code> <p>Angle of sight line relative to horizontal. If the look_angle != 0 then any target in sight crosshairs will be at a different altitude:     With target_distance = sight distance to a target (i.e., as through a rangefinder):         * Horizontal distance X to target = cos(look_angle) * target_distance         * Vertical distance Y to target = sin(look_angle) * target_distance</p> <code>relative_angle</code> <code>Angular</code> <p>Elevation adjustment added to weapon.zero_elevation for a particular shot.</p> <code>cant_angle</code> <code>Angular</code> <p>Tilt of gun from vertical, which shifts any barrel elevation from the vertical plane into the horizontal plane by sine(cant_angle)</p> <code>weapon</code> <code>Weapon</code> <p>Weapon instance uses for making shot</p> <code>ammo</code> <code>Ammo</code> <p>Ammo instance uses for making shot</p> <code>atmo</code> <code>Atmo</code> <p>Atmo instance uses for making shot</p> <p>Parameters:</p> Name Type Description Default <code>look_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Angle of sight line relative to horizontal. If the look_angle != 0 then any target in sight crosshairs will be at a different altitude:     With target_distance = sight distance to a target (i.e., as through a rangefinder):         * Horizontal distance X to target = cos(look_angle) * target_distance         * Vertical distance Y to target = sin(look_angle) * target_distance</p> <code>None</code> <code>relative_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Elevation adjustment added to weapon.zero_elevation for a particular shot.</p> <code>None</code> <code>cant_angle</code> <code>Optional[Union[float, Angular]]</code> <p>Tilt of gun from vertical, which shifts any barrel elevation from the vertical plane into the horizontal plane by sine(cant_angle)</p> <code>None</code> <code>weapon</code> <code>Weapon</code> <p>Weapon instance used for making shot</p> required <code>ammo</code> <code>Ammo</code> <p>Ammo instance used for making shot</p> required <code>atmo</code> <code>Optional[Atmo]</code> <p>Atmo instance used for making shot</p> <code>None</code> <code>winds</code> <code>Optional[List[Wind]]</code> <p>list of winds used for making shot</p> <code>None</code> Example <p>This is how you can create a shot <pre><code>from py_ballisticcalc import Weapon, Ammo, Atmo, Wind\nshot = Shot(\n    weapon=Weapon(...),\n    ammo=Ammo(...),\n    look_angle=Unit.Degree(5),\n    relative_angle=Unit.Degree(0),\n    cant_angle=Unit.Degree(0),\n    atmo=Atmo(...),\n    winds=[Wind(...), ... ]\n)\n</code></pre></p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>def __init__(self,\n             weapon: Weapon,\n             ammo: Ammo,\n             look_angle: Optional[Union[float, Angular]] = None,\n             relative_angle: Optional[Union[float, Angular]] = None,\n             cant_angle: Optional[Union[float, Angular]] = None,\n\n             atmo: Optional[Atmo] = None,\n             winds: Optional[List[Wind]] = None\n             ):\n    \"\"\"\n    A base class for creating Shot.\n    Stores shot parameters for the trajectory calculation.\n\n    Args:\n        look_angle: Angle of sight line relative to horizontal.\n            If the look_angle != 0 then any target in sight crosshairs will be at a different altitude:\n                With target_distance = sight distance to a target (i.e., as through a rangefinder):\n                    * Horizontal distance X to target = cos(look_angle) * target_distance\n                    * Vertical distance Y to target = sin(look_angle) * target_distance\n        relative_angle: Elevation adjustment added to weapon.zero_elevation for a particular shot.\n        cant_angle: Tilt of gun from vertical, which shifts any barrel elevation\n            from the vertical plane into the horizontal plane by sine(cant_angle)\n        weapon: Weapon instance used for making shot\n        ammo: Ammo instance used for making shot\n        atmo: Atmo instance used for making shot\n        winds: list of winds used for making shot\n\n    Example:\n        This is how you can create a shot\n        ```python\n        from py_ballisticcalc import Weapon, Ammo, Atmo, Wind\n        shot = Shot(\n            weapon=Weapon(...),\n            ammo=Ammo(...),\n            look_angle=Unit.Degree(5),\n            relative_angle=Unit.Degree(0),\n            cant_angle=Unit.Degree(0),\n            atmo=Atmo(...),\n            winds=[Wind(...), ... ]\n        )\n        ```\n    \"\"\"\n    self.look_angle = PreferredUnits.angular(look_angle or 0)\n    self.relative_angle = PreferredUnits.angular(relative_angle or 0)\n    self.cant_angle = PreferredUnits.angular(cant_angle or 0)\n    self.weapon = weapon\n    self.ammo = ammo\n    self.atmo = atmo or Atmo.icao()\n    self._winds = winds or [Wind()]\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.look_angle","title":"look_angle  <code>instance-attribute</code>","text":"<pre><code>look_angle: Angular = angular(look_angle or 0)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.relative_angle","title":"relative_angle  <code>instance-attribute</code>","text":"<pre><code>relative_angle: Angular = angular(relative_angle or 0)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.cant_angle","title":"cant_angle  <code>instance-attribute</code>","text":"<pre><code>cant_angle: Angular = angular(cant_angle or 0)\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.weapon","title":"weapon  <code>instance-attribute</code>","text":"<pre><code>weapon: Weapon = weapon\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.ammo","title":"ammo  <code>instance-attribute</code>","text":"<pre><code>ammo: Ammo = ammo\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.atmo","title":"atmo  <code>instance-attribute</code>","text":"<pre><code>atmo: Atmo = atmo or icao()\n</code></pre>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.winds","title":"winds  <code>property</code> <code>writable</code>","text":"<pre><code>winds: Tuple[Wind, ...]\n</code></pre> <p>Property that returns winds sorted by until distance</p> <p>Returns:</p> Type Description <code>Tuple[Wind, ...]</code> <p>Tuple[Wind, ...] sorted by until distance</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.barrel_elevation","title":"barrel_elevation  <code>property</code>","text":"<pre><code>barrel_elevation: Angular\n</code></pre> <p>Barrel elevation in vertical plane from horizontal</p> <p>Returns:</p> Type Description <code>Angular</code> <p>Angle of barrel elevation in vertical plane from horizontal</p>"},{"location":"api/conditions/shot/#py_ballisticcalc.conditions.Shot.barrel_azimuth","title":"barrel_azimuth  <code>property</code>","text":"<pre><code>barrel_azimuth: Angular\n</code></pre> <p>Horizontal angle of barrel relative to sight line</p> <p>Returns:</p> Type Description <code>Angular</code> <p>Horizontal angle of barrel relative to sight line</p>"},{"location":"api/conditions/wind/","title":"Wind","text":"<p>Wind </p> <p>A base class for creating Wind. Wind direction and velocity by down-range distance.</p> <p>Attributes:</p> Name Type Description <code>velocity</code> <code>Velocity</code> <p>speed of wind</p> <code>direction_from</code> <code>Angular</code> <p>0 is blowing from behind shooter. 90 degrees is blowing from shooter's left towards right.</p> <code>until_distance</code> <code>Distance</code> <p>until which distance the specified wind blows</p> <code>MAX_DISTANCE_FEET</code> <code>float</code> <p>Optional custom max wind distance</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>Optional[Union[float, Velocity]]</code> <p>speed of wind</p> <code>None</code> <code>direction_from</code> <code>Optional[Union[float, Angular]]</code> <p>0 is blowing from behind shooter. 90 degrees is blowing from shooter's left towards right.</p> <code>None</code> <code>until_distance</code> <code>Optional[Union[float, Distance]]</code> <p>until which distance the specified wind blows</p> <code>None</code> <code>MAX_DISTANCE_FEET</code> <p>Optional custom max wind distance</p> required Example <p>This is how you can create a wind <pre><code>from py_ballisticcalc import Wind\nwind = Wind(\n    velocity=Unit.FPS(2700),\n    direction_from=Unit.Degree(20)\n)\n</code></pre></p> Source code in <code>py_ballisticcalc\\conditions.py</code> <pre><code>def __init__(self,\n             velocity: Optional[Union[float, Velocity]] = None,\n             direction_from: Optional[Union[float, Angular]] = None,\n             until_distance: Optional[Union[float, Distance]] = None,\n             *,\n             max_distance_feet: Optional[float] = cMaxWindDistanceFeet):\n    \"\"\"\n    Create a new wind instance with given parameters\n\n    Args:\n        velocity: speed of wind\n        direction_from: 0 is blowing from behind shooter.\n            90 degrees is blowing from shooter's left towards right.\n        until_distance: until which distance the specified wind blows\n        MAX_DISTANCE_FEET: Optional custom max wind distance\n\n    Example:\n        This is how you can create a wind\n        ```python\n        from py_ballisticcalc import Wind\n        wind = Wind(\n            velocity=Unit.FPS(2700),\n            direction_from=Unit.Degree(20)\n        )\n        ```\n    \"\"\"\n\n    self.MAX_DISTANCE_FEET = float(max_distance_feet or cMaxWindDistanceFeet)\n    self.velocity = PreferredUnits.velocity(velocity or 0)\n    self.direction_from = PreferredUnits.angular(direction_from or 0)\n    self.until_distance = PreferredUnits.distance(until_distance or Distance.Foot(self.MAX_DISTANCE_FEET))\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.velocity","title":"velocity  <code>instance-attribute</code>","text":"<pre><code>velocity: Velocity = velocity(velocity or 0)\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.direction_from","title":"direction_from  <code>instance-attribute</code>","text":"<pre><code>direction_from: Angular = angular(direction_from or 0)\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.until_distance","title":"until_distance  <code>instance-attribute</code>","text":"<pre><code>until_distance: Distance = distance(until_distance or Foot(MAX_DISTANCE_FEET))\n</code></pre>"},{"location":"api/conditions/wind/#py_ballisticcalc.conditions.Wind.MAX_DISTANCE_FEET","title":"MAX_DISTANCE_FEET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_DISTANCE_FEET: float = float(max_distance_feet or cMaxWindDistanceFeet)\n</code></pre>"},{"location":"api/munition/ammo/","title":"Ammo","text":"<p>A base class for creating Weapon.</p> <p>Attributes:</p> Name Type Description <code>dm</code> <code>DragModel</code> <p>DragModel for projectile</p> <code>mv</code> <code>Velocity</code> <p>Muzzle Velocity</p> <code>powder_temp</code> <code>Temperature</code> <p>Baseline temperature that produces the given mv</p> <code>temp_modifier</code> <code>float</code> <p>Change in velocity w temperature: % per 15\u00b0C. Can be computed with .calc_powder_sens().  Only applies if:     Settings.use_powder_sensitivity = True</p> <code>use_powder_sensitivity</code> <code>bool</code> <p>Flag to allow to adjust muzzle velocity to the powder sensitivity</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>DragModel</code> <p>drag model</p> required <code>mv</code> <code>Union[float, Velocity]</code> <p>muzzle velocity at given powder temperature</p> required <code>powder_temp</code> <code>Optional[Union[float, Temperature]]</code> <p>powder temperature</p> <code>None</code> <code>temp_modifier</code> <code>float</code> <p>Change in velocity w temperature: % per 15\u00b0C. Can be computed with .calc_powder_sens().  Only applies if: Ammo.use_powder_sensitivity = True</p> <code>0</code> <code>use_powder_sensitivity</code> <code>bool</code> <p>should adjust muzzle velocity using powder sensitivity</p> <code>False</code> Example <p>This is how you can create a weapon</p> <pre><code>from py_ballisticcalc import Ammo, Unit, DragModel\n\nammo = Ammo(\n    dm=DragModel(\n        bc=0.381,\n        drag_table=TableG7,\n        weight=Unit.Grain(300),\n        length=Unit.Inch(1.7),\n        diameter=Unit.Inch(0.338),\n    ),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True,\n)\n</code></pre> Source code in <code>py_ballisticcalc\\munition.py</code> <pre><code>def __init__(self,\n             dm: DragModel,\n             mv: Union[float, Velocity],\n             powder_temp: Optional[Union[float, Temperature]] = None,\n             temp_modifier: float = 0,\n             use_powder_sensitivity: bool = False):\n    \"\"\"\n    Create a new ammo instance with given parameters\n\n    Args:\n        dm: drag model\n        mv: muzzle velocity at given powder temperature\n        powder_temp: powder temperature\n        temp_modifier: Change in velocity w temperature: % per 15\u00b0C.\n            Can be computed with .calc_powder_sens().  Only applies if:\n            Ammo.use_powder_sensitivity = True\n        use_powder_sensitivity: should adjust muzzle velocity using powder sensitivity\n\n    Example:\n        This is how you can create a weapon\n\n        ```python\n        from py_ballisticcalc import Ammo, Unit, DragModel\n\n        ammo = Ammo(\n            dm=DragModel(\n                bc=0.381,\n                drag_table=TableG7,\n                weight=Unit.Grain(300),\n                length=Unit.Inch(1.7),\n                diameter=Unit.Inch(0.338),\n            ),\n            mv=Unit.MPS(815),\n            powder_temp=Unit.Celsius(15),\n            temp_modifier=0.123,\n            use_powder_sensitivity=True,\n        )\n        ```\n    \"\"\"\n    self.dm = dm\n    self.mv = PreferredUnits.velocity(mv or 0)\n    self.powder_temp = PreferredUnits.temperature(powder_temp or Temperature.Celsius(15))\n    self.temp_modifier = temp_modifier or 0\n    self.use_powder_sensitivity = use_powder_sensitivity\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.dm","title":"dm  <code>instance-attribute</code>","text":"<pre><code>dm: DragModel = dm\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.mv","title":"mv  <code>instance-attribute</code>","text":"<pre><code>mv: Velocity = velocity(mv or 0)\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.powder_temp","title":"powder_temp  <code>instance-attribute</code>","text":"<pre><code>powder_temp: Temperature = temperature(powder_temp or Celsius(15))\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.temp_modifier","title":"temp_modifier  <code>instance-attribute</code>","text":"<pre><code>temp_modifier: float = temp_modifier or 0\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.use_powder_sensitivity","title":"use_powder_sensitivity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>use_powder_sensitivity: bool = use_powder_sensitivity\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.calc_powder_sens","title":"calc_powder_sens","text":"<pre><code>calc_powder_sens(other_velocity: Union[float, Velocity], other_temperature: Union[float, Temperature]) -&gt; float\n</code></pre> <p>Calculates velocity correction by temperature change; assigns to self.temp_modifier</p> <p>Parameters:</p> Name Type Description Default <code>other_velocity</code> <code>Union[float, Velocity]</code> <p>other velocity at other_temperature</p> required <code>other_temperature</code> <code>Union[float, Temperature]</code> <p>other temperature</p> required <p>Returns:</p> Type Description <code>float</code> <p>temperature modifier in terms %v_delta/15\u00b0C</p> Example <pre><code>powder_sensitivity = ammo.calc_powder_sens(\n    Unit.MPS(830),\n    Unit.Celsius(200)\n)\n</code></pre> Source code in <code>py_ballisticcalc\\munition.py</code> <pre><code>def calc_powder_sens(self, other_velocity: Union[float, Velocity],\n                     other_temperature: Union[float, Temperature]) -&gt; float:\n    \"\"\"Calculates velocity correction by temperature change; assigns to self.temp_modifier\n\n    Args:\n        other_velocity: other velocity at other_temperature\n        other_temperature: other temperature\n\n    Returns:\n        temperature modifier in terms %v_delta/15\u00b0C\n\n    Example:\n        ```python\n        powder_sensitivity = ammo.calc_powder_sens(\n            Unit.MPS(830),\n            Unit.Celsius(200)\n        )\n        ```\n    \"\"\"\n    v0 = self.mv &gt;&gt; Velocity.MPS\n    t0 = self.powder_temp &gt;&gt; Temperature.Celsius\n    v1 = PreferredUnits.velocity(other_velocity) &gt;&gt; Velocity.MPS\n    t1 = PreferredUnits.temperature(other_temperature) &gt;&gt; Temperature.Celsius\n\n    v_delta = math.fabs(v0 - v1)\n    t_delta = math.fabs(t0 - t1)\n    v_lower = v1 if v1 &lt; v0 else v0\n\n    if v_delta == 0 or t_delta == 0:\n        raise ValueError(\n            \"Temperature modifier error, other velocity\"\n            \" and temperature can't be same as default\"\n        )\n    self.temp_modifier = v_delta / t_delta * (15 / v_lower)  # * 100\n    return self.temp_modifier\n</code></pre>"},{"location":"api/munition/ammo/#py_ballisticcalc.munition.Ammo.get_velocity_for_temp","title":"get_velocity_for_temp","text":"<pre><code>get_velocity_for_temp(current_temp: Union[float, Temperature]) -&gt; Velocity\n</code></pre> <p>Calculates muzzle velocity at temperature, based on temp_modifier.</p> <p>Parameters:</p> Name Type Description Default <code>current_temp</code> <code>Union[float, Temperature]</code> <p>Temperature of cartridge powder</p> required <p>Returns:</p> Type Description <code>Velocity</code> <p>Muzzle velocity corrected to current_temp</p> Example <pre><code>muzzle_velocity = ammo.get_velocity_for_temp(\n    Unit.Celsius(200)\n)\n</code></pre> Source code in <code>py_ballisticcalc\\munition.py</code> <pre><code>def get_velocity_for_temp(self, current_temp: Union[float, Temperature]) -&gt; Velocity:\n    \"\"\"Calculates muzzle velocity at temperature, based on temp_modifier.\n\n    Args:\n        current_temp: Temperature of cartridge powder\n\n    Returns:\n        Muzzle velocity corrected to current_temp\n\n    Example:\n        ```python\n        muzzle_velocity = ammo.get_velocity_for_temp(\n            Unit.Celsius(200)\n        )\n        ```\n    \"\"\"\n    if not self.use_powder_sensitivity:\n        return self.mv\n    try:\n        v0 = self.mv &gt;&gt; Velocity.MPS\n        t0 = self.powder_temp &gt;&gt; Temperature.Celsius\n        t1 = PreferredUnits.temperature(current_temp) &gt;&gt; Temperature.Celsius\n        t_delta = t1 - t0\n        muzzle_velocity = self.temp_modifier / (15 / v0) * t_delta + v0\n    except ZeroDivisionError:\n        muzzle_velocity = 0\n    return Velocity.MPS(muzzle_velocity)\n</code></pre>"},{"location":"api/munition/weapon/","title":"Weapon","text":"<p>A base class for creating Weapon.</p> <p>Attributes:</p> Name Type Description <code>sight_height</code> <code>Distance</code> <p>Sight height</p> <code>twist</code> <code>Distance</code> <p>Twist</p> <code>zero_elevation</code> <code>Angular</code> <p>Zero elevation</p> <code>sight</code> <code>Optional[Sight]</code> <p>Sight properties</p> <p>Parameters:</p> Name Type Description Default <code>sight_height</code> <code>Optional[Union[float, Distance]]</code> <p>Vertical distance from center of bore line to center of sight line.</p> <code>None</code> <code>twist</code> <code>Optional[Union[float, Distance]]</code> <p>Distance for barrel rifling to complete one complete turn. Positive value =&gt; right-hand twist, negative value =&gt; left-hand twist.</p> <code>None</code> <code>zero_elevation</code> <code>Optional[Union[float, Angular]]</code> <p>Angle of barrel relative to sight line when sight is set to \"zero.\" (Typically computed by ballistic Calculator.)</p> <code>None</code> <code>sight</code> <code>Optional[Sight]</code> <p>Sight properties</p> <code>None</code> Example <p>This is how you can create a weapon</p> <pre><code>from py_ballisticcalc import Weapon, Unis, Sight\n\nweapon = Weapon(\n    sight_height=Unit.Inch(2.),\n    twist=Unit.Inch(10.),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight(\n        'FFP', 2,\n        h_click_size=Unit.Mil(0.2),\n        v_click_size=Unit.Mil(0.2)\n    )\n)\n</code></pre> Source code in <code>py_ballisticcalc\\munition.py</code> <pre><code>def __init__(self,\n             sight_height: Optional[Union[float, Distance]] = None,\n             twist: Optional[Union[float, Distance]] = None,\n             zero_elevation: Optional[Union[float, Angular]] = None,\n             sight: Optional[Sight] = None):\n    \"\"\"\n    Create a new weapon instance with given parameters\n\n    Args:\n        sight_height: Vertical distance from center of bore line to center of sight line.\n        twist: Distance for barrel rifling to complete one complete turn.\n            Positive value =&gt; right-hand twist, negative value =&gt; left-hand twist.\n        zero_elevation: Angle of barrel relative to sight line when sight is set to \"zero.\"\n            (Typically computed by ballistic Calculator.)\n        sight: Sight properties\n\n    Example:\n        This is how you can create a weapon\n\n        ```python\n        from py_ballisticcalc import Weapon, Unis, Sight\n\n        weapon = Weapon(\n            sight_height=Unit.Inch(2.),\n            twist=Unit.Inch(10.),\n            zero_elevation=Unit.Mil(0),\n            sight=Sight(\n                'FFP', 2,\n                h_click_size=Unit.Mil(0.2),\n                v_click_size=Unit.Mil(0.2)\n            )\n        )\n        ```\n    \"\"\"\n    self.sight_height = PreferredUnits.sight_height(sight_height or 0)\n    self.twist = PreferredUnits.twist(twist or 0)\n    self.zero_elevation = PreferredUnits.angular(zero_elevation or 0)\n    self.sight = sight\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.sight_height","title":"sight_height  <code>instance-attribute</code>","text":"<pre><code>sight_height: Distance = sight_height(sight_height or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.twist","title":"twist  <code>instance-attribute</code>","text":"<pre><code>twist: Distance = twist(twist or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.zero_elevation","title":"zero_elevation  <code>instance-attribute</code>","text":"<pre><code>zero_elevation: Angular = angular(zero_elevation or 0)\n</code></pre>"},{"location":"api/munition/weapon/#py_ballisticcalc.munition.Weapon.sight","title":"sight  <code>instance-attribute</code>","text":"<pre><code>sight: Optional[Sight] = sight\n</code></pre>"},{"location":"concepts/constants/","title":"Constants","text":"API Documentation <p><code>py_ballisticcalc.constants</code></p>"},{"location":"concepts/drag_model/","title":"DragModel","text":"API Documentation <p><code>py_ballisticcalc.drag_model</code></p>"},{"location":"concepts/trajectory_data/","title":"TrajectoryData","text":"API Documentation <p><code>py_ballisticcalc.trajectory_data</code></p>"},{"location":"concepts/unit/","title":"\ud83d\udccf Unit","text":"API Documentation <p><code>py_ballisticcalc.conditions.unit</code></p>"},{"location":"concepts/vector/","title":"Vector","text":"API Documentation <p><code>py_ballisticcalc.vector.Vector</code></p>"},{"location":"concepts/conditions/atmo/","title":"\ud83c\udf21\ufe0f Atmo","text":"API Documentation <p><code>py_ballisticcalc.conditions.Atmo</code></p>"},{"location":"concepts/conditions/shot/","title":"\ud83c\udfaf Shot","text":"API Documentation <p><code>py_ballisticcalc.conditions.Shot</code></p>"},{"location":"concepts/conditions/wind/","title":"\ud83d\udca8 Wind","text":"API Documentation <p><code>py_ballisticcalc.conditions.Wind</code></p>"},{"location":"concepts/munition/ammo/","title":"\ud83d\udca3 Ammo","text":"API Documentation <p><code>py_ballisticcalc.munition.Ammo</code></p> <p>The way to define <code>projectile</code> properties in py-ballisticcalc is via Ammo dataclass. Ammo instances are simply and reusable.</p>"},{"location":"concepts/munition/ammo/#ammo-initialization","title":"Ammo initialization","text":"<p>Import the necessary types to create a Weapon instance <pre><code>from py_ballisticcalc import Ammo, Unit, DragModel\n</code></pre></p> <p>Then create a weapon <pre><code>ammo = Ammo(\n    dm=DragModel(\n        bc=0.381,\n        drag_table=TableG7,\n        weight=Unit.Grain(300),\n        length=Unit.Inch(1.7),\n        diameter=Unit.Inch(0.338),\n    ),\n    mv=Unit.MPS(815),\n    powder_temp=Unit.Celsius(15),\n    temp_modifier=0.123,\n    use_powder_sensitivity=True,\n)\n</code></pre> In this example, we use calls to <code>Unit</code> to initialize <code>Ammo</code> fields with specific unit types. We also can do it using <code>float</code>'s then fields will be initialized with unit types defined in <code>PreferredUnit</code> class, or we can directly specify the dimension with referencing to dimension type class</p> <p>Fields of a <code>Ammo</code> can be accessed as normal attributes of <code>ammo</code> instance</p> <p>Ammo instance is mutable object and field values can be changed through attribute assignment</p> <p>Warning</p> <p>Direct values assignment to attributes of <code>ammo</code> is restricted and not recommended, it can be not reinitialized properly after that</p> <p>Weapon possess the following methods and attributes:</p> <ul> <li><code>dm</code>: DragModel for projectile</li> <li><code>mv</code>: Muzzle Velocity</li> <li><code>powder_temp</code>: Baseline temperature that produces the given mv</li> <li><code>temp_modifier</code>: Change in velocity w temperature: % per 15\u00b0C.</li> <li><code>use_powder_sensitivity</code>: Flag to enable adjusting muzzle velocity to powder temperature</li> <li><code>calc_powder_sens</code>: Method to calculate powder temperature sensitivity coefficient</li> <li><code>get_velocity_for_temp</code>: Method to get adjusted muzzle velocity to powder sensitivity</li> </ul> <p>Note</p> <p>See the API documentation of <code>Ammo</code> for the class definition including a full list of methods and attributes.</p>"},{"location":"concepts/munition/weapon/","title":"\ud83d\udd2b Weapon","text":"API Documentation <p><code>py_ballisticcalc.munition.Weapon</code></p> <p>The way to define <code>weapon</code> properties in py-ballisticcalc is via Weapon dataclass. Weapon instances are simply and reusable.</p>"},{"location":"concepts/munition/weapon/#weapon-initialization","title":"Weapon initialization","text":"<p>Import the necessary types to create a Weapon instance <pre><code>from py_ballisticcalc import Weapon, Unit, Sight\n</code></pre></p> <p>Then create a weapon <pre><code>weapon = Weapon(\n    sight_height=Unit.Inch(2.),\n    twist=Unit.Inch(10.),\n    zero_elevation=Unit.Mil(0),\n    sight=Sight(\n        'FFP', 2,\n        h_click_size=Unit.Mil(0.2),\n        v_click_size=Unit.Mil(0.2)\n    )\n)\n</code></pre> In this example, we use calls to <code>Unit</code> to initialize <code>Weapon</code> fields with specific unit types. We also can do it using <code>float</code>'s then fields will be initialized with unit types defined in <code>PreferredUnit</code> class, or we can directly specify the dimension with referencing to dimension type class</p> <p>Fields of a <code>Weapon</code> can be accessed as normal attributes of <code>weapon</code> instance</p> <p>Weapon instance is mutable object and field values can be changed through attribute assignment</p>"},{"location":"concepts/munition/weapon/#weapon-methods-and-properties","title":"Weapon methods and properties","text":"<p>Weapon possess the following methods and attributes:</p> <ul> <li><code>sight_height</code>: Sight height, given distance from barrel axis and sight lense axis </li> <li><code>twist</code>: Given barrel twist, accepted as ratio 1 / given value </li> <li><code>zero_elevation</code>: Barrel elevation - the angle that displays how barrel should be elevated to hit target on zeroing distance </li> <li><code>sight</code>: Sight type and properties</li> </ul> <p>Note</p> <p>See the API documentation of <code>Weapon</code> for the class definition including a full list of methods and attributes.</p>"}]}